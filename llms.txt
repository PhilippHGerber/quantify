# Project Documentation: quantify v0.5.0

Generated by llmifier on: 2025-06-29T16:15:53
Extraction Mode: full
Project Type: dart

---

<!-- BEGIN FILE: [v0.5.0] README.md -->
# Quantify

[![pub version](https://img.shields.io/pub/v/quantify.svg)](https://pub.dev/packages/quantify)
[![license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/PhilippHGerber/quantify/blob/main/LICENSE)

A type-safe unit of measurement converter library for Dart with elegant syntax, high precision, and optimal performance.

## Why `quantify`?

`quantify` makes working with physical units in Dart safer, more readable, and efficient:

* **Type Safety:** Prevents unit mismatch errors at compile-time.
* **Elegant API:** Intuitive syntax like `10.m` or `length.inKm`.
* **Precise & Performant:** Uses `double` and direct conversion factors for speed and to minimize rounding errors.
* **Immutable:** `Quantity` objects are immutable for safer code.
* **Configurable Output:** Highly flexible `toString()` for customized formatting.
* **Lightweight:** Minimal dependencies.

## Quick Start

```dart
import 'package:quantify/quantify.dart';
// For locale-specific number formatting, add 'intl' to your pubspec.yaml
// and import 'package:intl/intl.dart';

void main() {
  // Create quantities
  final pathA = 1500.m;
  final pathB = 2.5.km;

  // Convert to value / a new Quantity object
  double pathInKm = pathA.inKm;
  final pathAsKm = pathA.asKm;

  // Convert and print
  print(pathA.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 1));  // Output: "1.5 km"
  print(pathB.toString(targetUnit: LengthUnit.mile, fractionDigits: 2));  // Output: "1.55 mi" (approx.)

  // Arithmetic
  final distance = pathA + pathB; // pathB is converted to meters
  print(distance.toString(fractionDigits: 0));  // Output: "4000 m"
  print(distance.toString(
    targetUnit: LengthUnit.yard,
    fractionDigits: 0,
  ));  // Output: "4374 yd" (approx., with non-breaking space)

  // Locale-specific example (if 'intl' is used)
  // final distanceDE = 1234.567.m;
  print(distanceDE.toString(
    targetUnit: LengthUnit.kilometer,
    fractionDigits: 2,
    locale: 'de_DE',
  ));  // Output: "1,23 km"
}
```

## Installation

Add to your `pubspec.yaml`:

```yaml
dependencies:
  quantify: ^0.5.0 # Or latest version
  # Optional, for locale-specific number formatting:
  # intl: ^0.19.0
```

Then run `dart pub get` or `flutter pub get`.

## Supported Units

The library supports a comprehensive range of physical quantities, including all 7 SI base units and many derived units:

| Quantity Type           | Status | Units Available                                                                                                                        | Notes / SI Base Unit Ref. |
| :---------------------- | :----: | :------------------------------------------------------------------------------------------------------------------------------------- | :------------------------ |
| **Length**              |   ‚úÖ    | **`m`** (meter), `km`, `hm`, `dam`, `dm`, `cm`, `mm`, `Œºm`, `nm`, `pm`, `fm`, `in`, `ft`, `yd`, `mi`, `nmi`, `AU`, `ly`, `pc`, `√Ö`     | SI Base: Meter (m)        |
| **Mass**                |   ‚úÖ    | **`kg`** (kilogram), `hg`, `dag`, `g`, `dg`, `cg`, `mg`, `Œºg`, `ng`, `t`, `lb`, `oz`, `st`, `slug`, `short ton`, `long ton`, `u`, `ct` | SI Base: Kilogram (kg)    |
| **Time**                |   ‚úÖ    | **`s`** (second), `Œºs`, `ns`, `ps`, `ms`, `min`, `h`, `d`, `wk`, `mo`, `yr`                                                            | SI Base: Second (s)       |
| **Electric Current**    |   ‚úÖ    | **`A`** (ampere), `mA`, `ŒºA`, `nA`, `kA`                                                                                               | SI Base: Ampere (A)       |
| **Temperature**         |   ‚úÖ    | **`K`** (kelvin), `¬∞C` (celsius), `¬∞F` (fahrenheit), `¬∞R` (rankine)                                                                    | SI Base: Kelvin (K)       |
| **Amount of Substance** |   ‚úÖ    | **`mol`** (mole), `mmol`, `Œºmol`, `nmol`, `pmol`, `kmol`                                                                               | SI Base: Mole (mol)       |
| **Luminous Intensity**  |   ‚úÖ    | **`cd`** (candela), `mcd`, `kcd`                                                                                                       | SI Base: Candela (cd)     |
| --- Derived ---         |        |                                                                                                                                        |                           |
| **Pressure**            |   ‚úÖ    | **`Pa`** (Pascal), `atm`, `bar`, `psi`, `Torr`, `mmHg`, `inHg`, `kPa`, `hPa`, `mbar`, `cmH‚ÇÇO`, `inH‚ÇÇO`                                 | Derived SI: N/m¬≤          |
| **Angle**               |   ‚úÖ    | **`rad`** (radian), `¬∞` (degree), `grad`, `rev`, `arcmin` ('), `arcsec` ("), `mrad`                                                    | Derived SI: dimensionless |
| **Angular Velocity**    |   ‚úÖ    | **`rad/s`**, `¬∞/s`, `rpm`, `rps`                                                                                                       | Derived SI: 1/s           |
| Area                    |   üóìÔ∏è    | **`m¬≤`** (square meter), `km¬≤`, `cm¬≤`, `ha` (hectare), `acre` ...                                                                      | Derived SI                |
| Volume                  |   üóìÔ∏è    | **`m¬≥`** (cubic meter), `L` (liter), `mL`, `cm¬≥`, `gal` (gallon), `fl oz` ...                                                          | Derived SI                |
| Speed / Velocity        |   üóìÔ∏è    | **`m/s`** (meter per second), `km/h`, `mph`, `knot` ...                                                                                | Derived SI                |
| Acceleration            |   üóìÔ∏è    | **`m/s¬≤`** (meter per second squared), `g` (standard gravity) ...                                                                      | Derived SI                |
| Force                   |   üóìÔ∏è    | **`N`** (Newton), `lbf` (pound-force), `dyn` (dyne) ...                                                                                | Derived SI: kg¬∑m/s¬≤       |
| Energy / Work           |   üóìÔ∏è    | **`J`** (Joule), `kWh` (kilowatt-hour), `cal` (calorie), `eV` (electronvolt) ...                                                       | Derived SI: N¬∑m           |
| Power                   |   üí°    | **`W`** (Watt), `hp` (horsepower) ...                                                                                                  | Derived SI: J/s           |
| Frequency               |   üí°    | **`Hz`** (Hertz), `kHz`, `MHz` ...                                                                                                     | Derived SI: 1/s           |

## Detailed Usage

### Creating Quantities

Use extension methods on `num` for readability:

```dart
final myLength = 25.5.m;
final anotherLength = 10.ft; // feet
final verySmall = 500.nm; // nanometers
final astronomical = 4.2.ly; // light years
```

Or use the constructor of the specific `Quantity` class:

```dart
final specificLength = Length(5.0, LengthUnit.yard);
```

### Converting and Retrieving Values

1. **Get Numerical Value:** Use `in[UnitName]` getters or `getValue(TargetUnit)`.

    ```dart
    final oneMile = 1.0.mi;
    double milesInKm = oneMile.inKm; // approx 1.609344
    double milesInMeters = oneMile.getValue(LengthUnit.meter); // approx 1609.344

    final smallDistance = 1.um; // micrometer
    double inNanometers = smallDistance.inNm; // 1000.0
    ```

2. **Get New `Quantity` Object:** Use `convertTo(TargetUnit)` or `as[UnitName]` getters.

    ```dart
    final tenMeters = 10.m;
    final tenMetersInFeetObj = tenMeters.convertTo(LengthUnit.foot);
    // tenMetersInFeetObj is Length(approx 32.8084, LengthUnit.foot)
    final tenMetersInKmObj = tenMeters.asKm;
    // tenMetersInKmObj is Length(0.01, LengthUnit.kilometer)
    ```

### Formatting Output with `toString()`

The `toString()` method on `Quantity` objects is highly configurable:

```dart
final myDistance = 1578.345.m;

// Default
print(myDistance.toString()); // "1578.345 m"

// Convert to kilometers, 2 fraction digits
print(myDistance.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2));
// Output: "1.58 km"

// Scientific notation with micrometers
final smallLength = 0.000523.m;
print(smallLength.toString(targetUnit: LengthUnit.micrometer, fractionDigits: 0));
// Output: "523 Œºm"
```

### Arithmetic Operations

Standard arithmetic operators (`+`, `-`, `*`, `/` by a scalar) are overloaded. The result's unit is typically that of the left-hand operand. `Temperature` has specific arithmetic rules.

```dart
final segment1 = 500.m;
final segment2 = 0.25.km; // 250 meters
final total = segment1 + segment2; // Result is in meters
print(total.toString()); // "750.0 m"

final scaled = segment1 * 3;
print(scaled.toString()); // "1500.0 m"

// Work with different scales
final bigMass = 5.t; // tonnes
final smallMass = 250.g; // grams
final combined = bigMass + smallMass; // Result: 5.00025 t
```

### Comparisons & Sorting

Quantities are `Comparable`, allowing them to be sorted even if their units differ. `compareTo()` is used for magnitude comparison. The `==` operator checks for equal value AND unit.

```dart
final oneMeter = 1.m;
final hundredCm = 100.cm;
final oneYard = 1.yd;

print(oneMeter.compareTo(hundredCm) == 0); // true (magnitudes are equal)
print(oneMeter == hundredCm);          // false (units are different)

// Sort mixed units
final lengths = [1.mi, 2000.m, 1.km, 5000.ft];
lengths.sort(); // Sorts by physical magnitude
```

## **Managing Imports and Avoiding Conflicts**

`quantify` is designed to be both convenient and robust. By default, importing `package:quantify/quantify.dart` gives you access to all quantities and their handy extensions (like `10.m` or `5.s`).

However, in large projects or when combining `quantify` with other libraries, this might lead to name conflicts with extension methods. To give you full control over what is imported into your project's namespace, `quantify` provides separate entry points for each quantity type.

If you encounter a name conflict or simply want to be more explicit about your dependencies, you can import only the quantities you need.

**Example: Importing only Length and Time**

Instead of the main package, you can import specific libraries:

```dart

// Import only the extensions you need
import 'package:quantify/length.dart';
import 'package:quantify/time.dart';

void main() {
  // Now, only extensions for Length and Time are available.
  final distance = 100.m; // Works
  final duration = 30.s;   // Works

  // This will cause a compile-time error because Mass extensions were not imported.
  // final weight = 70.kg; // ERROR: The getter 'kg' isn't defined for the type 'int'.

  // You can still create the Mass object using its constructor:
  final weight = Mass(70, MassUnit.kilogram); // This always works
}
```

This granular approach ensures that `quantify` can be used safely and effectively in any project, no matter how complex.

## Goals & Roadmap

* **V1.0 (Current):** All 7 SI base units with comprehensive unit coverage
* **V2.0 and Beyond:**
  * **High Precision:** Support for `Decimal`.
  * **Enhanced Quantity Arithmetic:** e.g., `Distance / Time = Speed`.
  * **More Derived Units:** Area, Volume, Speed, Force, Energy, Power, etc.
  * **Serialization support.**

## Contributing

Contributions are welcome! Please open an [Issue](https://github.com/PhilippHGerber/quantify/issues) or a [Pull Request](https://github.com/PhilippHGerber/quantify/pulls).

## License

MIT License - see the `LICENSE` file.

<!-- END FILE: [v0.5.0] README.md -->

<!-- BEGIN FILE: [v0.5.0] CHANGELOG.md -->
# Changelog

All notable changes to the `quantify` package will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.5.0]

2025-06-29

### Added
- Expanded Unit Coverage:
  - Length: Added Mm (megametre) and Gm (gigametre).
  - Mass: Added Mg (megagram) and Gg (gigagram).
  - Time: Added full range of SI prefixes (Gs to cs) and calendar units (fortnight, decade, century).
  - ElectricCurrent: Added CGS units statA (statampere) and abA (abampere/biot).

- Granular Exports: Added separate library entry points (e.g., package:quantify/length.dart) to allow for explicit imports and prevent namespace conflicts.

## [0.4.0]

2025-06-23

### Added

- **New Quantity: `Angle`**
  - `Angle` quantity
  - `AngleUnit`:
    - **`radian` (rad):** The SI-derived unit, used as the base for conversions.
    - **`degree` (¬∞):** The most common unit for angles.
    - **`gradian` (grad):** Unit used in surveying (400 grad in a circle).
    - **`revolution` (rev):** Represents a full circle or turn.
    - **`arcminute` ('):** High-precision unit (1/60 of a degree).
    - **`arcsecond` ("):** High-precision unit (1/60 of an arcminute).
    - **`milliradian` (mrad):** Common in optics and ballistics.
  - Standard arithmetic operators (`+`, `-`, `*`, `/`) for `Angle`.

- **New Quantity: `AngularVelocity`**
  - `AngularVelocity` quantity - represents rotational speed.
  - `AngularVelocityUnit`:
    - **`radianPerSecond` (rad/s):** The SI-derived unit.
    - **`degreePerSecond` (¬∞/s).**
    - **`revolutionPerMinute` (rpm):** A widely used unit for rotational speed.
    - **`revolutionPerSecond` (rps).**
  - Standard arithmetic operators for `AngularVelocity`.

## [0.3.0]

2025-06-21

### Added

- **Expanded Unit Coverage:**
  - **Length:**
    - SI Prefixes: `hm` (hectometer), `dam` (decameter), `dm` (decimeter), `Œºm` (micrometer), `nm` (nanometer), `pm` (picometer), `fm` (femtometer).
    - Astronomical: `AU` (astronomical unit), `ly` (light year), `pc` (parsec).
    - Special: `√Ö` (√•ngstr√∂m).
  - **Mass:**
    - SI Prefixes: `hg` (hectogram), `dag` (decagram), `dg` (decigram), `cg` (centigram), `Œºg` (microgram), `ng` (nanogram).
    - Imperial/US: `short ton`, `long ton`.
    - Special: `u` (atomic mass unit), `ct` (carat).
  - **Time:**
    - SI Prefixes: `Œºs` (microsecond), `ns` (nanosecond), `ps` (picosecond).
    - Calendar: `wk` (week), `mo` (month), `yr` (year).
  - **Temperature:**
    - Absolute Scale: `¬∞R` (rankine).

## [0.2.0]

2025-06-16

### Added

- **New SI Base Quantity Types (completing all 7 SI base units):**
  - **Mass:**
    - `Mass` class and `MassUnit` enum (`kg`, `g`, `mg`, `t` (tonne), `lb`, `oz`, `st` (stone), `slug`).
  - **Amount of Substance (Molar Amount):**
    - `MolarAmount` class and `MolarUnit` enum (`mol`, `mmol`, `¬µmol`, `nmol`, `pmol`, `kmol`).
  - **Electric Current:**
    - `Current` class and `CurrentUnit` enum (`A`, `mA`, `¬µA`, `nA`, `kA`).
  - **Luminous Intensity:**
    - `LuminousIntensity` class and `LuminousIntensityUnit` enum (`cd`, `mcd`, `kcd`).

## [0.1.0]

2025-06-12

### Added

- **Initial Release of `quantify` v0.1.0**
- **Core Functionality:**
  - Type-safe `Quantity` base class for representing physical quantities with a value and a unit.
  - `Unit` interface for defining conversion factors and symbols.
  - Immutable `Quantity` objects.
  - `double` precision for quantity values.
  - Elegant API with extension methods on `num` for quantity creation (e.g., `10.m`, `20.celsius`).
  - Extension methods on `Quantity` for easy value retrieval in target units (e.g., `length.inKm`) and for obtaining new `Quantity` objects in target units (e.g., `length.asKm`).
  - Configurable `toString()` method on `Quantity` objects supporting:
    - Conversion to a `targetUnit` before formatting.
    - Fixed `fractionDigits`.
    - Option to `showUnitSymbol`.
    - Custom `unitSymbolSeparator`.
    - Locale-aware number formatting via `locale` parameter (using `intl` package).
    - Full control over number formatting via `numberFormat` parameter (using `intl` package).
  - Arithmetic operations (`+`, `-`, `*` by scalar, `/` by scalar) for most quantities.
  - Specialized arithmetic for `Temperature` (difference `T - T` returns `double`, ratio `T / T` returns `double`).
  - `Comparable` interface implementation for sorting quantities by magnitude.
  - `==` operator override for value and unit equality.
- **Supported Quantity Types (with units and extensions):**
  - **Length:** Meter (m), Kilometer (km), Centimeter (cm), Millimeter (mm), Inch (in), Foot (ft), Yard (yd), Mile (mi), Nautical Mile (nmi).
  - **Time:** Second (s), Millisecond (ms), Minute (min), Hour (h), Day (d).
  - **Temperature:** Kelvin (K), Celsius (¬∞C), Fahrenheit (¬∞F). Handles affine conversions correctly.
  - **Pressure:** Pascal (Pa), Atmosphere (atm), Bar (bar), PSI (psi), Torr, mmHg, inHg, kPa, hPa, mbar, cmH‚ÇÇO, inH‚ÇÇO.

<!-- END FILE: [v0.5.0] CHANGELOG.md -->

<!-- BEGIN FILE: [v0.5.0] LICENSE -->
Copyright 2025 Philipp H. Gerber

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without
restriction, including without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

<!-- END FILE: [v0.5.0] LICENSE -->

<!-- BEGIN FILE: [v0.5.0] pubspec.yaml -->
name: quantify
description: A type-safe unit of measurement converter library for Dart with elegant syntax, high precision, and optimal performance.
version: 0.5.0

homepage: https://github.com/PhilippHGerber/quantify
repository: https://github.com/PhilippHGerber/quantify
issue_tracker: https://github.com/PhilippHGerber/quantify/issues

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  intl: ">=0.18.1 <0.21.0"
  meta: ^1.16.0

dev_dependencies:
  test: ^1.26.0
  very_good_analysis: ^8.0.0

topics:
  - units
  - unit-converter
  - measurement
  - conversion
  - physics

screenshots:
  - description: "Quantify - Convert SI Units"
    path: pub/quantify.webp

<!-- END FILE: [v0.5.0] pubspec.yaml -->

<!-- BEGIN FILE: [v0.5.0] analysis_options.yaml -->
include: package:very_good_analysis/analysis_options.yaml

formatter:
  page_width: 100
#  trailing_commas: preserve

analyzer:
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"
    - "test/.test_coverage.dart"
    - "bin/cache/**"
    - "lib/generated_plugin_registrant.dart"

  errors:
    unused_import: warning
    todo: ignore

linter:
  rules:
    # Allow relative imports for files within the same package
    always_use_package_imports: false
    # Prefer using relative imports within the same package
    prefer_relative_imports: true
    # Allow lines to exceed 80 characters
    lines_longer_than_80_chars: false
    # Prefer using const constructors where possible
    prefer_const_constructors: true
    # Prefer declaring local variables as final if they are not reassigned
    prefer_final_locals: true
    # Allow mutable literal lists/maps/sets even if they could be const
    prefer_const_literals_to_create_immutables: false
    # Allow explicitly typing closure parameters
    avoid_types_on_closure_parameters: false
    # Allow TODOs without the Flutter-style format (e.g., missing author tags)
    flutter_style_todos: false
    # Use trailing commas for all parameter lists and argument lists.
    require_trailing_commas: true
    # Use enums rather than classes that behave like enums.
    use_enums: true

    # Prototyping and Development:
    # Allow public classes and members without documentation comments
    public_member_api_docs: true

<!-- END FILE: [v0.5.0] analysis_options.yaml -->

<!-- BEGIN FILE: [v0.5.0] lib/angle.dart -->
/// Provides type-safe units for Angle.
///
/// Import this file to use Angle quantities and their extensions on `num`
/// (like `90.degrees`, `1.5.radians`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/angle/angle.dart';
export 'src/units/angle/angle_extensions.dart';
export 'src/units/angle/angle_unit.dart';

<!-- END FILE: [v0.5.0] lib/angle.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/angular_velocity.dart -->
/// Provides type-safe units for Angular Velocity.
///
/// Import this file to use AngularVelocity quantities and their extensions on `num`
/// (like `3000.rpm`, `10.radiansPerSecond`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/angular_velocity/angular_velocity.dart';
export 'src/units/angular_velocity/angular_velocity_extensions.dart';
export 'src/units/angular_velocity/angular_velocity_unit.dart';

<!-- END FILE: [v0.5.0] lib/angular_velocity.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/constants.dart -->
/// Physical, astronomical, and engineering constants for the quantify package.
///
/// This library provides type-safe access to fundamental constants with
/// appropriate units from physics, astronomy, and engineering.
///
/// ## Usage
///
/// ```dart
/// import 'package:quantify/constants.dart';
///
/// // Physical constants
/// final lightSpeed = PhysicalConstants.speedOfLightPerSecond;
/// final electronMass = PhysicalConstants.electronMass;
///
/// // Astronomical constants
/// final earthMass = AstronomicalConstants.earthMass;
/// final solarRadius = AstronomicalConstants.solarRadius;
///
/// // Engineering constants
/// final roomTemp = EngineeringConstants.roomTemperature;
/// final steelModulus = EngineeringConstants.steelYoungsModulus;
///
/// // Convenience calculations
/// final photonEnergy = PhysicalConstants.photonEnergy(500.0.nm);
/// final escapeVel = AstronomicalConstants.escapeVelocity(earthMass, earthRadius);
/// ```
///
/// ## Categories
///
/// ### PhysicalConstants
/// Fundamental constants from physics including:
/// - Speed of light, Planck constant, elementary charge
/// - Particle masses (electron, proton, neutron)
/// - Quantum and electromagnetic constants
/// - Convenience methods for common physics calculations
///
/// ### AstronomicalConstants
/// Constants from astronomy and astrophysics including:
/// - Solar system bodies (masses, radii, distances)
/// - Galactic and cosmological scales
/// - Stellar physics constants
/// - Convenience methods for orbital mechanics
///
/// ### EngineeringConstants
/// Practical constants for engineering including:
/// - Standard conditions (STP, NTP, atmospheric pressure)
/// - Material properties (density, thermal conductivity, etc.)
/// - Mechanical properties (Young's modulus, strength)
/// - Convenience methods for engineering calculations
///
/// ## Type Safety
///
/// All constants are provided with appropriate Quantity types where possible:
/// ```dart
/// final distance = PhysicalConstants.bohrRadius; // Returns Length
/// final mass = AstronomicalConstants.earthMass;   // Returns Mass
/// final temp = EngineeringConstants.roomTemperature; // Returns Temperature
/// ```
///
/// Constants requiring compound units not yet implemented are provided
/// as doubles with clear documentation of their units.
///
/// ## Future Extensions
///
/// As more Quantity types are added to quantify (Speed, Energy, Force, etc.),
/// the constants will be updated to use these types for even better type safety.
library;

// Export all constant classes
export 'src/constants/astronomical_constants.dart';
export 'src/constants/engineering_constants.dart';
export 'src/constants/physical_constants.dart';

<!-- END FILE: [v0.5.0] lib/constants.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/current.dart -->
/// Provides type-safe units for Electric Current.
///
/// Import this file to use Current quantities and their extensions on `num`
/// (like `1.5.A`, `20.mA`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/current/current.dart';
export 'src/units/current/current_extensions.dart';
export 'src/units/current/current_unit.dart';

<!-- END FILE: [v0.5.0] lib/current.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/length.dart -->
/// Provides type-safe units for Length.
///
/// Import this file to use Length quantities and their extensions on `num`
/// (like `10.m`, `5.ft`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/length/length.dart';
export 'src/units/length/length_extensions.dart';
export 'src/units/length/length_unit.dart';

<!-- END FILE: [v0.5.0] lib/length.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/luminous_intensity.dart -->
/// Provides type-safe units for Luminous Intensity.
///
/// Import this file to use LuminousIntensity quantities and their extensions on `num`
/// (like `150.cd`, `500.mcd`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/luminous/luminous_intensity.dart';
export 'src/units/luminous/luminous_intensity_extensions.dart';
export 'src/units/luminous/luminous_intensity_unit.dart';

<!-- END FILE: [v0.5.0] lib/luminous_intensity.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/mass.dart -->
/// Provides type-safe units for Mass.
///
/// Import this file to use Mass quantities and their extensions on `num`
/// (like `70.kg`, `500.g`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/mass/mass.dart';
export 'src/units/mass/mass_extensions.dart';
export 'src/units/mass/mass_unit.dart';

<!-- END FILE: [v0.5.0] lib/mass.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/molar.dart -->
/// Provides type-safe units for Amount of Substance (Molar Amount).
///
/// Import this file to use MolarAmount quantities and their extensions on `num`
/// (like `0.5.mol`, `25.mmol`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/molar/molar_amount.dart';
export 'src/units/molar/molar_extensions.dart';
export 'src/units/molar/molar_unit.dart';

<!-- END FILE: [v0.5.0] lib/molar.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/pressure.dart -->
/// Provides type-safe units for Pressure.
///
/// Import this file to use Pressure quantities and their extensions on `num`
/// (like `1.atm`, `32.psi`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/pressure/pressure.dart';
export 'src/units/pressure/pressure_extensions.dart';
export 'src/units/pressure/pressure_unit.dart';

<!-- END FILE: [v0.5.0] lib/pressure.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/quantify.dart -->
/// A type-safe library for units of measurement, providing elegant syntax for unit conversions.
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
// Exporting units and their extensions for angle
export 'src/units/angle/angle.dart';
export 'src/units/angle/angle_extensions.dart';
export 'src/units/angle/angle_unit.dart';
// Exporting units and their extensions for angular velocity
export 'src/units/angular_velocity/angular_velocity.dart';
export 'src/units/angular_velocity/angular_velocity_extensions.dart';
export 'src/units/angular_velocity/angular_velocity_unit.dart';
// Exporting units and their extensions for electric current
export 'src/units/current/current.dart';
export 'src/units/current/current_extensions.dart';
export 'src/units/current/current_unit.dart';
// Exporting units and their extensions for length
export 'src/units/length/length.dart';
export 'src/units/length/length_extensions.dart';
export 'src/units/length/length_unit.dart';
// Exporting units and their extensions for luminous intensity
export 'src/units/luminous/luminous_intensity.dart';
export 'src/units/luminous/luminous_intensity_extensions.dart';
export 'src/units/luminous/luminous_intensity_unit.dart';
// Exporting units and their extensions for mass
export 'src/units/mass/mass.dart';
export 'src/units/mass/mass_extensions.dart';
export 'src/units/mass/mass_unit.dart';
// Exporting units and their extensions for molar amount
export 'src/units/molar/molar_amount.dart';
export 'src/units/molar/molar_extensions.dart';
export 'src/units/molar/molar_unit.dart';
// Exporting units and their extensions for pressure
export 'src/units/pressure/pressure.dart';
export 'src/units/pressure/pressure_extensions.dart';
export 'src/units/pressure/pressure_unit.dart';
// Exporting units and their extensions for temperature
export 'src/units/temperature/temperature.dart';
export 'src/units/temperature/temperature_extensions.dart';
export 'src/units/temperature/temperature_unit.dart';
// Exporting units and their extensions for time
export 'src/units/time/time.dart';
export 'src/units/time/time_extensions.dart';
export 'src/units/time/time_unit.dart';

<!-- END FILE: [v0.5.0] lib/quantify.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/constants/astronomical_constants.dart -->
import 'dart:math' as math;

import '../units/length/length.dart';
import '../units/length/length_unit.dart';
import '../units/mass/mass.dart';
import '../units/mass/mass_unit.dart';
import '../units/temperature/temperature.dart';
import '../units/temperature/temperature_unit.dart';
import '../units/time/time.dart';
import '../units/time/time_unit.dart';

/// Astronomical and astrophysical constants with their respective units.
///
/// All constants are based on IAU (International Astronomical Union)
/// recommendations and recent astronomical measurements.
///
/// References:
/// - IAU 2015 Resolution B3: https://www.iau.org/static/resolutions/IAU2015_English.pdf
/// - NASA Planetary Fact Sheets: https://nssdc.gsfc.nasa.gov/planetary/factsheet/
/// - CODATA 2018 values for fundamental constants
class AstronomicalConstants {
  // Private constructor to prevent instantiation
  AstronomicalConstants._();

  // === FUNDAMENTAL ASTRONOMICAL UNITS ===

  /// Astronomical Unit (AU) - already available as LengthUnit.astronomicalUnit
  /// Value: 149,597,870.7 km (exact by IAU definition)
  ///
  /// Average distance from Earth to Sun, used as fundamental unit for Solar System.
  static const Length astronomicalUnit = Length(1, LengthUnit.astronomicalUnit);

  /// Light year (ly) - already available as LengthUnit.lightYear
  /// Value: 9.4607304725808√ó10¬π‚Åµ m
  ///
  /// Distance light travels in one Julian year (365.25 days).
  static const Length lightYear = Length(1, LengthUnit.lightYear);

  /// Parsec (pc) - already available as LengthUnit.parsec
  /// Value: 3.0856775814913673√ó10¬π‚Å∂ m
  ///
  /// Distance at which one AU subtends one arcsecond.
  static const Length parsec = Length(1, LengthUnit.parsec);

  // === SOLAR SYSTEM BODIES ===

  /// Solar mass (M‚òâ)
  /// Value: 1.98847√ó10¬≥‚Å∞ kg
  ///
  /// Total mass of the Sun, fundamental unit for stellar masses.
  static const Mass solarMass = Mass(1.98847e30, MassUnit.kilogram);

  /// Solar radius (R‚òâ)
  /// Value: 6.957√ó10‚Å∏ m
  ///
  /// Radius of the Sun from center to photosphere.
  static const Length solarRadius = Length(695700000, LengthUnit.meter);

  /// Solar luminosity (L‚òâ)
  /// Value: 3.828√ó10¬≤‚Å∂ W
  ///
  /// Total power output of the Sun.
  /// Note: This would ideally be Power, represented as double for now.
  static const double solarLuminosity = 3.828e26; // W

  /// Solar effective temperature
  /// Value: 5778 K
  ///
  /// Effective black-body temperature of the Sun.
  static const Temperature solarEffectiveTemperature = Temperature(5778, TemperatureUnit.kelvin);

  /// Earth mass (M‚äï)
  /// Value: 5.9722√ó10¬≤‚Å¥ kg
  ///
  /// Total mass of Earth, fundamental unit for terrestrial planet masses.
  static const Mass earthMass = Mass(5.9722e24, MassUnit.kilogram);

  /// Earth equatorial radius (R‚äï)
  /// Value: 6.37814√ó10‚Å∂ m
  ///
  /// Earth's radius at the equator.
  static const Length earthRadius = Length(6378140, LengthUnit.meter);

  /// Earth polar radius
  /// Value: 6.35675√ó10‚Å∂ m
  ///
  /// Earth's radius at the poles (Earth is oblate).
  static const Length earthPolarRadius = Length(6356750, LengthUnit.meter);

  /// Moon mass
  /// Value: 7.342√ó10¬≤¬≤ kg
  static const Mass moonMass = Mass(7.342e22, MassUnit.kilogram);

  /// Moon radius
  /// Value: 1.737√ó10‚Å∂ m
  static const Length moonRadius = Length(1737000, LengthUnit.meter);

  /// Earth-Moon distance (semi-major axis)
  /// Value: 3.844√ó10‚Å∏ m
  static const Length earthMoonDistance = Length(384400000, LengthUnit.meter);

  // === PLANETARY MASSES ===

  /// Mercury mass
  /// Value: 3.301√ó10¬≤¬≥ kg
  static const Mass mercuryMass = Mass(3.301e23, MassUnit.kilogram);

  /// Venus mass
  /// Value: 4.867√ó10¬≤‚Å¥ kg
  static const Mass venusMass = Mass(4.867e24, MassUnit.kilogram);

  /// Mars mass
  /// Value: 6.39√ó10¬≤¬≥ kg
  static const Mass marsMass = Mass(6.39e23, MassUnit.kilogram);

  /// Jupiter mass (MJ)
  /// Value: 1.898√ó10¬≤‚Å∑ kg
  ///
  /// Fundamental unit for gas giant masses.
  static const Mass jupiterMass = Mass(1.898e27, MassUnit.kilogram);

  /// Saturn mass
  /// Value: 5.683√ó10¬≤‚Å∂ kg
  static const Mass saturnMass = Mass(5.683e26, MassUnit.kilogram);

  /// Uranus mass
  /// Value: 8.681√ó10¬≤‚Åµ kg
  static const Mass uranusMass = Mass(8.681e25, MassUnit.kilogram);

  /// Neptune mass
  /// Value: 1.024√ó10¬≤‚Å∂ kg
  static const Mass neptuneMass = Mass(1.024e26, MassUnit.kilogram);

  // === GALACTIC AND EXTRAGALACTIC ===

  /// Milky Way mass
  /// Value: ~1.5√ó10¬π¬≤ M‚òâ = 2.98√ó10‚Å¥¬≤ kg
  ///
  /// Estimated total mass of the Milky Way galaxy.
  static const Mass milkyWayMass = Mass(2.98e42, MassUnit.kilogram);

  /// Galactic center distance
  /// Value: 2.615√ó10¬≤‚Å∞ m ‚âà 26,000 ly
  ///
  /// Distance from Solar System to Sagittarius A*.
  static const Length galacticCenterDistance = Length(2.615e20, LengthUnit.meter);

  /// Local Group diameter
  /// Value: ~3√ó10¬≤¬≤ m ‚âà 10 million ly
  ///
  /// Approximate diameter of our local galaxy group.
  static const Length localGroupDiameter = Length(3e22, LengthUnit.meter);

  /// Hubble constant (H‚ÇÄ)
  /// Value: 67.4 km/(s‚ãÖMpc) ‚âà 2.18√ó10‚Åª¬π‚Å∏ s‚Åª¬π
  ///
  /// Current expansion rate of the universe.
  /// Note: This would ideally be Speed per Length, represented as double for now.
  static const double hubbleConstant = 2.18e-18; // s‚Åª¬π (simplified unit)

  /// Critical density of universe
  /// Value: 9.47√ó10‚Åª¬≤‚Å∑ kg/m¬≥
  ///
  /// Density required for flat universe geometry.
  /// Note: This would ideally be Density, represented as double for now.
  static const double criticalDensity = 9.47e-27; // kg/m¬≥

  /// Observable universe radius
  /// Value: 4.40√ó10¬≤‚Å∂ m ‚âà 46.5 billion ly
  ///
  /// Current radius of the observable universe.
  static const Length observableUniverseRadius = Length(4.40e26, LengthUnit.meter);

  // === STELLAR CONSTANTS ===

  /// Chandrasekhar limit
  /// Value: 2.785√ó10¬≥‚Å∞ kg ‚âà 1.4 M‚òâ
  ///
  /// Maximum mass of white dwarf star.
  static const Mass chandrasekharLimit = Mass(2.785e30, MassUnit.kilogram);

  /// Schwarzschild radius of solar mass black hole
  /// Value: 2.954√ó10¬≥ m ‚âà 2.95 km
  ///
  /// Event horizon radius for solar mass black hole.
  static const Length solarMassSchwarzschildRadius = Length(2954, LengthUnit.meter);

  /// Planck mass
  /// Value: 2.176434√ó10‚Åª‚Å∏ kg
  ///
  /// Fundamental mass scale in quantum gravity.
  static const Mass planckMass = Mass(2.176434e-8, MassUnit.kilogram);

  /// Planck length
  /// Value: 1.616255√ó10‚Åª¬≥‚Åµ m
  ///
  /// Fundamental length scale in quantum gravity.
  static const Length planckLength = Length(1.616255e-35, LengthUnit.meter);

  /// Planck time
  /// Value: 5.391247√ó10‚Åª‚Å¥‚Å¥ s
  ///
  /// Fundamental time scale in quantum gravity.
  static const Time planckTime = Time(5.391247e-44, TimeUnit.second);

  // === EARTH PROPERTIES ===

  /// Standard gravity (g‚ÇÄ)
  /// Value: 9.80665 m/s¬≤ (exact by definition)
  ///
  /// Standard acceleration due to gravity at Earth's surface.
  /// Note: This would ideally be Acceleration.
  static const double standardGravity = 9.80665; // m/s¬≤

  /// Earth's rotational period (sidereal day)
  /// Value: 86164.0905 s ‚âà 23h 56m 4s
  ///
  /// Time for one rotation relative to distant stars.
  static const Time siderealDay = Time(86164.0905, TimeUnit.second);

  /// Earth's orbital period (sidereal year)
  /// Value: 3.155815√ó10‚Å∑ s ‚âà 365.256 days
  ///
  /// Time for one orbit around the Sun.
  static const Time siderealYear = Time(31558150, TimeUnit.second);

  /// Escape velocity from Earth
  /// Value: 1.119√ó10‚Å¥ m/s ‚âà 11.19 km/s
  ///
  /// Minimum velocity to escape Earth's gravitational field.
  /// Note: This would ideally be Speed.
  static const double earthEscapeVelocity = 11190; // m/s

  // === COSMOLOGICAL TIMES ===

  /// Age of the universe
  /// Value: 4.35√ó10¬π‚Å∑ s ‚âà 13.8 billion years
  ///
  /// Time since the Big Bang.
  static const Time ageOfUniverse = Time(435000000000000000, TimeUnit.second);

  /// Cosmic microwave background temperature
  /// Value: 2.72548 K
  ///
  /// Current temperature of cosmic microwave background radiation.
  static const Temperature cmbTemperature = Temperature(2.72548, TemperatureUnit.kelvin);

  // === CONVENIENCE METHODS ===

  /// Calculate gravitational acceleration at surface of a celestial body
  ///
  /// Returns acceleration in m/s¬≤ as a double.
  /// Usage: `final g = AstronomicalConstants.surfaceGravity(earthMass, earthRadius);`
  static double surfaceGravity(Mass bodyMass, Length bodyRadius) {
    final mass = bodyMass.getValue(MassUnit.kilogram);
    final radius = bodyRadius.getValue(LengthUnit.meter);
    const gravitationalConstant = 6.67430e-11; // G in m¬≥/(kg‚ãÖs¬≤)
    return gravitationalConstant * mass / (radius * radius); // g = GM/r¬≤
  }

  /// Calculate escape velocity from surface of a celestial body
  ///
  /// Returns velocity in m/s as a double.
  /// Usage: `final v = AstronomicalConstants.escapeVelocity(earthMass, earthRadius);`
  static double escapeVelocity(Mass bodyMass, Length bodyRadius) {
    final mass = bodyMass.getValue(MassUnit.kilogram);
    final radius = bodyRadius.getValue(LengthUnit.meter);
    const gravitationalConstant = 6.67430e-11; // G in m¬≥/(kg‚ãÖs¬≤)
    final v2 = 2.0 * gravitationalConstant * mass / radius; // v¬≤ = 2GM/r
    return math.sqrt(v2); // v = ‚àö(2GM/r)
  }

  /// Calculate orbital velocity for circular orbit
  ///
  /// Returns velocity in m/s as a double.
  /// Usage: `final v = AstronomicalConstants.orbitalVelocity(earthMass, earthRadius);`
  static double orbitalVelocity(Mass centralMass, Length orbitalRadius) {
    final mass = centralMass.getValue(MassUnit.kilogram);
    final radius = orbitalRadius.getValue(LengthUnit.meter);
    const gravitationalConstant = 6.67430e-11; // G in m¬≥/(kg‚ãÖs¬≤)
    final v2 = gravitationalConstant * mass / radius; // v¬≤ = GM/r
    return math.sqrt(v2); // v = ‚àö(GM/r)
  }

  /// Calculate Schwarzschild radius (event horizon) for given mass
  ///
  /// Returns radius as Length.
  /// Usage: `final rs = AstronomicalConstants.schwarzschildRadius(solarMass);`
  static Length schwarzschildRadius(Mass mass) {
    final massInKg = mass.getValue(MassUnit.kilogram);
    const gravitationalConstant = 6.67430e-11; // G in m¬≥/(kg‚ãÖs¬≤)
    const speedOfLight = 299792458.0; // c in m/s
    final rs = 2.0 * gravitationalConstant * massInKg / (speedOfLight * speedOfLight);
    return Length(rs, LengthUnit.meter); // rs = 2GM/c¬≤
  }

  /// Calculate tidal force between two bodies
  ///
  /// Returns force gradient in N/m as a double.
  /// Usage: `final tidal = AstronomicalConstants.tidalForce(moonMass, earthMoonDistance);`
  static double tidalForce(Mass tidalMass, Length distance) {
    final mass = tidalMass.getValue(MassUnit.kilogram);
    final r = distance.getValue(LengthUnit.meter);
    const gravitationalConstant = 6.67430e-11; // G in m¬≥/(kg‚ãÖs¬≤)
    return 2.0 * gravitationalConstant * mass / (r * r * r); // dF/dr = 2GM/r¬≥
  }

  /// Calculate luminosity distance in expanding universe
  ///
  /// Returns distance as Length.
  /// Usage: `final dL = AstronomicalConstants.luminosityDistance(redshift);`
  static Length luminosityDistance(double redshift) {
    // Simplified calculation for low redshift (z << 1)
    // For accurate cosmological distances, use full ŒõCDM model
    const hubbleConstantSI = 2.18e-18; // H‚ÇÄ in s‚Åª¬π
    const speedOfLight = 299792458.0; // c in m/s
    final distance = speedOfLight * redshift / hubbleConstantSI; // d ‚âà cz/H‚ÇÄ
    return Length(distance, LengthUnit.meter);
  }
}

<!-- END FILE: [v0.5.0] lib/src/constants/astronomical_constants.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/constants/engineering_constants.dart -->
import '../units/length/length.dart';
import '../units/length/length_unit.dart';
import '../units/mass/mass.dart';
import '../units/mass/mass_unit.dart';
import '../units/pressure/pressure.dart';
import '../units/pressure/pressure_unit.dart';
import '../units/temperature/temperature.dart';
import '../units/temperature/temperature_unit.dart';

/// Engineering and technical constants with their respective units.
///
/// These constants are commonly used in engineering calculations,
/// material science, and industrial applications.
///
/// References:
/// - NIST Reference Fluid Thermodynamic and Transport Properties
/// - Engineering Standards and Handbooks
/// - International Standards Organization (ISO)
class EngineeringConstants {
  // Private constructor to prevent instantiation
  EngineeringConstants._();

  // === STANDARD CONDITIONS ===

  /// Standard temperature and pressure (STP) - Temperature
  /// Value: 273.15 K (0¬∞C)
  ///
  /// IUPAC definition of standard temperature.
  static const Temperature standardTemperature = Temperature(273.15, TemperatureUnit.kelvin);

  /// Standard temperature and pressure (STP) - Pressure
  /// Value: 100,000 Pa (1 bar)
  ///
  /// IUPAC definition of standard pressure (changed from 1 atm in 1982).
  static const Pressure standardPressure = Pressure(100000, PressureUnit.pascal);

  /// Standard atmospheric pressure
  /// Value: 101,325 Pa (1 atm)
  ///
  /// Historical standard, still widely used in engineering.
  static const Pressure standardAtmosphere = Pressure(101325, PressureUnit.pascal);

  /// Normal temperature and pressure (NTP) - Temperature
  /// Value: 293.15 K (20¬∞C)
  ///
  /// Common reference temperature for engineering calculations.
  static const Temperature normalTemperature = Temperature(293.15, TemperatureUnit.kelvin);

  /// Room temperature (typical)
  /// Value: 295.15 K (22¬∞C)
  ///
  /// Typical comfortable indoor temperature.
  static const Temperature roomTemperature = Temperature(295.15, TemperatureUnit.kelvin);

  // === MATERIAL PROPERTIES ===

  /// Density of water at STP
  /// Value: 999.97 kg/m¬≥
  ///
  /// Maximum density of water occurs at ~4¬∞C.
  /// Note: This would ideally be Density, represented as double for now.
  static const double waterDensitySTP = 999.97; // kg/m¬≥

  /// Density of air at STP
  /// Value: 1.225 kg/m¬≥
  ///
  /// Standard atmospheric conditions.
  static const double airDensitySTP = 1.225; // kg/m¬≥

  /// Speed of sound in air at 20¬∞C
  /// Value: 343.2 m/s
  ///
  /// At sea level, 20¬∞C, 50% humidity.
  /// Note: This would ideally be Speed.
  static const double soundSpeedAir20C = 343.2; // m/s

  /// Speed of sound in water at 25¬∞C
  /// Value: 1497 m/s
  static const double soundSpeedWater25C = 1497; // m/s

  /// Viscosity of water at 20¬∞C
  /// Value: 1.002√ó10‚Åª¬≥ Pa‚ãÖs
  ///
  /// Dynamic viscosity of water.
  /// Note: This would ideally be DynamicViscosity.
  static const double waterViscosity20C = 1.002e-3; // Pa‚ãÖs

  /// Viscosity of air at 20¬∞C
  /// Value: 1.81√ó10‚Åª‚Åµ Pa‚ãÖs
  static const double airViscosity20C = 1.81e-5; // Pa‚ãÖs

  // === THERMAL PROPERTIES ===

  /// Thermal conductivity of copper
  /// Value: 401 W/(m‚ãÖK)
  ///
  /// High-purity copper at room temperature.
  /// Note: This would ideally be ThermalConductivity.
  static const double copperThermalConductivity = 401; // W/(m‚ãÖK)

  /// Thermal conductivity of aluminum
  /// Value: 237 W/(m‚ãÖK)
  static const double aluminumThermalConductivity = 237; // W/(m‚ãÖK)

  /// Thermal conductivity of steel
  /// Value: 50 W/(m‚ãÖK)
  ///
  /// Typical carbon steel.
  static const double steelThermalConductivity = 50; // W/(m‚ãÖK)

  /// Thermal conductivity of air at 20¬∞C
  /// Value: 0.0257 W/(m‚ãÖK)
  static const double airThermalConductivity = 0.0257; // W/(m‚ãÖK)

  /// Specific heat capacity of water
  /// Value: 4184 J/(kg‚ãÖK)
  ///
  /// At 15¬∞C, used for thermal calculations.
  /// Note: This would ideally be SpecificHeatCapacity.
  static const double waterSpecificHeat = 4184; // J/(kg‚ãÖK)

  /// Specific heat capacity of air
  /// Value: 1005 J/(kg‚ãÖK)
  ///
  /// At constant pressure, 20¬∞C.
  static const double airSpecificHeat = 1005; // J/(kg‚ãÖK)

  /// Latent heat of vaporization of water
  /// Value: 2.26√ó10‚Å∂ J/kg
  ///
  /// Energy required to vaporize water at 100¬∞C.
  /// Note: This would ideally be SpecificEnergy.
  static const double waterLatentHeatVaporization = 2260000; // J/kg

  /// Latent heat of fusion of water
  /// Value: 3.34√ó10‚Åµ J/kg
  ///
  /// Energy required to melt ice at 0¬∞C.
  static const double waterLatentHeatFusion = 334000; // J/kg

  // === ELECTRICAL PROPERTIES ===

  /// Resistivity of copper
  /// Value: 1.68√ó10‚Åª‚Å∏ Œ©‚ãÖm
  ///
  /// At 20¬∞C, high-purity copper.
  /// Note: This would ideally be ElectricalResistivity.
  static const double copperResistivity = 1.68e-8; // Œ©‚ãÖm

  /// Resistivity of aluminum
  /// Value: 2.65√ó10‚Åª‚Å∏ Œ©‚ãÖm
  static const double aluminumResistivity = 2.65e-8; // Œ©‚ãÖm

  /// Resistivity of silicon (intrinsic)
  /// Value: 2.3√ó10¬≥ Œ©‚ãÖm
  ///
  /// Pure silicon at room temperature.
  static const double siliconResistivity = 2300; // Œ©‚ãÖm

  /// Dielectric constant of vacuum
  /// Value: 1.0 (dimensionless)
  ///
  /// By definition, reference for all other materials.
  static const double vacuumDielectricConstant = 1;

  /// Dielectric constant of air
  /// Value: 1.00059 (dimensionless)
  ///
  /// At STP, very close to vacuum.
  static const double airDielectricConstant = 1.00059;

  /// Dielectric constant of water
  /// Value: 81.0 (dimensionless)
  ///
  /// At 20¬∞C, static relative permittivity.
  static const double waterDielectricConstant = 81;

  // === MECHANICAL PROPERTIES ===

  /// Young's modulus of steel
  /// Value: 2.0√ó10¬π¬π Pa
  ///
  /// Typical carbon steel, measure of stiffness.
  /// Note: This would ideally be Pressure (stress/strain).
  static const double steelYoungsModulus = 200000000000; // Pa

  /// Young's modulus of aluminum
  /// Value: 7.0√ó10¬π‚Å∞ Pa
  static const double aluminumYoungsModulus = 70000000000; // Pa

  /// Young's modulus of concrete
  /// Value: 3.0√ó10¬π‚Å∞ Pa
  ///
  /// Typical Portland cement concrete.
  static const double concreteYoungsModulus = 30000000000; // Pa

  /// Tensile strength of steel
  /// Value: 4.0√ó10‚Å∏ Pa
  ///
  /// Typical mild steel ultimate tensile strength.
  static const double steelTensileStrength = 400000000; // Pa

  /// Yield strength of steel
  /// Value: 2.5√ó10‚Å∏ Pa
  ///
  /// Typical mild steel yield strength.
  static const double steelYieldStrength = 250000000; // Pa

  /// Coefficient of thermal expansion - Steel
  /// Value: 1.2√ó10‚Åª‚Åµ K‚Åª¬π
  ///
  /// Linear thermal expansion coefficient.
  static const double steelThermalExpansion = 1.2e-5; // K‚Åª¬π

  /// Coefficient of thermal expansion - Aluminum
  /// Value: 2.3√ó10‚Åª‚Åµ K‚Åª¬π
  static const double aluminumThermalExpansion = 2.3e-5; // K‚Åª¬π

  /// Coefficient of thermal expansion - Concrete
  /// Value: 1.0√ó10‚Åª‚Åµ K‚Åª¬π
  static const double concreteThermalExpansion = 1.0e-5; // K‚Åª¬π

  // === FLUID DYNAMICS ===

  /// Reynolds number for turbulent flow in pipes
  /// Value: 4000 (dimensionless)
  ///
  /// Approximate transition from laminar to turbulent flow.
  static const double turbulentReynoldsNumber = 4000;

  /// Reynolds number for laminar flow in pipes
  /// Value: 2300 (dimensionless)
  ///
  /// Flow below this value is typically laminar.
  static const double laminarReynoldsNumber = 2300;

  /// Prandtl number for air
  /// Value: 0.71 (dimensionless)
  ///
  /// Ratio of momentum to thermal diffusivity.
  static const double airPrandtlNumber = 0.71;

  /// Prandtl number for water
  /// Value: 7.0 (dimensionless)
  static const double waterPrandtlNumber = 7;

  // === COMBUSTION AND ENERGY ===

  /// Heating value of natural gas (methane)
  /// Value: 5.0√ó10‚Å∑ J/kg
  ///
  /// Lower heating value (LHV) of methane.
  /// Note: This would ideally be SpecificEnergy.
  static const double methaneHeatingValue = 50000000; // J/kg

  /// Heating value of gasoline
  /// Value: 4.4√ó10‚Å∑ J/kg
  ///
  /// Lower heating value of typical gasoline.
  static const double gasolineHeatingValue = 44000000; // J/kg

  /// Heating value of diesel
  /// Value: 4.3√ó10‚Å∑ J/kg
  ///
  /// Lower heating value of diesel fuel.
  static const double dieselHeatingValue = 43000000; // J/kg

  /// Stoichiometric air-fuel ratio for gasoline
  /// Value: 14.7 (dimensionless)
  ///
  /// Mass ratio of air to fuel for complete combustion.
  static const double gasolineAirFuelRatio = 14.7;

  // === ATOMIC AND NUCLEAR ===

  /// Avogadro's number (from PhysicalConstants but useful here)
  /// Value: 6.02214076√ó10¬≤¬≥ mol‚Åª¬π
  static const double avogadroNumber = 6.02214076e23; // mol‚Åª¬π

  /// Atomic mass unit in kg
  /// Value: 1.66053906660√ó10‚Åª¬≤‚Å∑ kg
  static const Mass atomicMassUnit = Mass(1.66053906660e-27, MassUnit.kilogram);

  /// Typical nuclear binding energy per nucleon
  /// Value: 8.0√ó10‚Å∂ eV ‚âà 1.28√ó10‚Åª¬π¬≤ J
  ///
  /// Energy scale for nuclear reactions.
  /// Note: This would ideally be Energy.
  static const double nuclearBindingEnergyPerNucleon = 1.28e-12; // J

  // === TYPICAL ENGINEERING VALUES ===

  /// Atmospheric pressure at sea level
  /// Value: 101,325 Pa
  static const Pressure seaLevelPressure = Pressure(101325, PressureUnit.pascal);

  /// Freezing point of water
  /// Value: 273.15 K (0¬∞C)
  static const Temperature waterFreezingPoint = Temperature(273.15, TemperatureUnit.kelvin);

  /// Boiling point of water at 1 atm
  /// Value: 373.15 K (100¬∞C)
  static const Temperature waterBoilingPoint = Temperature(373.15, TemperatureUnit.kelvin);

  /// Human body temperature
  /// Value: 310.15 K (37¬∞C)
  static const Temperature bodyTemperature = Temperature(310.15, TemperatureUnit.kelvin);

  /// Liquid nitrogen temperature
  /// Value: 77.36 K (-195.79¬∞C)
  static const Temperature liquidNitrogenTemperature = Temperature(77.36, TemperatureUnit.kelvin);

  /// Liquid helium temperature
  /// Value: 4.22 K (-268.93¬∞C)
  static const Temperature liquidHeliumTemperature = Temperature(4.22, TemperatureUnit.kelvin);

  // === CONVENIENCE METHODS ===

  /// Calculate Reynolds number for pipe flow
  ///
  /// Returns dimensionless Reynolds number.
  /// Usage: `final Re = EngineeringConstants.reynoldsNumberPipe(velocity, diameter, kinematicViscosity);`
  static double reynoldsNumberPipe(double velocity, Length diameter, double kinematicViscosity) {
    final d = diameter.getValue(LengthUnit.meter);
    return velocity * d / kinematicViscosity; // Re = vD/ŒΩ
  }

  /// Calculate pressure drop in pipe using Darcy-Weisbach equation
  ///
  /// Returns pressure drop in Pa as double.
  /// Usage: `final dp = EngineeringConstants.pipePressureDrop(frictionFactor, length, diameter, velocity, density);`
  static double pipePressureDrop(
    double frictionFactor,
    Length length,
    Length diameter,
    double velocity,
    double density,
  ) {
    final L = length.getValue(LengthUnit.meter);
    final D = diameter.getValue(LengthUnit.meter);
    return frictionFactor * (L / D) * (density * velocity * velocity / 2.0); // Œîp = f(L/D)(œÅv¬≤/2)
  }

  /// Calculate thermal expansion of a material
  ///
  /// Returns change in length as Length.
  /// Usage: `final deltaL = EngineeringConstants.thermalExpansion(originalLength, expansionCoeff, tempChange);`
  static Length thermalExpansion(
    Length originalLength,
    double expansionCoefficient,
    Temperature temperatureChange,
  ) {
    final l0 = originalLength.getValue(LengthUnit.meter);
    final deltaT = temperatureChange.getValue(TemperatureUnit.kelvin);
    final deltaL = l0 * expansionCoefficient * deltaT; // ŒîL = L‚ÇÄŒ±ŒîT
    return Length(deltaL, LengthUnit.meter);
  }

  /// Calculate heat transfer by conduction
  ///
  /// Returns heat transfer rate in W as double.
  /// Usage: `final q = EngineeringConstants.conductiveHeatTransfer(thermalConductivity, area, thickness, tempDiff);`
  static double conductiveHeatTransfer(
    double thermalConductivity,
    double area,
    Length thickness,
    Temperature temperatureDifference,
  ) {
    final dx = thickness.getValue(LengthUnit.meter);
    final deltaT = temperatureDifference.getValue(TemperatureUnit.kelvin);
    return thermalConductivity * area * deltaT / dx; // q = kA(ŒîT/Œîx)
  }

  /// Calculate electrical resistance of a conductor
  ///
  /// Returns resistance in Œ© as double.
  /// Usage: `final R = EngineeringConstants.electricalResistance(resistivity, length, area);`
  static double electricalResistance(double resistivity, Length length, double crossSectionArea) {
    final L = length.getValue(LengthUnit.meter);
    return resistivity * L / crossSectionArea; // R = œÅL/A
  }

  /// Calculate capacitance of parallel plate capacitor
  ///
  /// Returns capacitance in F as double.
  /// Usage: `final C = EngineeringConstants.parallelPlateCapacitance(area, separation, dielectricConstant);`
  static double parallelPlateCapacitance(
    double plateArea,
    Length separation,
    double dielectricConstant,
  ) {
    const epsilon0 = 8.8541878128e-12; // Vacuum permittivity in F/m
    final d = separation.getValue(LengthUnit.meter);
    return epsilon0 * dielectricConstant * plateArea / d; // C = Œµ‚ÇÄŒµ·µ£A/d
  }

  /// Calculate stress from force and area
  ///
  /// Returns stress in Pa as double.
  /// Usage: `final stress = EngineeringConstants.mechanicalStress(force, area);`
  static double mechanicalStress(double force, double area) {
    return force / area; // œÉ = F/A
  }

  /// Calculate strain from stress using Young's modulus
  ///
  /// Returns dimensionless strain.
  /// Usage: `final strain = EngineeringConstants.mechanicalStrain(stress, youngsModulus);`
  static double mechanicalStrain(double stress, double youngsModulus) {
    return stress / youngsModulus; // Œµ = œÉ/E
  }
}

<!-- END FILE: [v0.5.0] lib/src/constants/engineering_constants.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/constants/physical_constants.dart -->
import '../units/length/length.dart';
import '../units/length/length_unit.dart';
import '../units/mass/mass.dart';
import '../units/mass/mass_unit.dart';
import '../units/temperature/temperature.dart';
import '../units/temperature/temperature_unit.dart';
import '../units/time/time.dart';
import '../units/time/time_unit.dart';

/// Fundamental physical constants with their respective units.
///
/// All constants are based on the 2018 CODATA recommended values
/// and are defined as immutable static constants with appropriate
/// Quantity types for type safety.
///
/// References:
/// - CODATA 2018: https://physics.nist.gov/cuu/Constants/
/// - NIST Reference on Constants: https://www.nist.gov/pml/fundamental-physical-constants
class PhysicalConstants {
  // Private constructor to prevent instantiation
  PhysicalConstants._();

  // === FUNDAMENTAL CONSTANTS ===

  /// Speed of light in vacuum (c)
  /// Exact value: 299,792,458 m/s
  ///
  /// This is an exact value by definition since the meter is defined
  /// in terms of the speed of light.
  static const Length speedOfLightPerSecond = Length(299792458, LengthUnit.meter);

  // Note: For speed, we'd need a Speed quantity type. For now, provide as Length per unit time.
  // Future: static const Speed speedOfLight = Speed(299792458.0, SpeedUnit.meterPerSecond);

  /// Planck constant (h)
  /// Value: 6.62607015√ó10‚Åª¬≥‚Å¥ J‚ãÖs
  ///
  /// Exact value by definition since 2019 SI redefinition.
  /// Note: This would ideally be Energy √ó Time, but we represent as a double for now.
  static const double planckConstant = 6.62607015e-34; // J‚ãÖs

  /// Reduced Planck constant (‚Ñè = h/2œÄ)
  /// Value: 1.054571817√ó10‚Åª¬≥‚Å¥ J‚ãÖs
  static const double reducedPlanckConstant = 1.054571817e-34; // J‚ãÖs

  /// Elementary charge (e)
  /// Value: 1.602176634√ó10‚Åª¬π‚Åπ C
  ///
  /// Exact value by definition since 2019 SI redefinition.
  /// Note: This would ideally be ElectricCharge, represented as double for now.
  static const double elementaryCharge = 1.602176634e-19; // C

  /// Avogadro constant (N‚Çê)
  /// Value: 6.02214076√ó10¬≤¬≥ mol‚Åª¬π
  ///
  /// Exact value by definition since 2019 SI redefinition.
  static const double avogadroConstant = 6.02214076e23; // mol‚Åª¬π

  /// Boltzmann constant (k)
  /// Value: 1.380649√ó10‚Åª¬≤¬≥ J/K
  ///
  /// Exact value by definition since 2019 SI redefinition.
  /// Note: This would ideally be Energy per Temperature.
  static const double boltzmannConstant = 1.380649e-23; // J/K

  /// Gas constant (R = N‚Çê √ó k)
  /// Value: 8.314462618 J/(mol‚ãÖK)
  ///
  /// Derived from Avogadro and Boltzmann constants.
  static const double gasConstant = 8.314462618; // J/(mol‚ãÖK)

  /// Gravitational constant (G)
  /// Value: 6.67430√ó10‚Åª¬π¬π m¬≥/(kg‚ãÖs¬≤)
  ///
  /// This is the least precisely known fundamental constant.
  /// Note: This would ideally be Volume per (Mass √ó Time¬≤).
  static const double gravitationalConstant = 6.67430e-11; // m¬≥/(kg‚ãÖs¬≤)

  /// Fine-structure constant (Œ±)
  /// Value: 7.2973525693√ó10‚Åª¬≥
  ///
  /// Dimensionless constant characterizing the strength of electromagnetic interaction.
  static const double fineStructureConstant = 7.2973525693e-3;

  /// Vacuum permeability (Œº‚ÇÄ)
  /// Value: 4œÄ√ó10‚Åª‚Å∑ H/m
  ///
  /// Exact value by definition.
  /// Note: This would ideally be MagneticPermeability.
  static const double vacuumPermeability = 4.0e-7 * 3.14159265358979323846; // H/m

  /// Vacuum permittivity (Œµ‚ÇÄ = 1/(Œº‚ÇÄc¬≤))
  /// Value: 8.8541878128√ó10‚Åª¬π¬≤ F/m
  ///
  /// Derived from vacuum permeability and speed of light.
  /// Note: This would ideally be ElectricPermittivity.
  static const double vacuumPermittivity = 8.8541878128e-12; // F/m

  // === PARTICLE MASSES ===

  /// Electron mass (m‚Çë)
  /// Value: 9.1093837015√ó10‚Åª¬≥¬π kg
  static const Mass electronMass = Mass(9.1093837015e-31, MassUnit.kilogram);

  /// Proton mass (m‚Çö)
  /// Value: 1.67262192369√ó10‚Åª¬≤‚Å∑ kg
  static const Mass protonMass = Mass(1.67262192369e-27, MassUnit.kilogram);

  /// Neutron mass (m‚Çô)
  /// Value: 1.67492749804√ó10‚Åª¬≤‚Å∑ kg
  static const Mass neutronMass = Mass(1.67492749804e-27, MassUnit.kilogram);

  /// Atomic mass constant (m·µ§ = 1 u)
  /// Value: 1.66053906660√ó10‚Åª¬≤‚Å∑ kg
  ///
  /// This is exactly 1/12 of the mass of carbon-12.
  static const Mass atomicMassConstant = Mass(1.66053906660e-27, MassUnit.kilogram);

  // === DERIVED CONSTANTS ===

  /// Electron charge-to-mass ratio (e/m‚Çë)
  /// Value: 1.75882001076√ó10¬π¬π C/kg
  ///
  /// Important in electron optics and mass spectrometry.
  static const double electronChargeToMassRatio = 175882001076; // C/kg

  /// Proton charge-to-mass ratio (e/m‚Çö)
  /// Value: 9.5788331560√ó10‚Å∑ C/kg
  static const double protonChargeToMassRatio = 9.5788331560e7; // C/kg

  /// Classical electron radius (r‚Çë)
  /// Value: 2.8179403262√ó10‚Åª¬π‚Åµ m
  ///
  /// Derived from fundamental constants: r‚Çë = e¬≤/(4œÄŒµ‚ÇÄm‚Çëc¬≤)
  static const Length classicalElectronRadius = Length(2.8179403262e-15, LengthUnit.meter);

  /// Bohr radius (a‚ÇÄ)
  /// Value: 5.29177210903√ó10‚Åª¬π¬π m
  ///
  /// The most probable distance between nucleus and electron in hydrogen atom.
  static const Length bohrRadius = Length(5.29177210903e-11, LengthUnit.meter);

  /// Compton wavelength of electron (ŒªC)
  /// Value: 2.42631023867√ó10‚Åª¬π¬≤ m
  ///
  /// Quantum mechanical property of particles with mass.
  static const Length electronComptonWavelength = Length(2.42631023867e-12, LengthUnit.meter);

  // === ENERGY CONVERSIONS ===

  /// Electron volt in joules
  /// Value: 1.602176634√ó10‚Åª¬π‚Åπ J
  ///
  /// Energy gained by an electron when accelerated through 1 volt potential difference.
  /// Note: This would ideally be Energy, represented as double for now.
  static const double electronVoltInJoules = 1.602176634e-19; // J

  /// Rydberg energy
  /// Value: 2.1798723611035√ó10‚Åª¬π‚Å∏ J
  ///
  /// Binding energy of hydrogen atom ground state.
  static const double rydbergEnergy = 2.1798723611035e-18; // J

  /// Rest energy of electron (m‚Çëc¬≤)
  /// Value: 8.1871057769√ó10‚Åª¬π‚Å¥ J
  ///
  /// Einstein's mass-energy equivalence for electron.
  static const double electronRestEnergy = 8.1871057769e-14; // J

  /// Rest energy of proton (m‚Çöc¬≤)
  /// Value: 1.50327759787√ó10‚Åª¬π‚Å∞ J
  static const double protonRestEnergy = 1.50327759787e-10; // J

  // === QUANTUM CONSTANTS ===

  /// Stefan-Boltzmann constant (œÉ)
  /// Value: 5.670374419√ó10‚Åª‚Å∏ W/(m¬≤‚ãÖK‚Å¥)
  ///
  /// Relates total energy radiated from black body to its temperature.
  /// Note: This would ideally be Power per (Area √ó Temperature‚Å¥).
  static const double stefanBoltzmannConstant = 5.670374419e-8; // W/(m¬≤‚ãÖK‚Å¥)

  /// Wien displacement law constant (b)
  /// Value: 2.897771955√ó10‚Åª¬≥ m‚ãÖK
  ///
  /// Peak wavelength of black-body radiation times temperature.
  /// Note: This would ideally be Length √ó Temperature.
  static const double wienDisplacementConstant = 2.897771955e-3; // m‚ãÖK

  /// First radiation constant (c‚ÇÅ)
  /// Value: 3.741771852√ó10‚Åª¬π‚Å∂ W‚ãÖm¬≤
  ///
  /// Used in Planck's law for black-body radiation.
  /// Note: This would ideally be Power √ó Area.
  static const double firstRadiationConstant = 3.741771852e-16; // W‚ãÖm¬≤

  /// Second radiation constant (c‚ÇÇ)
  /// Value: 1.438776877√ó10‚Åª¬≤ m‚ãÖK
  ///
  /// Used in Planck's law for black-body radiation.
  /// Note: This would ideally be Length √ó Temperature.
  static const double secondRadiationConstant = 1.438776877e-2; // m‚ãÖK

  // === CONVENIENCE METHODS ===

  /// Get speed of light as a ratio of distance to time
  ///
  /// Usage: `final distance = PhysicalConstants.lightSpeed(1.0.seconds);`
  static Length lightSpeed(Time time) {
    final distanceInMeters = speedOfLightPerSecond.value * time.getValue(TimeUnit.second);
    return Length(distanceInMeters, LengthUnit.meter);
  }

  /// Calculate energy equivalent of mass using E = mc¬≤
  ///
  /// Returns energy in joules as a double (until Energy quantity is implemented).
  /// Usage: `final energy = PhysicalConstants.massEnergyEquivalence(1.0.kg);`
  static double massEnergyEquivalence(Mass mass) {
    final massInKg = mass.getValue(MassUnit.kilogram);
    final speedOfLightMs = speedOfLightPerSecond.getValue(LengthUnit.meter); // m/s
    return massInKg * speedOfLightMs * speedOfLightMs; // E = mc¬≤ in joules
  }

  /// Calculate thermal energy using E = kT
  ///
  /// Returns energy in joules as a double.
  /// Usage: `final energy = PhysicalConstants.thermalEnergy(300.0.kelvin);`
  static double thermalEnergy(Temperature temperature) {
    final tempInKelvin = temperature.getValue(TemperatureUnit.kelvin);
    return boltzmannConstant * tempInKelvin; // in joules
  }

  /// Calculate gravitational force between two masses
  ///
  /// Returns force in newtons as a double (until Force quantity is implemented).
  /// Usage: `final force = PhysicalConstants.gravitationalForce(mass1, mass2, distance);`
  static double gravitationalForce(Mass mass1, Mass mass2, Length distance) {
    final m1 = mass1.getValue(MassUnit.kilogram);
    final m2 = mass2.getValue(MassUnit.kilogram);
    final r = distance.getValue(LengthUnit.meter);
    return gravitationalConstant * m1 * m2 / (r * r); // F = Gm‚ÇÅm‚ÇÇ/r¬≤ in newtons
  }

  /// Calculate photon energy from wavelength using E = hc/Œª
  ///
  /// Returns energy in joules as a double.
  /// Usage: `final energy = PhysicalConstants.photonEnergy(500.0.nm);`
  static double photonEnergy(Length wavelength) {
    final lambdaInMeters = wavelength.getValue(LengthUnit.meter);
    final speedOfLightMs = speedOfLightPerSecond.getValue(LengthUnit.meter);
    return planckConstant * speedOfLightMs / lambdaInMeters; // E = hc/Œª in joules
  }

  /// Calculate de Broglie wavelength of a particle
  ///
  /// Returns wavelength as Length.
  /// Usage: `final wavelength = PhysicalConstants.deBroglieWavelength(electronMass, velocity);`
  static Length deBroglieWavelength(Mass mass, double velocityMeterPerSecond) {
    final massInKg = mass.getValue(MassUnit.kilogram);
    final momentum = massInKg * velocityMeterPerSecond; // p = mv
    final wavelengthInMeters = planckConstant / momentum; // Œª = h/p
    return Length(wavelengthInMeters, LengthUnit.meter);
  }
}

<!-- END FILE: [v0.5.0] lib/src/constants/physical_constants.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/core/quantity.dart -->
import 'package:intl/intl.dart';
import 'package:meta/meta.dart';

import 'unit.dart';

/// An abstract representation of a physical quantity, encapsulating a numerical
/// [value] and a specific [unit] of measurement.
///
/// This class serves as the foundation for all specific quantity types (e.g., `Length`,
/// `Pressure`, `Temperature`). It enforces a common interface for unit conversions,
/// comparisons, and string formatting.
///
/// ## Immutability
/// `Quantity` objects are immutable. Operations that might seem to modify a quantity,
/// such as unit conversion (`convertTo`) or arithmetic, always return a new `Quantity`
/// instance with the updated value or unit, leaving the original instance unchanged.
/// This promotes safer and more predictable code.
///
/// ## Type Parameter `T`
/// The type parameter `T` represents the specific `Unit` enum associated with this
/// quantity type. For example, a `Pressure` quantity would use `PressureUnit` for `T`,
/// so it would be declared as `class Pressure extends Quantity<PressureUnit>`.
///
/// ## Comparison
/// `Quantity` implements `Comparable<Quantity<T>>`, allowing quantities of the
/// same type (e.g., two `Length` objects) to be compared based on their physical
/// magnitude, even if their internal units differ. The `compareTo` method handles
/// necessary conversions for accurate comparison.
@immutable
abstract class Quantity<T extends Unit<T>> implements Comparable<Quantity<T>> {
  /// Creates a new `Quantity` with a given numerical [value] and its corresponding [unit].
  ///
  /// Subclasses will typically call this constructor via `super(value, unit)`.
  ///
  /// - [_value]: The numerical magnitude of the quantity.
  /// - [_unit]: The unit of measurement for the `_value`.
  const Quantity(this._value, this._unit);

  /// The internal numerical value of this quantity, represented as a [double].
  /// This value is always in the context of the original [_unit] it was created with.
  final double _value;

  /// The internal unit of measurement for this quantity's [_value].
  /// This is an instance of the specific `Unit` enum `T`.
  final T _unit;

  /// Returns the numerical value of this quantity in its original [unit].
  ///
  /// Example:
  /// ```dart
  /// final length = Length(10.5, LengthUnit.meter);
  /// print(length.value); // Output: 10.5
  /// ```
  double get value => _value;

  /// Returns the unit of measurement associated with this quantity's original [value].
  ///
  /// Example:
  /// ```dart
  /// final length = Length(10.5, LengthUnit.meter);
  /// print(length.unit); // Output: LengthUnit.meter
  /// ```
  T get unit => _unit;

  /// Converts this quantity's [value] to the specified [targetUnit] and
  /// returns the numerical result of this conversion.
  ///
  /// This method must be implemented by concrete subclasses.
  ///
  /// For most quantities (e.g., `Length`, `Pressure`), this involves a direct
  /// multiplication by a conversion factor:
  /// `convertedValue = this.value * this.unit.factorTo(targetUnit)`.
  ///
  /// For quantities with affine conversions (like `Temperature` with Celsius or
  /// Fahrenheit), subclasses must implement specific conversion formulas that
  /// account for offsets (e.g., `(value * 9/5) + 32` for Celsius to Fahrenheit).
  ///
  /// - [targetUnit]: The desired unit to which the current quantity's value
  ///   should be converted.
  ///
  /// Returns the numerical value of this quantity expressed in the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final lengthInMeters = Length(1.0, LengthUnit.kilometer);
  /// double meters = lengthInMeters.getValue(LengthUnit.meter); // meters will be 1000.0
  ///
  /// final tempInCelsius = Temperature(0.0, TemperatureUnit.celsius);
  /// double fahrenheit = tempInCelsius.getValue(TemperatureUnit.fahrenheit); // fahrenheit will be 32.0
  /// ```
  double getValue(T targetUnit);

  /// Creates a new `Quantity` instance of the same type, with its value
  /// converted to the specified [targetUnit].
  ///
  /// This method must be implemented by concrete subclasses.
  /// It should utilize `getValue(targetUnit)` to get the numerical value in the
  /// target unit and then construct a new instance of the concrete quantity type.
  ///
  /// This is useful for obtaining a new `Quantity` object in a different unit
  /// while preserving the type information and immutability.
  ///
  /// - [targetUnit]: The desired unit for the new `Quantity` instance.
  ///
  /// Returns a new `Quantity` instance representing the same physical magnitude
  /// as this instance, but expressed in the [targetUnit]. If `targetUnit` is
  /// the same as `this.unit`, this method might return `this` instance directly
  /// as an optimization, since `Quantity` objects are immutable.
  ///
  /// Example:
  /// ```dart
  /// final lengthInKm = Length(1.5, LengthUnit.kilometer);
  /// final lengthInMeters = lengthInKm.convertTo(LengthUnit.meter);
  /// // lengthInMeters is now Length(1500.0, LengthUnit.meter)
  ///
  /// final tempInC = Temperature(20.0, TemperatureUnit.celsius);
  /// final tempInF = tempInC.convertTo(TemperatureUnit.fahrenheit);
  /// // tempInF is now Temperature(68.0, TemperatureUnit.fahrenheit)
  /// ```
  Quantity<T> convertTo(T targetUnit);

  /// Compares this quantity to another [Quantity] of the same type (`T`).
  ///
  /// This method must be implemented by concrete subclasses.
  /// The comparison is based on the physical magnitude of the quantities.
  /// To achieve this, one quantity (or both) might need to be converted to a
  /// common unit before their numerical values are compared. A common strategy
  /// is to convert `this.value` to `other.unit` using `getValue(other.unit)`
  /// and then compare the result with `other.value`.
  ///
  /// Returns:
  /// - A negative integer if this quantity is less than [other].
  /// - Zero if this quantity is equal in magnitude to [other].
  /// - A positive integer if this quantity is greater than [other].
  ///
  /// This method is essential for sorting collections of `Quantity` objects.
  @override
  int compareTo(Quantity<T> other);

  /// Returns a string representation of this quantity, with options for
  /// formatting and unit conversion.
  ///
  /// By default, it formats as `"[value] [unit_symbol]"` (e.g., "10.5 m"),
  /// using the quantity's current value and unit symbol, separated by a
  /// non-breaking space. Number formatting defaults to Dart's `double.toString()`.
  ///
  /// ## Parameters:
  ///
  /// - [targetUnit]: (Optional) If provided, the quantity's value will be
  ///   converted to this unit *before* formatting. The displayed unit symbol
  ///   will also be that of [targetUnit].
  ///   Example: `1.km.toString(targetUnit: LengthUnit.meter)` might produce "1000.0 m".
  ///
  /// - [fractionDigits]: (Optional) If provided and [numberFormat] is `null`,
  ///   the numerical value will be formatted to this fixed number of decimal places.
  ///   If [locale] is also provided, formatting attempts to respect it for decimal
  ///   and grouping separators (using `NumberFormat.decimalPatternDigits`).
  ///   Otherwise, `double.toStringAsFixed()` is used (locale-agnostic, uses '.' as decimal separator).
  ///   Example: `1.2345.m.toString(fractionDigits: 2)` might produce "1.23 m".
  ///
  /// - [showUnitSymbol]: (Optional) Defaults to `true`. If `false`, only the
  ///   numerical value (potentially converted and formatted) is returned, without
  ///   the unit symbol and separator.
  ///   Example: `10.m.toString(showUnitSymbol: false)` produces "10.0".
  ///
  /// - [unitSymbolSeparator]: (Optional) The string used to separate the formatted
  ///   numerical value and the unit symbol. Defaults to a non-breaking space (`'\u00A0'`).
  ///   Example: `10.m.toString(unitSymbolSeparator: "-")` produces "10.0-m".
  ///
  /// - [locale]: (Optional) A BCP 47 language tag (e.g., 'en_US', 'de_DE').
  ///   If provided and [numberFormat] is `null`, this locale is used for number
  ///   formatting (via `package:intl`). This affects decimal separators, grouping
  ///   separators, etc. Requires the `intl` package to be available.
  ///   Example: `1234.56.m.toString(locale: 'de_DE', fractionDigits: 1)` might produce "1234,6 m".
  ///
  /// - [numberFormat]: (Optional) An explicit `intl.NumberFormat` instance.
  ///   If provided, this takes precedence over [fractionDigits] and [locale] for
  ///   number formatting, offering maximum control. Requires the `intl` package.
  ///   Example:
  ///   ```dart
  ///   final customFormat = NumberFormat("#,##0.000", "en_US");
  ///   print(1234.5.m.toString(numberFormat: customFormat)); // "1,234.500 m"
  ///   ```
  ///
  /// Returns a string representation of the quantity according to the specified options.
  @override
  String toString({
    T? targetUnit,
    int? fractionDigits,
    bool showUnitSymbol = true,
    String unitSymbolSeparator = '\u00A0', // Default: Non-breaking space
    String? locale,
    NumberFormat? numberFormat,
  }) {
    var valueToFormat = _value;
    var unitToDisplay = _unit;

    // Step 1: Convert to target unit if specified.
    // If a target unit is provided and it's different from the current unit,
    // get the value in the target unit for formatting.
    if (targetUnit != null && targetUnit != _unit) {
      valueToFormat = getValue(targetUnit);
      unitToDisplay = targetUnit;
    }

    // Step 2: Format the numerical value.
    String formattedValue;

    if (numberFormat != null) {
      // If an explicit NumberFormat is provided, use it directly. This offers the most control.
      formattedValue = numberFormat.format(valueToFormat);
    } else {
      // Otherwise, use fractionDigits and/or locale if provided.
      if (locale != null) {
        // A locale is specified.
        if (fractionDigits != null) {
          // Both locale and fractionDigits: Use NumberFormat.decimalPatternDigits
          // for locale-aware fixed fraction digits.
          final nf = NumberFormat.decimalPatternDigits(
            locale: locale,
            decimalDigits: fractionDigits,
          );
          formattedValue = nf.format(valueToFormat);
        } else {
          // Locale provided, but no specific fractionDigits: Use a default decimal pattern for the locale.
          final nf = NumberFormat.decimalPattern(locale);
          formattedValue = nf.format(valueToFormat);
        }
      } else {
        // No locale and no explicit NumberFormat. Use Dart's built-in formatting.
        if (fractionDigits != null) {
          // Only fractionDigits provided: Use Dart's toStringAsFixed.
          // This is NOT locale-aware (always uses '.' as decimal separator).
          formattedValue = valueToFormat.toStringAsFixed(fractionDigits);
        } else {
          // No formatting options: Default double to string conversion.
          formattedValue = valueToFormat.toString();
        }
      }
    }

    // Step 3: Construct the final string.
    if (showUnitSymbol) {
      // Append the unit symbol (from unitToDisplay, which is targetUnit if conversion occurred)
      // and the specified separator.
      return '$formattedValue$unitSymbolSeparator${unitToDisplay.symbol}';
    } else {
      // Return only the formatted numerical value.
      return formattedValue;
    }
  }

  /// Determines whether this [Quantity] is equal to another [Object].
  ///
  /// Two `Quantity` instances are considered equal if they are:
  /// 1. The same instance (identical).
  /// 2. Of the exact same runtime type (e.g., both `Length`, not one `Length` and one `Pressure`).
  /// 3. Have the same numerical [value].
  /// 4. Have the same [unit].
  ///
  /// This means `1.m` is NOT equal to `100.cm` according to `==`, because their
  /// units differ, even though their physical magnitudes are the same.
  /// For magnitude comparison, use `compareTo()` or convert to a common unit first.
  ///
  /// - [other]: The object to compare against.
  ///
  /// Returns `true` if the objects are equal based on the criteria above, `false` otherwise.
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Quantity<T> &&
        runtimeType ==
            other.runtimeType && // Ensures strict type equality (e.g., Length != Pressure)
        _value == other._value &&
        _unit == other._unit;
  }

  /// Returns a hash code for this `Quantity` instance.
  ///
  /// The hash code is generated based on the [runtimeType], the numerical [_value],
  /// and the [_unit]. This is consistent with the `operator ==` implementation:
  /// if two `Quantity` objects are equal according to `==`, they will have the
  /// same hash code.
  @override
  int get hashCode => Object.hash(runtimeType, _value, _unit);
}

<!-- END FILE: [v0.5.0] lib/src/core/quantity.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/core/unit.dart -->
import 'package:meta/meta.dart';

/// A contract for all unit enums.
///
/// Each unit enum (e.g., `PressureUnit`, `LengthUnit`) must implement this
/// interface to provide a way to get a conversion factor to another unit
/// of the same type.
///
/// [T] is the specific unit enum type itself (e.g., `PressureUnit`).
abstract class Unit<T extends Unit<T>> {
  /// Returns the direct conversion factor to convert a value from this unit
  /// to the [targetUnit].
  ///
  /// The conversion is performed by multiplying the original value by this factor:
  /// `convertedValue = originalValue * this.factorTo(targetUnit);`
  @internal
  double factorTo(T targetUnit);

  /// A human-readable symbol or abbreviation for the unit.
  ///
  /// This should be a concise representation suitable for display.
  /// For example: "m" for Meter, "psi" for Pound per Square Inch, "¬∞C" for Celsius.
  String get symbol;
}

<!-- END FILE: [v0.5.0] lib/src/core/unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/angle/angle.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'angle_unit.dart';

/// Represents a quantity of a plane angle.
///
/// Although angle is a dimensionless quantity in the SI system, it is treated
/// as a distinct quantity type for type safety and clarity. This class provides a
/// way to handle angle values and conversions between different units like
/// degrees, radians, and revolutions.
@immutable
class Angle extends Quantity<AngleUnit> {
  /// Creates a new `Angle` quantity with the given numerical [value] and [unit].
  const Angle(super.value, super.unit);

  /// Converts this angle's value to the specified [targetUnit].
  @override
  double getValue(AngleUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Angle] instance with the value converted to the [targetUnit].
  @override
  Angle convertTo(AngleUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Angle(newValue, targetUnit);
  }

  /// Compares this [Angle] object to another [Quantity<AngleUnit>].
  @override
  int compareTo(Quantity<AngleUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this angle to another angle.
  Angle operator +(Angle other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Angle(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another angle from this angle.
  Angle operator -(Angle other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Angle(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this angle by a scalar value.
  Angle operator *(double scalar) {
    return Angle(value * scalar, unit);
  }

  /// Divides this angle by a scalar value.
  Angle operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Angle(value / scalar, unit);
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/angle/angle.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/angle/angle_extensions.dart -->
import 'angle.dart';
import 'angle_unit.dart';

/// Provides convenient access to [Angle] values in specific units.
extension AngleValueGetters on Angle {
  /// Returns the angle value in Radians (rad).
  double get inRadians => getValue(AngleUnit.radian);

  /// Returns the angle value in Degrees (¬∞).
  double get inDegrees => getValue(AngleUnit.degree);

  /// Returns the angle value in Gradians (grad).
  double get inGradians => getValue(AngleUnit.gradian);

  /// Returns the angle value in Revolutions (rev).
  double get inRevolutions => getValue(AngleUnit.revolution);

  /// Returns the angle value in Arcminutes (').
  double get inArcminutes => getValue(AngleUnit.arcminute);

  /// Returns the angle value in Arcseconds (").
  double get inArcseconds => getValue(AngleUnit.arcsecond);

  /// Returns the angle value in Milliradians (mrad).
  double get inMilliradians => getValue(AngleUnit.milliradian);

  /// Returns an [Angle] object representing this angle in Radians (rad).
  Angle get asRadians => convertTo(AngleUnit.radian);

  /// Returns an [Angle] object representing this angle in Degrees (¬∞).
  Angle get asDegrees => convertTo(AngleUnit.degree);

  /// Returns an [Angle] object representing this angle in Gradians (grad).
  Angle get asGradians => convertTo(AngleUnit.gradian);

  /// Returns an [Angle] object representing this angle in Revolutions (rev).
  Angle get asRevolutions => convertTo(AngleUnit.revolution);

  /// Returns an [Angle] object representing this angle in Arcminutes (').
  Angle get asArcminutes => convertTo(AngleUnit.arcminute);

  /// Returns an [Angle] object representing this angle in Arcseconds (").
  Angle get asArcseconds => convertTo(AngleUnit.arcsecond);

  /// Returns an [Angle] object representing this angle in Milliradians (mrad).
  Angle get asMilliradians => convertTo(AngleUnit.milliradian);
}

/// Provides convenient factory methods for creating [Angle] instances from [num].
extension AngleCreation on num {
  /// Creates an [Angle] instance from this numerical value in Radians (rad).
  Angle get radians => Angle(toDouble(), AngleUnit.radian);

  /// Creates an [Angle] instance from this numerical value in Degrees (¬∞).
  Angle get degrees => Angle(toDouble(), AngleUnit.degree);

  /// Creates an [Angle] instance from this numerical value in Gradians (grad).
  Angle get gradians => Angle(toDouble(), AngleUnit.gradian);

  /// Creates an [Angle] instance from this numerical value in Gradians (grad).
  /// Alias for `gradians`.
  Angle get grad => Angle(toDouble(), AngleUnit.gradian);

  /// Creates an [Angle] instance from this numerical value in Revolutions (rev).
  Angle get revolutions => Angle(toDouble(), AngleUnit.revolution);

  /// Creates an [Angle] instance from this numerical value in Revolutions (rev).
  /// Alias for `revolutions`.
  Angle get rev => Angle(toDouble(), AngleUnit.revolution);

  /// Creates an [Angle] instance from this numerical value in Arcminutes (').
  Angle get arcminutes => Angle(toDouble(), AngleUnit.arcminute);

  /// Creates an [Angle] instance from this numerical value in Arcseconds (").
  Angle get arcseconds => Angle(toDouble(), AngleUnit.arcsecond);

  /// Creates an [Angle] instance from this numerical value in Milliradians (mrad).
  Angle get milliradians => Angle(toDouble(), AngleUnit.milliradian);

  /// Creates an [Angle] instance from this numerical value in Milliradians (mrad).
  /// Alias for `milliradians`.
  Angle get mrad => Angle(toDouble(), AngleUnit.milliradian);
}

<!-- END FILE: [v0.5.0] lib/src/units/angle/angle_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/angle/angle_factors.dart -->
import 'dart:math' as math;

/// Defines base conversion factors for various angle units relative to the
/// Radian (rad), which is the SI-derived unit for plane angle and the
/// standard for `dart:math`.
class AngleFactors {
  // --- Factors to convert FROM a unit TO Radians (the base unit) ---
  // Formula: 1 [Unit] = Z [Radians]

  /// Radians per Revolution. Base for other cyclic units.
  static const double radiansPerRevolution = 2 * math.pi;

  /// Radians per Degree.
  static const double radiansPerDegree = radiansPerRevolution / 360.0;

  /// Radians per Gradian.
  static const double radiansPerGradian = radiansPerRevolution / 400.0;

  /// Radians per Arcminute.
  static const double radiansPerArcminute = radiansPerDegree / 60.0;

  /// Radians per Arcsecond.
  static const double radiansPerArcsecond = radiansPerArcminute / 60.0;

  /// Radians per Milliradian.
  static const double radiansPerMilliradian = 0.001;

  // --- Factors to convert FROM Radians TO a unit ---
  // This avoids division of imprecise doubles in the const constructor.
  // Formula: 1 Radian = Z [Unit]

  /// Degrees per Radian.
  static const double degreesPerRadian = 180.0 / math.pi;

  /// Gradians per Radian.
  static const double gradiansPerRadian = 200.0 / math.pi;

  /// Revolutions per Radian.
  static const double revolutionsPerRadian = 1.0 / (2 * math.pi);

  /// Arcminutes per Radian.
  static const double arcminutesPerRadian = degreesPerRadian * 60.0;

  /// Arcseconds per Radian.
  static const double arcsecondsPerRadian = arcminutesPerRadian * 60.0;

  /// Milliradians per Radian.
  static const double milliradiansPerRadian = 1000;
}

<!-- END FILE: [v0.5.0] lib/src/units/angle/angle_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/angle/angle_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'angle_factors.dart';

/// Represents units for a plane angle.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each angle unit. All conversion factors are
/// pre-calculated in the constructor relative to Radian (rad).
enum AngleUnit implements Unit<AngleUnit> {
  /// Radian (rad), the SI-derived unit of angle. Used by `dart:math`.
  radian(1, 'rad'),

  /// Degree (¬∞), the most common unit of angle. 360¬∞ in a full circle.
  degree(AngleFactors.radiansPerDegree, '¬∞'),

  /// Gradian (grad/gon), a unit of angle where a right angle is 100 gradians.
  /// 400 grad in a full circle. Commonly used in surveying.
  gradian(AngleFactors.radiansPerGradian, 'grad'),

  /// Revolution (rev/turn), where 1 revolution is a full circle.
  revolution(AngleFactors.radiansPerRevolution, 'rev'),

  /// Arcminute ('), a unit of angle equal to 1/60 of a degree.
  /// Used in astronomy and navigation.
  arcminute(AngleFactors.radiansPerArcminute, "'"),

  /// Arcsecond ("), a unit of angle equal to 1/60 of an arcminute.
  /// Used for very precise angular measurements.
  arcsecond(AngleFactors.radiansPerArcsecond, '"'),

  /// Milliradian (mrad), equal to 0.001 radians.
  /// Used in optics and ballistics.
  milliradian(AngleFactors.radiansPerMilliradian, 'mrad');

  /// Constant constructor for enum members.
  ///
  /// [_toRadianFactor] is the factor to convert from this unit to the base unit (Radian).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `AngleUnit`.
  const AngleUnit(double toRadianFactor, this.symbol)
      : _toRadianFactor = toRadianFactor,
        _factorToRadian = toRadianFactor,
        _factorToDegree = toRadianFactor * AngleFactors.degreesPerRadian,
        _factorToGradian = toRadianFactor * AngleFactors.gradiansPerRadian,
        _factorToRevolution = toRadianFactor * AngleFactors.revolutionsPerRadian,
        _factorToArcminute = toRadianFactor * AngleFactors.arcminutesPerRadian,
        _factorToArcsecond = toRadianFactor * AngleFactors.arcsecondsPerRadian,
        _factorToMilliradian = toRadianFactor * AngleFactors.milliradiansPerRadian;

  // ignore: unused_field // The factor to convert from this unit to Radian.
  final double _toRadianFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToRadian;
  final double _factorToDegree;
  final double _factorToGradian;
  final double _factorToRevolution;
  final double _factorToArcminute;
  final double _factorToArcsecond;
  final double _factorToMilliradian;

  /// Returns the direct conversion factor to convert a value from this [AngleUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(AngleUnit targetUnit) {
    switch (targetUnit) {
      case AngleUnit.radian:
        return _factorToRadian;
      case AngleUnit.degree:
        return _factorToDegree;
      case AngleUnit.gradian:
        return _factorToGradian;
      case AngleUnit.revolution:
        return _factorToRevolution;
      case AngleUnit.arcminute:
        return _factorToArcminute;
      case AngleUnit.arcsecond:
        return _factorToArcsecond;
      case AngleUnit.milliradian:
        return _factorToMilliradian;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/angle/angle_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/angular_velocity/angular_velocity.dart -->
// lib/src/units/angular_velocity/angular_velocity.dart
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import '../angle/angle.dart';
import '../angle/angle_unit.dart';
import '../time/time.dart';
import '../time/time_extensions.dart';
import 'angular_velocity_unit.dart';

/// Represents a quantity of angular velocity (or rotational speed).
///
/// Angular velocity is a derived quantity representing the rate of change of
/// an angle over time. The SI unit is radians per second (rad/s).
@immutable
class AngularVelocity extends Quantity<AngularVelocityUnit> {
  /// Creates a new `AngularVelocity` with a given [value] and [unit].
  const AngularVelocity(super.value, super.unit);

  /// Converts this angular velocity's value to the specified [targetUnit].
  @override
  double getValue(AngularVelocityUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [AngularVelocity] instance with the value converted to the [targetUnit].
  @override
  AngularVelocity convertTo(AngularVelocityUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return AngularVelocity(newValue, targetUnit);
  }

  @override
  int compareTo(Quantity<AngularVelocityUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this angular velocity to another.
  AngularVelocity operator +(AngularVelocity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return AngularVelocity(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another angular velocity from this one.
  AngularVelocity operator -(AngularVelocity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return AngularVelocity(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this angular velocity by a scalar.
  AngularVelocity operator *(double scalar) {
    return AngularVelocity(value * scalar, unit);
  }

  /// Divides this angular velocity by a scalar.
  AngularVelocity operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return AngularVelocity(value / scalar, unit);
  }

  // --- Dimensional Analysis: Methode statt √ºberladenem Operator ---

  /// Calculates the total [Angle] of rotation over a given [Time] duration.
  ///
  /// `Angle = Angular Velocity √ó Time`
  ///
  /// The calculation is performed in the base units (rad/s and s) to ensure
  /// correctness, and the result is returned as an [Angle] in radians.
  ///
  /// Example:
  /// ```dart
  /// final speed = 3000.rpm;
  /// final duration = 2.0.seconds;
  /// final totalAngle = speed.totalAngleOver(duration);
  /// print(totalAngle.inRevolutions); // Output: 100.0
  /// ```
  Angle totalAngleOver(Time time) {
    final valueInRadPerSec = getValue(AngularVelocityUnit.radianPerSecond);
    final timeInSeconds = time.inSeconds;
    final resultingAngleInRadians = valueInRadPerSec * timeInSeconds;
    return Angle(resultingAngleInRadians, AngleUnit.radian);
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/angular_velocity/angular_velocity.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/angular_velocity/angular_velocity_extensions.dart -->
import 'angular_velocity.dart';
import 'angular_velocity_unit.dart';

/// Provides convenient access to [AngularVelocity] values in specific units.
extension AngularVelocityValueGetters on AngularVelocity {
  /// Returns the value in Radians per second (rad/s).
  double get inRadiansPerSecond => getValue(AngularVelocityUnit.radianPerSecond);

  /// Returns the value in Degrees per second (¬∞/s).
  double get inDegreesPerSecond => getValue(AngularVelocityUnit.degreePerSecond);

  /// Returns the value in Revolutions per minute (rpm).
  double get inRpm => getValue(AngularVelocityUnit.revolutionPerMinute);

  /// Returns the value in Revolutions per second (rps).
  double get inRps => getValue(AngularVelocityUnit.revolutionPerSecond);

  /// Returns an [AngularVelocity] object in Radians per second (rad/s).
  AngularVelocity get asRadiansPerSecond => convertTo(AngularVelocityUnit.radianPerSecond);

  /// Returns an [AngularVelocity] object in Degrees per second (¬∞/s).
  AngularVelocity get asDegreesPerSecond => convertTo(AngularVelocityUnit.degreePerSecond);

  /// Returns an [AngularVelocity] object in Revolutions per minute (rpm).
  AngularVelocity get asRpm => convertTo(AngularVelocityUnit.revolutionPerMinute);

  /// Returns an [AngularVelocity] object in Revolutions per second (rps).
  AngularVelocity get asRps => convertTo(AngularVelocityUnit.revolutionPerSecond);
}

/// Provides convenient factory methods for creating [AngularVelocity] instances from [num].
extension AngularVelocityCreation on num {
  /// Creates an [AngularVelocity] from this value in Radians per second (rad/s).
  AngularVelocity get radiansPerSecond =>
      AngularVelocity(toDouble(), AngularVelocityUnit.radianPerSecond);

  /// Creates an [AngularVelocity] from this value in Degrees per second (¬∞/s).
  AngularVelocity get degreesPerSecond =>
      AngularVelocity(toDouble(), AngularVelocityUnit.degreePerSecond);

  /// Creates an [AngularVelocity] from this value in Revolutions per minute (rpm).
  AngularVelocity get rpm => AngularVelocity(toDouble(), AngularVelocityUnit.revolutionPerMinute);

  /// Creates an [AngularVelocity] from this value in Revolutions per second (rps).
  AngularVelocity get rps => AngularVelocity(toDouble(), AngularVelocityUnit.revolutionPerSecond);

  /// Alias for `rps`.
  AngularVelocity get revolutionsPerSecond =>
      AngularVelocity(toDouble(), AngularVelocityUnit.revolutionPerSecond);
}

<!-- END FILE: [v0.5.0] lib/src/units/angular_velocity/angular_velocity_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/angular_velocity/angular_velocity_factors.dart -->
import '../angle/angle_factors.dart';

/// Defines base conversion factors for various angular velocity units relative
/// to the Radian per Second (rad/s), which is the SI-derived unit.
///
/// These constants represent: `1 [Unit] = Z [Radians Per Second]`.
class AngularVelocityFactors {
  /// Radians per second per Degree per second: 1 ¬∞/s = (œÄ/180) rad/s.
  static const double radPSecPerDegPSec = AngleFactors.radiansPerDegree;

  /// Radians per second per Revolution per minute (RPM): 1 rev/min = (2œÄ/60) rad/s.
  static const double radPSecPerRevPMin = AngleFactors.radiansPerRevolution / 60.0;

  /// Radians per second per Revolution per second (RPS): 1 rev/s = 2œÄ rad/s.
  static const double radPSecPerRevPSec = AngleFactors.radiansPerRevolution;
}

<!-- END FILE: [v0.5.0] lib/src/units/angular_velocity/angular_velocity_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/angular_velocity/angular_velocity_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'angular_velocity_factors.dart';

/// Represents units for angular velocity.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each angular velocity unit. All conversion factors
/// are pre-calculated in the constructor relative to Radian per Second (rad/s).
enum AngularVelocityUnit implements Unit<AngularVelocityUnit> {
  /// Radian per second (rad/s), the SI-derived unit of angular velocity.
  radianPerSecond(1, 'rad/s'),

  /// Degree per second (¬∞/s).
  degreePerSecond(AngularVelocityFactors.radPSecPerDegPSec, '¬∞/s'),

  /// Revolution per minute (rpm), a common unit for rotational speed.
  revolutionPerMinute(AngularVelocityFactors.radPSecPerRevPMin, 'rpm'),

  /// Revolution per second (rps).
  revolutionPerSecond(AngularVelocityFactors.radPSecPerRevPSec, 'rps');

  /// Constant constructor for enum members.
  const AngularVelocityUnit(double toBaseFactor, this.symbol)
      : _toRadPerSecFactor = toBaseFactor,
        _factorToRadianPerSecond = toBaseFactor / 1.0,
        _factorToDegreePerSecond = toBaseFactor / AngularVelocityFactors.radPSecPerDegPSec,
        _factorToRevolutionPerMinute = toBaseFactor / AngularVelocityFactors.radPSecPerRevPMin,
        _factorToRevolutionPerSecond = toBaseFactor / AngularVelocityFactors.radPSecPerRevPSec;

  // ignore: unused_field // The factor to convert from this unit to Radian per Second.
  final double _toRadPerSecFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToRadianPerSecond;
  final double _factorToDegreePerSecond;
  final double _factorToRevolutionPerMinute;
  final double _factorToRevolutionPerSecond;

  @override
  @internal
  double factorTo(AngularVelocityUnit targetUnit) {
    switch (targetUnit) {
      case AngularVelocityUnit.radianPerSecond:
        return _factorToRadianPerSecond;
      case AngularVelocityUnit.degreePerSecond:
        return _factorToDegreePerSecond;
      case AngularVelocityUnit.revolutionPerMinute:
        return _factorToRevolutionPerMinute;
      case AngularVelocityUnit.revolutionPerSecond:
        return _factorToRevolutionPerSecond;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/angular_velocity/angular_velocity_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/current/current.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'current_unit.dart';

/// Represents a quantity of electric current.
///
/// Electric current is the rate of flow of electric charge. The SI base unit
/// for electric current is the Ampere (A). It is a fundamental quantity in
/// electrical engineering and physics.
///
/// This class provides a type-safe way to handle electric current values and
/// conversions between different units (e.g., amperes, milliamperes, kiloamperes).
@immutable
class Current extends Quantity<CurrentUnit> {
  /// Creates a new `Current` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final circuitCurrent = Current(1.5, CurrentUnit.ampere);
  /// final sensorOutput = Current(20.0, CurrentUnit.milliampere);
  /// ```
  const Current(super.value, super.unit);

  /// Converts this electric current's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `CurrentUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final currentInAmperes = Current(0.05, CurrentUnit.ampere);
  /// final valueInMilliamperes = currentInAmperes.getValue(CurrentUnit.milliampere); // 50.0
  /// ```
  @override
  double getValue(CurrentUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Current] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Current` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final currentInMilliamperes = Current(2500.0, CurrentUnit.milliampere);
  /// final currentInAmperesObj = currentInMilliamperes.convertTo(CurrentUnit.ampere);
  /// // currentInAmperesObj is Current(2.5, CurrentUnit.ampere)
  /// print(currentInAmperesObj); // Output: "2.5 A" (depending on toString formatting)
  /// ```
  @override
  Current convertTo(CurrentUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Current(newValue, targetUnit);
  }

  /// Compares this [Current] object to another [Quantity<CurrentUnit>].
  ///
  /// Comparison is based on the physical magnitude of the electric currents.
  /// For an accurate comparison, this current's value is converted to the unit
  /// of the [other] current before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this current is less than [other].
  /// - Zero if this current is equal in magnitude to [other].
  /// - A positive integer if this current is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final c1 = Current(1.0, CurrentUnit.ampere);        // 1000 mA
  /// final c2 = Current(1000.0, CurrentUnit.milliampere); // 1000 mA
  /// final c3 = Current(0.5, CurrentUnit.ampere);       // 500 mA
  ///
  /// print(c1.compareTo(c2)); // 0 (equal magnitude)
  /// print(c1.compareTo(c3)); // 1 (c1 > c3)
  /// print(c3.compareTo(c1)); // -1 (c3 < c1)
  /// ```
  @override
  int compareTo(Quantity<CurrentUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this electric current to another electric current.
  ///
  /// The [other] current is converted to the unit of this current before addition.
  /// The result is a new [Current] instance with the sum, expressed in the unit of this current.
  /// This is physically meaningful in contexts like Kirchhoff's Current Law (junction rule).
  ///
  /// Example:
  /// ```dart
  /// final currentBranchA = Current(0.75, CurrentUnit.ampere);
  /// final currentBranchB = Current(250.0, CurrentUnit.milliampere); // 0.25 A
  /// final totalCurrent = currentBranchA + currentBranchB; // Result: Current(1.0, CurrentUnit.ampere)
  /// ```
  Current operator +(Current other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Current(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another electric current from this electric current.
  ///
  /// The [other] current is converted to the unit of this current before subtraction.
  /// The result is a new [Current] instance with the difference, expressed in the unit of this current.
  ///
  /// Example:
  /// ```dart
  /// final mainCurrent = Current(2.0, CurrentUnit.ampere);
  /// final currentToDevice = Current(800.0, CurrentUnit.milliampere); // 0.8 A
  /// final remainingCurrent = mainCurrent - currentToDevice; // Result: Current(1.2, CurrentUnit.ampere)
  /// ```
  Current operator -(Current other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Current(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this electric current by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Current] instance with the scaled value, in the original unit of this current.
  /// This might be used, for example, if a current is distributed equally among several paths.
  ///
  /// Example:
  /// ```dart
  /// final currentPerWire = Current(0.1, CurrentUnit.ampere);
  /// final totalCurrentFor5Wires = currentPerWire * 5.0; // Result: Current(0.5, CurrentUnit.ampere)
  /// ```
  Current operator *(double scalar) {
    return Current(value * scalar, unit);
  }

  /// Divides this electric current by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Current] instance with the scaled value, in the original unit of this current.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalCurrent = Current(1.0, CurrentUnit.ampere);
  /// final currentPerBranch = totalCurrent / 4.0; // Result: Current(0.25, CurrentUnit.ampere)
  /// ```
  Current operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Current(value / scalar, unit);
  }

  // Potential future enhancements for Current:
  // - Current * Time = ElectricCharge (would require ElectricCharge type)
  // - ElectricPotential / Current = Resistance (would require ElectricPotential and Resistance types)
  // - Power / Current = ElectricPotential (would require Power and ElectricPotential types)
}

<!-- END FILE: [v0.5.0] lib/src/units/current/current.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/current/current_extensions.dart -->
import 'current.dart';
import 'current_unit.dart';

/// Provides convenient access to [Current] values in specific units
/// using getter properties.
extension CurrentValueGetters on Current {
  /// Returns the electric current value in Amperes (A).
  double get inAmperes => getValue(CurrentUnit.ampere);

  /// Returns the electric current value in Milliamperes (mA).
  double get inMilliamperes => getValue(CurrentUnit.milliampere);

  /// Returns the electric current value in Microamperes (¬µA).
  double get inMicroamperes => getValue(CurrentUnit.microampere);

  /// Returns the electric current value in Nanoamperes (nA).
  double get inNanoamperes => getValue(CurrentUnit.nanoampere);

  /// Returns the electric current value in Kiloamperes (kA).
  double get inKiloamperes => getValue(CurrentUnit.kiloampere);

  /// Returns the electric current value in Statamperes (statA).
  double get inStatamperes => getValue(CurrentUnit.statampere);

  /// Returns the electric current value in Abamperes (abA) or Biot (Bi).
  double get inAbamperes => getValue(CurrentUnit.abampere);

  // --- "As" Getters for new Current objects ---

  /// Returns a new [Current] object representing this current in Amperes (A).
  Current get asAmperes => convertTo(CurrentUnit.ampere);

  /// Returns a new [Current] object representing this current in Milliamperes (mA).
  Current get asMilliamperes => convertTo(CurrentUnit.milliampere);

  /// Returns a new [Current] object representing this current in Microamperes (¬µA).
  Current get asMicroamperes => convertTo(CurrentUnit.microampere);

  /// Returns a new [Current] object representing this current in Nanoamperes (nA).
  Current get asNanoamperes => convertTo(CurrentUnit.nanoampere);

  /// Returns a new [Current] object representing this current in Kiloamperes (kA).
  Current get asKiloamperes => convertTo(CurrentUnit.kiloampere);

  /// Returns a new [Current] object representing this current in Statamperes (statA).
  Current get asStatamperes => convertTo(CurrentUnit.statampere);

  /// Returns a new [Current] object representing this current in Abamperes (abA) or Biot (Bi).
  Current get asAbamperes => convertTo(CurrentUnit.abampere);
}

/// Provides convenient factory methods for creating [Current] instances from [num]
/// using getter properties named after common unit symbols or names.
extension CurrentCreation on num {
  /// Creates a [Current] instance representing this numerical value in Amperes (A).
  Current get A => Current(toDouble(), CurrentUnit.ampere); // Using symbol 'A'

  /// Creates a [Current] instance representing this numerical value in Amperes (A).
  /// Alias for `A`.
  Current get amperes => Current(toDouble(), CurrentUnit.ampere);

  /// Creates a [Current] instance representing this numerical value in Milliamperes (mA).
  Current get mA => Current(toDouble(), CurrentUnit.milliampere);

  /// Creates a [Current] instance representing this numerical value in Milliamperes (mA).
  /// Alias for `mA`.
  Current get milliamperes => Current(toDouble(), CurrentUnit.milliampere);

  /// Creates a [Current] instance representing this numerical value in Microamperes (¬µA).
  Current get uA => Current(toDouble(), CurrentUnit.microampere); // Using 'uA' for micro

  /// Creates a [Current] instance representing this numerical value in Microamperes (¬µA).
  /// Alias for `uA`.
  Current get microamperes => Current(toDouble(), CurrentUnit.microampere);

  /// Creates a [Current] instance representing this numerical value in Nanoamperes (nA).
  Current get nA => Current(toDouble(), CurrentUnit.nanoampere);

  /// Creates a [Current] instance representing this numerical value in Nanoamperes (nA).
  /// Alias for `nA`.
  Current get nanoamperes => Current(toDouble(), CurrentUnit.nanoampere);

  /// Creates a [Current] instance representing this numerical value in Kiloamperes (kA).
  Current get kA => Current(toDouble(), CurrentUnit.kiloampere);

  /// Creates a [Current] instance representing this numerical value in Kiloamperes (kA).
  /// Alias for `kA`.
  Current get kiloamperes => Current(toDouble(), CurrentUnit.kiloampere);

  /// Creates a [Current] instance from this numerical value in Statamperes (statA).
  Current get statA => Current(toDouble(), CurrentUnit.statampere);

  /// Creates a [Current] instance from this numerical value in Statamperes (statA).
  /// Alias for `statA`.
  Current get statamperes => Current(toDouble(), CurrentUnit.statampere);

  /// Creates a [Current] instance from this numerical value in Abamperes (abA).
  Current get abA => Current(toDouble(), CurrentUnit.abampere);

  /// Creates a [Current] instance from this numerical value in Abamperes (abA).
  /// Alias for `abA`, also known as Biot (Bi).
  Current get abamperes => Current(toDouble(), CurrentUnit.abampere);

  /// Creates a [Current] instance from this numerical value in Biot (Bi).
  /// This is an alias for Abampere (`abA`).
  Current get bi => Current(toDouble(), CurrentUnit.abampere);
}

<!-- END FILE: [v0.5.0] lib/src/units/current/current_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/current/current_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

/// Defines base conversion factors for various electric current units relative
/// to the Ampere (A), which is the SI base unit for electric current.
///
/// These constants represent: `1 [Unit] = Z [Amperes]`.
/// So, `amperesPerMilliampere` means `1 milliampere = amperesPerMilliampere amperes`.
class CurrentFactors {
  // --- SI Prefixed Units (relative to Ampere) ---

  /// Amperes per Milliampere: 1 milliampere (mA) = 0.001 amperes (A).
  static const double amperesPerMilliampere = 0.001;

  /// Amperes per Microampere: 1 microampere (¬µA) = 0.000001 amperes (A).
  static const double amperesPerMicroampere = 0.000001; // 1e-6

  /// Amperes per Nanoampere: 1 nanoampere (nA) = 1e-9 amperes (A).
  static const double amperesPerNanoampere = 1.0e-9;

  /// Amperes per Kiloampere: 1 kiloampere (kA) = 1000 amperes (A).
  static const double amperesPerKiloampere = 1000.0;

  /// Amperes per Statampere: 1 statampere (statA) ‚âà 3.33564 √ó 10‚Åª¬π‚Å∞ Amperes.
  /// The statampere is the unit of current in the CGS electrostatic system.
  /// It is defined as 1 statcoulomb per second.
  static const double amperesPerStatampere = 3.3356409519815204e-10;

  /// Amperes per Abampere (or Biot): 1 abampere (abA) = 10 Amperes.
  /// The abampere is the unit of current in the CGS electromagnetic system.
  /// It is also known as the biot (Bi).
  static const double amperesPerAbampere = 10.0;
}

<!-- END FILE: [v0.5.0] lib/src/units/current/current_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/current/current_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'current_factors.dart';

/// Represents units for electric current.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each electric current unit.
/// All conversion factors are pre-calculated in the constructor relative to Ampere (A),
/// which is the SI base unit for electric current.
enum CurrentUnit implements Unit<CurrentUnit> {
  /// Ampere (A), the SI base unit of electric current.
  /// Defined by taking the fixed numerical value of the elementary charge *e* to be
  /// 1.602176634 √ó 10‚Åª¬π‚Åπ when expressed in the unit C, which is equal to A s.
  ampere(1, 'A'),

  /// Milliampere (mA), equal to 0.001 amperes.
  milliampere(CurrentFactors.amperesPerMilliampere, 'mA'),

  /// Microampere (¬µA), equal to 1e-6 amperes.
  microampere(CurrentFactors.amperesPerMicroampere, '¬µA'),

  /// Nanoampere (nA), equal to 1e-9 amperes.
  nanoampere(CurrentFactors.amperesPerNanoampere, 'nA'),

  /// Kiloampere (kA), equal to 1000 amperes.
  kiloampere(CurrentFactors.amperesPerKiloampere, 'kA'),

  /// Statampere (statA), the CGS electrostatic unit of current.
  statampere(CurrentFactors.amperesPerStatampere, 'statA'),

  /// Abampere (abA) or Biot (Bi), the CGS electromagnetic unit of current.
  abampere(CurrentFactors.amperesPerAbampere, 'abA');

  /// Constant constructor for enum members.
  ///
  /// [_toAmpereFactor] is the factor to convert from this unit to the base unit (Ampere).
  /// For Ampere itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `CurrentUnit`.
  const CurrentUnit(double toAmpereFactor, this.symbol)
      : _toAmpereFactor = toAmpereFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToAmpere = toAmpereFactor / 1.0, // Base unit factor for ampere is 1.0
        _factorToMilliampere = toAmpereFactor / CurrentFactors.amperesPerMilliampere,
        _factorToMicroampere = toAmpereFactor / CurrentFactors.amperesPerMicroampere,
        _factorToNanoampere = toAmpereFactor / CurrentFactors.amperesPerNanoampere,
        _factorToKiloampere = toAmpereFactor / CurrentFactors.amperesPerKiloampere,
        _factorToStatampere = toAmpereFactor / CurrentFactors.amperesPerStatampere,
        _factorToAbampere = toAmpereFactor / CurrentFactors.amperesPerAbampere;
  // If biot were added:
  // _factorToBiot = toAmpereFactor / CurrentFactors.amperesPerBiot;

  /// The factor to convert a value from this unit to the base unit (Ampere).
  /// Example: For Milliampere, this is 0.001 (meaning 1 mA = 0.001 A).
  /// This field is primarily used internally by the constructor.
  // ignore: unused_field
  final double _toAmpereFactor;

  /// The human-readable symbol for this electric current unit (e.g., "A", "mA").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToAmpere;
  final double _factorToMilliampere;
  final double _factorToMicroampere;
  final double _factorToNanoampere;
  final double _factorToKiloampere;
  final double _factorToStatampere;
  final double _factorToAbampere;

  /// Returns the direct conversion factor to convert a value from this [CurrentUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `Current`
  /// class for conversions.
  @override
  @internal
  double factorTo(CurrentUnit targetUnit) {
    switch (targetUnit) {
      case CurrentUnit.ampere:
        return _factorToAmpere;
      case CurrentUnit.milliampere:
        return _factorToMilliampere;
      case CurrentUnit.microampere:
        return _factorToMicroampere;
      case CurrentUnit.nanoampere:
        return _factorToNanoampere;
      case CurrentUnit.kiloampere:
        return _factorToKiloampere;
      case CurrentUnit.statampere:
        return _factorToStatampere;
      case CurrentUnit.abampere:
        return _factorToAbampere;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/current/current_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/length/length.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'length_unit.dart';

/// Represents a quantity of length.
@immutable
class Length extends Quantity<LengthUnit> {
  /// Creates a new Length quantity with the given [value] and [unit].
  const Length(super.value, super.unit);

  /// Converts this length's value to the specified [targetUnit].
  @override
  double getValue(LengthUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Length] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Length` object in a different unit
  /// without losing the type information.
  ///
  /// Example:
  /// ```dart
  /// final oneFoot = Length(1.0, LengthUnit.foot);
  /// final inInches = oneFoot.convertTo(LengthUnit.inch); // Length(12.0, LengthUnit.inch)
  /// print(inInches.value); // 12.0
  /// ```
  @override
  Length convertTo(LengthUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Length(newValue, targetUnit);
  }

  /// Compares this [Length] object to another [Quantity<LengthUnit>].
  ///
  /// Comparison is based on the physical magnitude of the lengths.
  /// For comparison, this length is converted to the unit of the [other] length.
  ///
  /// Returns:
  /// - A negative integer if this length is less than [other].
  /// - Zero if this length is equal to [other].
  /// - A positive integer if this length is greater than [other].
  @override
  int compareTo(Quantity<LengthUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this length to another length.
  /// The [other] length is converted to the unit of this length before addition.
  /// Returns a new [Length] instance with the result in the unit of this length.
  Length operator +(Length other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Length(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another length from this length.
  /// The [other] length is converted to the unit of this length before subtraction.
  /// Returns a new [Length] instance with the result in the unit of this length.
  Length operator -(Length other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Length(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this length by a scalar value.
  /// Returns a new [Length] instance with the scaled value in the original unit.
  Length operator *(double scalar) {
    return Length(value * scalar, unit);
  }

  /// Divides this length by a scalar value.
  /// Returns a new [Length] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Length operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Length(value / scalar, unit);
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/length/length.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/length/length_extensions.dart -->
import 'length.dart';
import 'length_unit.dart';

/// Provides convenient access to [Length] values in specific units
/// using shortened unit names where appropriate.
extension LengthValueGetters on Length {
  /// Returns the length value in Meters (m).
  double get inM => getValue(LengthUnit.meter);

  /// Returns the length value in Kilometers (km).
  double get inKm => getValue(LengthUnit.kilometer);

  /// Returns the length value in Megameters (Mm).
  double get inMegaM => getValue(LengthUnit.megameter);

  /// Returns the length value in Gigameters (Gm).
  double get inGigaM => getValue(LengthUnit.gigameter);

  /// Returns the length value in Hectometers (hm).
  double get inHm => getValue(LengthUnit.hectometer);

  /// Returns the length value in Decameters (dam).
  double get inDam => getValue(LengthUnit.decameter);

  /// Returns the length value in Decimeters (dm).
  double get inDm => getValue(LengthUnit.decimeter);

  /// Returns the length value in Centimeters (cm).
  double get inCm => getValue(LengthUnit.centimeter);

  /// Returns the length value in Millimeters (mm).
  double get inMm => getValue(LengthUnit.millimeter);

  /// Returns the length value in Micrometers (Œºm).
  double get inUm => getValue(LengthUnit.micrometer);

  /// Returns the length value in Nanometers (nm).
  double get inNm => getValue(LengthUnit.nanometer);

  /// Returns the length value in Picometers (pm).
  double get inPm => getValue(LengthUnit.picometer);

  /// Returns the length value in Femtometers (fm).
  double get inFm => getValue(LengthUnit.femtometer);

  /// Returns the length value in Inches (in).
  double get inInch => getValue(LengthUnit.inch);

  /// Returns the length value in Feet (ft).
  double get inFt => getValue(LengthUnit.foot);

  /// Returns the length value in Yards (yd).
  double get inYd => getValue(LengthUnit.yard);

  /// Returns the length value in Miles (mi).
  double get inMi => getValue(LengthUnit.mile);

  /// Returns the length value in Nautical Miles (nmi).
  double get inNmi => getValue(LengthUnit.nauticalMile);

  /// Returns the length value in Astronomical Units (AU).
  double get inAU => getValue(LengthUnit.astronomicalUnit);

  /// Returns the length value in Light Years (ly).
  double get inLy => getValue(LengthUnit.lightYear);

  /// Returns the length value in Parsecs (pc).
  double get inPc => getValue(LengthUnit.parsec);

  /// Returns the length value in √Öngstr√∂ms (√Ö).
  double get inAngstrom => getValue(LengthUnit.angstrom);

  /// Returns a Length representing this length in Meters (m).
  Length get asM => convertTo(LengthUnit.meter);

  /// Returns a Length representing this length in Kilometers (km).
  Length get asKm => convertTo(LengthUnit.kilometer);

  /// Returns a Length representing this length in Megameters (Mm).
  Length get asMegaM => convertTo(LengthUnit.megameter);

  /// Returns a Length representing this length in Gigameters (Gm).
  Length get asGigaM => convertTo(LengthUnit.gigameter);

  /// Returns a Length representing this length in Hectometers (hm).
  Length get asHm => convertTo(LengthUnit.hectometer);

  /// Returns a Length representing this length in Decameters (dam).
  Length get asDam => convertTo(LengthUnit.decameter);

  /// Returns a Length representing this length in Decimeters (dm).
  Length get asDm => convertTo(LengthUnit.decimeter);

  /// Returns a Length representing this length in Centimeters (cm).
  Length get asCm => convertTo(LengthUnit.centimeter);

  /// Returns a Length representing this length in Millimeters (mm).
  Length get asMm => convertTo(LengthUnit.millimeter);

  /// Returns a Length representing this length in Micrometers (Œºm).
  Length get asUm => convertTo(LengthUnit.micrometer);

  /// Returns a Length representing this length in Nanometers (nm).
  Length get asNm => convertTo(LengthUnit.nanometer);

  /// Returns a Length representing this length in Picometers (pm).
  Length get asPm => convertTo(LengthUnit.picometer);

  /// Returns a Length representing this length in Femtometers (fm).
  Length get asFm => convertTo(LengthUnit.femtometer);

  /// Returns a Length representing this length in Inches (in).
  Length get asInch => convertTo(LengthUnit.inch);

  /// Returns a Length representing this length in Feet (ft).
  Length get asFt => convertTo(LengthUnit.foot);

  /// Returns a Length representing this length in Yards (yd).
  Length get asYd => convertTo(LengthUnit.yard);

  /// Returns a Length representing this length in Miles (mi).
  Length get asMi => convertTo(LengthUnit.mile);

  /// Returns a Length representing this length in Nautical Miles (nmi).
  Length get asNmi => convertTo(LengthUnit.nauticalMile);

  /// Returns a Length representing this length in Astronomical Units (AU).
  Length get asAU => convertTo(LengthUnit.astronomicalUnit);

  /// Returns a Length representing this length in Light Years (ly).
  Length get asLy => convertTo(LengthUnit.lightYear);

  /// Returns a Length representing this length in Parsecs (pc).
  Length get asPc => convertTo(LengthUnit.parsec);

  /// Returns a Length representing this length in √Öngstr√∂ms (√Ö).
  Length get asAngstrom => convertTo(LengthUnit.angstrom);
}

/// Provides convenient factory methods for creating [Length] instances from [num]
/// using shortened unit names where appropriate.
extension LengthCreation on num {
  /// Creates a [Length] instance representing this numerical value in Meters (m).
  Length get m => Length(toDouble(), LengthUnit.meter);

  /// Creates a [Length] instance representing this numerical value in Kilometers (km).
  Length get km => Length(toDouble(), LengthUnit.kilometer);

  /// Creates a [Length] instance representing this numerical value in Megameters (Mm).
  Length get megaM => Length(toDouble(), LengthUnit.megameter);

  /// Creates a [Length] instance representing this numerical value in Gigameters (Gm).
  Length get gigaM => Length(toDouble(), LengthUnit.gigameter);

  /// Creates a [Length] instance representing this numerical value in Hectometers (hm).
  Length get hm => Length(toDouble(), LengthUnit.hectometer);

  /// Creates a [Length] instance representing this numerical value in Decameters (dam).
  Length get dam => Length(toDouble(), LengthUnit.decameter);

  /// Creates a [Length] instance representing this numerical value in Decimeters (dm).
  Length get dm => Length(toDouble(), LengthUnit.decimeter);

  /// Creates a [Length] instance representing this numerical value in Centimeters (cm).
  Length get cm => Length(toDouble(), LengthUnit.centimeter);

  /// Creates a [Length] instance representing this numerical value in Millimeters (mm).
  Length get mm => Length(toDouble(), LengthUnit.millimeter);

  /// Creates a [Length] instance representing this numerical value in Micrometers (Œºm).
  Length get um => Length(toDouble(), LengthUnit.micrometer);

  /// Creates a [Length] instance representing this numerical value in Nanometers (nm).
  Length get nm => Length(toDouble(), LengthUnit.nanometer);

  /// Creates a [Length] instance representing this numerical value in Picometers (pm).
  Length get pm => Length(toDouble(), LengthUnit.picometer);

  /// Creates a [Length] instance representing this numerical value in Femtometers (fm).
  Length get fm => Length(toDouble(), LengthUnit.femtometer);

  /// Creates a [Length] instance representing this numerical value in Inches (in).
  Length get inch => Length(toDouble(), LengthUnit.inch);

  /// Creates a [Length] instance representing this numerical value in Feet (ft).
  Length get ft => Length(toDouble(), LengthUnit.foot);

  /// Creates a [Length] instance representing this numerical value in Yards (yd).
  Length get yd => Length(toDouble(), LengthUnit.yard);

  /// Creates a [Length] instance representing this numerical value in Miles (mi).
  Length get mi => Length(toDouble(), LengthUnit.mile);

  /// Creates a [Length] instance representing this numerical value in Nautical Miles (nmi).
  Length get nmi => Length(toDouble(), LengthUnit.nauticalMile);

  /// Creates a [Length] instance representing this numerical value in Astronomical Units (AU).
  // ignore: non_constant_identifier_names
  Length get AU => Length(toDouble(), LengthUnit.astronomicalUnit);

  /// Creates a [Length] instance representing this numerical value in Light Years (ly).
  Length get ly => Length(toDouble(), LengthUnit.lightYear);

  /// Creates a [Length] instance representing this numerical value in Parsecs (pc).
  Length get pc => Length(toDouble(), LengthUnit.parsec);

  /// Creates a [Length] instance representing this numerical value in √Öngstr√∂ms (√Ö).
  Length get angstrom => Length(toDouble(), LengthUnit.angstrom);

  // Longer aliases (can be added or chosen over short forms)
  // Length get meters => Length(toDouble(), LengthUnit.meter);
  // Length get kilometers => Length(toDouble(), LengthUnit.kilometer);
  // Length get hectometers => Length(toDouble(), LengthUnit.hectometer);
  // Length get decameters => Length(toDouble(), LengthUnit.decameter);
  // Length get decimeters => Length(toDouble(), LengthUnit.decimeter);
  // Length get centimeters => Length(toDouble(), LengthUnit.centimeter);
  // Length get millimeters => Length(toDouble(), LengthUnit.millimeter);
  // Length get micrometers => Length(toDouble(), LengthUnit.micrometer);
  // Length get nanometers => Length(toDouble(), LengthUnit.nanometer);
  // Length get picometers => Length(toDouble(), LengthUnit.picometer);
  // Length get femtometers => Length(toDouble(), LengthUnit.femtometer);
  // Length get inches => Length(toDouble(), LengthUnit.inch);
  // Length get feet => Length(toDouble(), LengthUnit.foot);
  // Length get yards => Length(toDouble(), LengthUnit.yard);
  // Length get miles => Length(toDouble(), LengthUnit.mile);
  // Length get nauticalMiles => Length(toDouble(), LengthUnit.nauticalMile);
  // Length get astronomicalUnits => Length(toDouble(), LengthUnit.astronomicalUnit);
  // Length get lightYears => Length(toDouble(), LengthUnit.lightYear);
  // Length get parsecs => Length(toDouble(), LengthUnit.parsec);
  // Length get angstroms => Length(toDouble(), LengthUnit.angstrom);
}

<!-- END FILE: [v0.5.0] lib/src/units/length/length_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/length/length_factors.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

/// Defines base conversion factors for various length units relative to Meter.
///
/// These constants are based on international standards (e.g., NIST).
class LengthFactors {
  // The base unit for internal calculations is Meter.
  // Factors represent: 1 [Unit] = X [Meters]

  /// Meters per Kilometer: 1 kilometer = 1000.0 meters.
  static const double metersPerKilometer = 1000.0;

  /// Meters per Megameter: 1 megameter = 1e6 meters.
  static const double metersPerMegameter = 1e6;

  /// Meters per Gigameter: 1 gigameter = 1e9 meters.
  static const double metersPerGigameter = 1e9;

  /// Meters per Hectometer: 1 hectometer = 100.0 meters.
  static const double metersPerHectometer = 100.0;

  /// Meters per Decameter: 1 decameter = 10.0 meters.
  static const double metersPerDecameter = 10.0;

  /// Meters per Decimeter: 1 decimeter = 0.1 meters.
  static const double metersPerDecimeter = 0.1;

  /// Meters per Centimeter: 1 centimeter = 0.01 meters.
  static const double metersPerCentimeter = 0.01;

  /// Meters per Millimeter: 1 millimeter = 0.001 meters.
  static const double metersPerMillimeter = 0.001;

  /// Meters per Micrometer: 1 micrometer = 1e-6 meters.
  static const double metersPerMicrometer = 1e-6;

  /// Meters per Nanometer: 1 nanometer = 1e-9 meters.
  static const double metersPerNanometer = 1e-9;

  /// Meters per Picometer: 1 picometer = 1e-12 meters.
  static const double metersPerPicometer = 1e-12;

  /// Meters per Femtometer: 1 femtometer = 1e-15 meters.
  static const double metersPerFemtometer = 1e-15;

  /// Meters per Inch: 1 inch = 0.0254 meters (exact definition).
  static const double metersPerInch = 0.0254;

  /// Meters per Foot: 1 foot = 0.3048 meters (exact definition, as 1 foot = 12 inches).
  static const double metersPerFoot = 0.3048;

  /// Meters per Yard: 1 yard = 0.9144 meters (exact definition, as 1 yard = 3 feet).
  static const double metersPerYard = 0.9144;

  /// Meters per Mile: 1 mile = 1609.344 meters (exact definition, as 1 mile = 1760 yards).
  static const double metersPerMile = 1609.344;

  /// Meters per Nautical Mile: 1 nautical mile = 1852.0 meters (international definition).
  static const double metersPerNauticalMile = 1852.0;

  /// Meters per Astronomical Unit: 1 AU = 149597870700.0 meters (exact definition, IAU 2012).
  static const double metersPerAstronomicalUnit = 149597870700.0;

  /// Meters per Light Year: 1 light year = 9460730472580800.0 meters.
  /// Based on Julian year (365.25 days) and exact speed of light.
  static const double metersPerLightYear = 9460730472580800.0;

  /// Meters per Parsec: 1 parsec ‚âà 3.0856775814913673e16 meters.
  /// Derived from astronomical unit: 1 pc = 648000/œÄ AU.
  static const double metersPerParsec = 3.0856775814913673e16;

  /// Meters per √Öngstr√∂m: 1 √•ngstr√∂m = 1e-10 meters (exact definition).
  static const double metersPerAngstrom = 1e-10;
}

<!-- END FILE: [v0.5.0] lib/src/units/length/length_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/length/length_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'length_factors.dart';

/// Represents units of length.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each length unit.
/// All conversion factors are pre-calculated in the constructor relative to Meter.
enum LengthUnit implements Unit<LengthUnit> {
  /// Meter (m), the SI base unit of length.
  meter(1, 'm'),

  /// Kilometer (km), equal to 1000 meters.
  kilometer(LengthFactors.metersPerKilometer, 'km'),

  /// Megameter (Mm), equal to 1e6 meters.
  megameter(LengthFactors.metersPerMegameter, 'Mm'),

  /// Gigameter (Gm), equal to 1e9 meters.
  gigameter(LengthFactors.metersPerGigameter, 'Gm'),

  /// Hectometer (hm), equal to 100 meters.
  hectometer(LengthFactors.metersPerHectometer, 'hm'),

  /// Decameter (dam), equal to 10 meters.
  decameter(LengthFactors.metersPerDecameter, 'dam'),

  /// Decimeter (dm), equal to 0.1 meters.
  decimeter(LengthFactors.metersPerDecimeter, 'dm'),

  /// Centimeter (cm), equal to 0.01 meters.
  centimeter(LengthFactors.metersPerCentimeter, 'cm'),

  /// Millimeter (mm), equal to 0.001 meters.
  millimeter(LengthFactors.metersPerMillimeter, 'mm'),

  /// Micrometer (Œºm), equal to 1e-6 meters.
  micrometer(LengthFactors.metersPerMicrometer, 'Œºm'),

  /// Nanometer (nm), equal to 1e-9 meters.
  nanometer(LengthFactors.metersPerNanometer, 'nm'),

  /// Picometer (pm), equal to 1e-12 meters.
  picometer(LengthFactors.metersPerPicometer, 'pm'),

  /// Femtometer (fm), equal to 1e-15 meters.
  femtometer(LengthFactors.metersPerFemtometer, 'fm'),

  /// Inch (in), defined as exactly 0.0254 meters.
  inch(LengthFactors.metersPerInch, 'in'),

  /// Foot (ft), defined as exactly 0.3048 meters (12 inches).
  foot(LengthFactors.metersPerFoot, 'ft'),

  /// Yard (yd), defined as exactly 0.9144 meters (3 feet).
  yard(LengthFactors.metersPerYard, 'yd'),

  /// Mile (mi), defined as exactly 1609.344 meters (1760 yards).
  mile(LengthFactors.metersPerMile, 'mi'),

  /// Nautical Mile (nmi), internationally defined as 1852 meters.
  nauticalMile(LengthFactors.metersPerNauticalMile, 'nmi'),

  /// Astronomical Unit (AU), defined as exactly 149597870700 meters.
  astronomicalUnit(LengthFactors.metersPerAstronomicalUnit, 'AU'),

  /// Light Year (ly), the distance light travels in one Julian year.
  lightYear(LengthFactors.metersPerLightYear, 'ly'),

  /// Parsec (pc), approximately 3.26 light years.
  parsec(LengthFactors.metersPerParsec, 'pc'),

  /// √Öngstr√∂m (√Ö), equal to 1e-10 meters.
  angstrom(LengthFactors.metersPerAngstrom, '√Ö');

  /// Constant constructor for enum members.
  ///
  /// [toBaseFactor] is the factor to convert from this unit to the base unit (Meter).
  /// For Meter itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `LengthUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used.
  const LengthUnit(double toBaseFactor, this.symbol)
      : _toMeterFactor = toBaseFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToMeter = toBaseFactor / 1.0,
        _factorToKilometer = toBaseFactor / LengthFactors.metersPerKilometer,
        _factorToMegameter = toBaseFactor / LengthFactors.metersPerMegameter,
        _factorToGigameter = toBaseFactor / LengthFactors.metersPerGigameter,
        _factorToHectometer = toBaseFactor / LengthFactors.metersPerHectometer,
        _factorToDecameter = toBaseFactor / LengthFactors.metersPerDecameter,
        _factorToDecimeter = toBaseFactor / LengthFactors.metersPerDecimeter,
        _factorToCentimeter = toBaseFactor / LengthFactors.metersPerCentimeter,
        _factorToMillimeter = toBaseFactor / LengthFactors.metersPerMillimeter,
        _factorToMicrometer = toBaseFactor / LengthFactors.metersPerMicrometer,
        _factorToNanometer = toBaseFactor / LengthFactors.metersPerNanometer,
        _factorToPicometer = toBaseFactor / LengthFactors.metersPerPicometer,
        _factorToFemtometer = toBaseFactor / LengthFactors.metersPerFemtometer,
        _factorToInch = toBaseFactor / LengthFactors.metersPerInch,
        _factorToFoot = toBaseFactor / LengthFactors.metersPerFoot,
        _factorToYard = toBaseFactor / LengthFactors.metersPerYard,
        _factorToMile = toBaseFactor / LengthFactors.metersPerMile,
        _factorToNauticalMile = toBaseFactor / LengthFactors.metersPerNauticalMile,
        _factorToAstronomicalUnit = toBaseFactor / LengthFactors.metersPerAstronomicalUnit,
        _factorToLightYear = toBaseFactor / LengthFactors.metersPerLightYear,
        _factorToParsec = toBaseFactor / LengthFactors.metersPerParsec,
        _factorToAngstrom = toBaseFactor / LengthFactors.metersPerAngstrom;

  /// The factor to convert a value from this unit to the base unit (Meter).
  /// Example: For Kilometer, this is 1000.0 (meaning 1 km = 1000.0 m).
  // ignore: unused_field
  final double _toMeterFactor;

  /// The human-readable symbol for this length unit (e.g., "m", "km").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToMeter;
  final double _factorToKilometer;
  final double _factorToMegameter;
  final double _factorToGigameter;
  final double _factorToHectometer;
  final double _factorToDecameter;
  final double _factorToDecimeter;
  final double _factorToCentimeter;
  final double _factorToMillimeter;
  final double _factorToMicrometer;
  final double _factorToNanometer;
  final double _factorToPicometer;
  final double _factorToFemtometer;
  final double _factorToInch;
  final double _factorToFoot;
  final double _factorToYard;
  final double _factorToMile;
  final double _factorToNauticalMile;
  final double _factorToAstronomicalUnit;
  final double _factorToLightYear;
  final double _factorToParsec;
  final double _factorToAngstrom;

  /// Returns the direct conversion factor to convert a value from this [LengthUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(LengthUnit targetUnit) {
    switch (targetUnit) {
      case LengthUnit.meter:
        return _factorToMeter;
      case LengthUnit.kilometer:
        return _factorToKilometer;
      case LengthUnit.megameter:
        return _factorToMegameter;
      case LengthUnit.gigameter:
        return _factorToGigameter;

      case LengthUnit.hectometer:
        return _factorToHectometer;
      case LengthUnit.decameter:
        return _factorToDecameter;
      case LengthUnit.decimeter:
        return _factorToDecimeter;
      case LengthUnit.centimeter:
        return _factorToCentimeter;
      case LengthUnit.millimeter:
        return _factorToMillimeter;
      case LengthUnit.micrometer:
        return _factorToMicrometer;
      case LengthUnit.nanometer:
        return _factorToNanometer;
      case LengthUnit.picometer:
        return _factorToPicometer;
      case LengthUnit.femtometer:
        return _factorToFemtometer;
      case LengthUnit.inch:
        return _factorToInch;
      case LengthUnit.foot:
        return _factorToFoot;
      case LengthUnit.yard:
        return _factorToYard;
      case LengthUnit.mile:
        return _factorToMile;
      case LengthUnit.nauticalMile:
        return _factorToNauticalMile;
      case LengthUnit.astronomicalUnit:
        return _factorToAstronomicalUnit;
      case LengthUnit.lightYear:
        return _factorToLightYear;
      case LengthUnit.parsec:
        return _factorToParsec;
      case LengthUnit.angstrom:
        return _factorToAngstrom;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/length/length_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/luminous/luminous_intensity.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'luminous_intensity_unit.dart';

/// Represents a quantity of luminous intensity.
///
/// Luminous intensity is a measure of the wavelength-weighted power emitted
/// by a light source in a particular direction per unit solid angle, based on
/// the luminosity function, a standardized model of the sensitivity of the
/// human eye. The SI base unit for luminous intensity is the Candela (cd).
///
/// This class provides a type-safe way to handle luminous intensity values and
/// conversions between different units (e.g., candelas, millicandelas).
@immutable
class LuminousIntensity extends Quantity<LuminousIntensityUnit> {
  /// Creates a new `LuminousIntensity` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final ledBrightness = LuminousIntensity(150.0, LuminousIntensityUnit.millicandela);
  /// final headlightIntensity = LuminousIntensity(800.0, LuminousIntensityUnit.candela);
  /// ```
  const LuminousIntensity(super.value, super.unit);

  /// Converts this luminous intensity's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the
  /// `LuminousIntensityUnit` enum for efficiency.
  ///
  /// Example:
  /// ```dart
  /// final intensityInCd = LuminousIntensity(0.5, LuminousIntensityUnit.candela);
  /// final valueInMcd = intensityInCd.getValue(LuminousIntensityUnit.millicandela); // 500.0
  /// ```
  @override
  double getValue(LuminousIntensityUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [LuminousIntensity] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final intensityInMcd = LuminousIntensity(2500.0, LuminousIntensityUnit.millicandela);
  /// final intensityInCdObj = intensityInMcd.convertTo(LuminousIntensityUnit.candela);
  /// // intensityInCdObj is LuminousIntensity(2.5, LuminousIntensityUnit.candela)
  /// print(intensityInCdObj); // Output: "2.5 cd"
  /// ```
  @override
  LuminousIntensity convertTo(LuminousIntensityUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return LuminousIntensity(newValue, targetUnit);
  }

  /// Compares this [LuminousIntensity] object to another [Quantity<LuminousIntensityUnit>].
  ///
  /// Comparison is based on the physical magnitude of the luminous intensities.
  ///
  /// Example:
  /// ```dart
  /// final li1 = LuminousIntensity(1.0, LuminousIntensityUnit.candela);      // 1000 mcd
  /// final li2 = LuminousIntensity(1000.0, LuminousIntensityUnit.millicandela); // 1000 mcd
  /// final li3 = LuminousIntensity(0.5, LuminousIntensityUnit.candela);     // 500 mcd
  ///
  /// print(li1.compareTo(li2)); // 0 (equal magnitude)
  /// print(li1.compareTo(li3)); // 1 (li1 > li3)
  /// ```
  @override
  int compareTo(Quantity<LuminousIntensityUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this luminous intensity to another luminous intensity.
  ///
  /// This is physically meaningful if, for example, combining light from multiple
  /// sources in the same direction (though solid angle considerations can be complex).
  /// The [other] intensity is converted to the unit of this intensity before addition.
  ///
  /// Example:
  /// ```dart
  /// final sourceA = LuminousIntensity(100.0, LuminousIntensityUnit.candela);
  /// final sourceB = LuminousIntensity(50000.0, LuminousIntensityUnit.millicandela); // 50 cd
  /// final combinedIntensity = sourceA + sourceB; // Result: LuminousIntensity(150.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator +(LuminousIntensity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return LuminousIntensity(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another luminous intensity from this luminous intensity.
  ///
  /// This could represent the reduction in intensity if one source is removed or shielded.
  /// The [other] intensity is converted to the unit of this intensity before subtraction.
  ///
  /// Example:
  /// ```dart
  /// final totalLight = LuminousIntensity(500.0, LuminousIntensityUnit.candela);
  /// final blockedLight = LuminousIntensity(150.0, LuminousIntensityUnit.candela);
  /// final remainingLight = totalLight - blockedLight; // Result: LuminousIntensity(350.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator -(LuminousIntensity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return LuminousIntensity(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this luminous intensity by a scalar value (a dimensionless number).
  ///
  /// Example:
  /// ```dart
  /// final singleLed = LuminousIntensity(20.0, LuminousIntensityUnit.millicandela);
  /// final arrayBrightness = singleLed * 10.0; // Result: LuminousIntensity(200.0, LuminousIntensityUnit.millicandela)
  /// ```
  LuminousIntensity operator *(double scalar) {
    return LuminousIntensity(value * scalar, unit);
  }

  /// Divides this luminous intensity by a scalar value (a dimensionless number).
  ///
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalOutput = LuminousIntensity(1000.0, LuminousIntensityUnit.candela);
  /// final outputPerSegment = totalOutput / 5.0; // Result: LuminousIntensity(200.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return LuminousIntensity(value / scalar, unit);
  }

  // Potential future enhancements:
  // - LuminousIntensity * SolidAngle = LuminousFlux (would require SolidAngle type or representation)
  // - LuminousIntensity / Area = Luminance (would require Area type)
}

<!-- END FILE: [v0.5.0] lib/src/units/luminous/luminous_intensity.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/luminous/luminous_intensity_extensions.dart -->
import 'luminous_intensity.dart';
import 'luminous_intensity_unit.dart';

/// Provides convenient access to [LuminousIntensity] values in specific units
/// using getter properties.
extension LuminousIntensityValueGetters on LuminousIntensity {
  /// Returns the luminous intensity value in Candelas (cd).
  double get inCandelas => getValue(LuminousIntensityUnit.candela);

  /// Returns the luminous intensity value in Millicandelas (mcd).
  double get inMillicandelas => getValue(LuminousIntensityUnit.millicandela);

  /// Returns the luminous intensity value in Kilocandelas (kcd).
  double get inKilocandelas => getValue(LuminousIntensityUnit.kilocandela);

  // --- "As" Getters for new LuminousIntensity objects ---

  /// Returns a new [LuminousIntensity] object representing this intensity in Candelas (cd).
  LuminousIntensity get asCandelas => convertTo(LuminousIntensityUnit.candela);

  /// Returns a new [LuminousIntensity] object representing this intensity in Millicandelas (mcd).
  LuminousIntensity get asMillicandelas => convertTo(LuminousIntensityUnit.millicandela);

  /// Returns a new [LuminousIntensity] object representing this intensity in Kilocandelas (kcd).
  LuminousIntensity get asKilocandelas => convertTo(LuminousIntensityUnit.kilocandela);
}

/// Provides convenient factory methods for creating [LuminousIntensity] instances from [num]
/// using getter properties named after common unit symbols or names.
extension LuminousIntensityCreation on num {
  /// Creates a [LuminousIntensity] instance from this numerical value in Candelas (cd).
  LuminousIntensity get cd => LuminousIntensity(toDouble(), LuminousIntensityUnit.candela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Candelas (cd).
  /// Alias for `cd`.
  LuminousIntensity get candelas => LuminousIntensity(toDouble(), LuminousIntensityUnit.candela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Millicandelas (mcd).
  LuminousIntensity get mcd => LuminousIntensity(toDouble(), LuminousIntensityUnit.millicandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Millicandelas (mcd).
  /// Alias for `mcd`.
  LuminousIntensity get millicandelas =>
      LuminousIntensity(toDouble(), LuminousIntensityUnit.millicandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Kilocandelas (kcd).
  LuminousIntensity get kcd => LuminousIntensity(toDouble(), LuminousIntensityUnit.kilocandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Kilocandelas (kcd).
  /// Alias for `kcd`.
  LuminousIntensity get kilocandelas =>
      LuminousIntensity(toDouble(), LuminousIntensityUnit.kilocandela);
}

<!-- END FILE: [v0.5.0] lib/src/units/luminous/luminous_intensity_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/luminous/luminous_intensity_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various luminous intensity units relative
/// to the Candela (cd), which is the SI base unit for luminous intensity.
///
/// These constants represent: `1 [Unit] = Z [Candelas]`.
/// So, `candelasPerMillicandela` means `1 millicandela = candelasPerMillicandela candelas`.
class LuminousIntensityFactors {
  // --- SI Prefixed Units (relative to Candela) ---

  /// Candelas per Millicandela: 1 millicandela (mcd) = 0.001 candelas (cd).
  static const double candelasPerMillicandela = 0.001;

  /// Candelas per Kilocandela: 1 kilocandela (kcd) = 1000 candelas (cd).
  /// Note: Kilocandela is a valid SI unit but less commonly used in practice
  /// compared to candela or millicandela for typical light sources.
  static const double candelasPerKilocandela = 1000.0;

  // --- Other historical or specialized units (less common) ---
  // Example: Hefnerkerze (HK) or Hefner candle, an old German unit of luminous intensity.
  // 1 HK ‚âà 0.903 cd.
  // static const double candelasPerHefnerCandle = 0.903;

  // Example: Carcel, an old French unit.
  // 1 Carcel ‚âà 9.74 cd (varies by definition).
  // static const double candelasPerCarcel = 9.74;

  // For a primary SI base unit like Candela, prefixed versions are the most relevant.
  // Other units are typically for historical context or very specialized applications.
  // Focusing on SI prefixed units for the core implementation.
}

<!-- END FILE: [v0.5.0] lib/src/units/luminous/luminous_intensity_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/luminous/luminous_intensity_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'luminous_intensity_factors.dart';

/// Represents units for luminous intensity.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each luminous intensity unit.
/// All conversion factors are pre-calculated in the constructor relative to Candela (cd),
/// which is the SI base unit for luminous intensity.
enum LuminousIntensityUnit implements Unit<LuminousIntensityUnit> {
  /// Candela (cd), the SI base unit of luminous intensity.
  /// It is defined by taking the fixed numerical value of the luminous efficacy
  /// of monochromatic radiation of frequency 540 √ó 10¬π¬≤ Hz, Kcd, to be 683
  /// when expressed in the unit lm W‚Åª¬π, which is equal to cd sr W‚Åª¬π or
  /// cd sr kg‚Åª¬π m‚Åª¬≤ s¬≥.
  candela(1, 'cd'),

  /// Millicandela (mcd), equal to 0.001 candelas.
  /// Commonly used for LEDs and indicator lights.
  millicandela(LuminousIntensityFactors.candelasPerMillicandela, 'mcd'),

  /// Kilocandela (kcd), equal to 1000 candelas.
  /// A less common unit, might be used for very high-intensity light sources
  /// like searchlights or lighthouses.
  kilocandela(LuminousIntensityFactors.candelasPerKilocandela, 'kcd');

  // If Hefnerkerze were to be added:
  // /// Hefnerkerze (HK) or Hefner candle, an old German unit.
  // /// 1 HK ‚âà 0.903 cd.
  // hefnerCandle(LuminousIntensityFactors.candelasPerHefnerCandle, 'HK');

  /// Constant constructor for enum members.
  ///
  /// [_toCandelaFactor] is the factor to convert from this unit to the base unit (Candela).
  /// For Candela itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `LuminousIntensityUnit`.
  const LuminousIntensityUnit(double toCandelaFactor, this.symbol)
      : _toCandelaFactor = toCandelaFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToCandela = toCandelaFactor / 1.0, // Base unit factor for candela is 1.0
        _factorToMillicandela = toCandelaFactor / LuminousIntensityFactors.candelasPerMillicandela,
        _factorToKilocandela = toCandelaFactor / LuminousIntensityFactors.candelasPerKilocandela;
  // If hefnerCandle were added:
  // _factorToHefnerCandle = toCandelaFactor / LuminousIntensityFactors.candelasPerHefnerCandle;

  /// The factor to convert a value from this unit to the base unit (Candela).
  /// Example: For Millicandela, this is 0.001 (meaning 1 mcd = 0.001 cd).
  /// This field is primarily used internally by the constructor.
  // ignore: unused_field
  final double _toCandelaFactor;

  /// The human-readable symbol for this luminous intensity unit (e.g., "cd", "mcd").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToCandela;
  final double _factorToMillicandela;
  final double _factorToKilocandela;
  // If hefnerCandle were added:
  // final double _factorToHefnerCandle;

  /// Returns the direct conversion factor to convert a value from this [LuminousIntensityUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `LuminousIntensity`
  /// class for conversions.
  @override
  @internal
  double factorTo(LuminousIntensityUnit targetUnit) {
    switch (targetUnit) {
      case LuminousIntensityUnit.candela:
        return _factorToCandela;
      case LuminousIntensityUnit.millicandela:
        return _factorToMillicandela;
      case LuminousIntensityUnit.kilocandela:
        return _factorToKilocandela;
      // If hefnerCandle were added:
      // case LuminousIntensityUnit.hefnerCandle:
      //  return _factorToHefnerCandle;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/luminous/luminous_intensity_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/mass/mass.dart -->
// BEGIN FILE: lib/src/units/mass/mass.dart
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'mass_unit.dart';

/// Represents a quantity of mass.
///
/// Mass is a fundamental physical property of matter. It is a measure of an
/// object's resistance to acceleration (a change in its state of motion)
/// when a net force is applied. It also determines the strength of its
/// mutual gravitational attraction to other bodies. The SI base unit of mass
/// is the Kilogram (kg).
///
/// This class provides a type-safe way to handle mass values and conversions
/// between different units of mass (e.g., kilograms, grams, pounds, ounces).
@immutable
class Mass extends Quantity<MassUnit> {
  /// Creates a new `Mass` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final personWeightKg = Mass(70.0, MassUnit.kilogram);
  /// final sugarAmountGrams = Mass(500.0, MassUnit.gram);
  /// final packageWeightLbs = Mass(5.0, MassUnit.pound);
  /// ```
  const Mass(super.value, super.unit);

  /// Converts this mass's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `MassUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final weightInKg = Mass(1.0, MassUnit.kilogram);
  /// final weightInGramsValue = weightInKg.getValue(MassUnit.gram); // 1000.0
  ///
  /// final weightInLbs = Mass(2.20462, MassUnit.pound);
  /// final weightInKgValue = weightInLbs.getValue(MassUnit.kilogram); // approx 1.0
  /// ```
  @override
  double getValue(MassUnit targetUnit) {
    // If the target unit is the same as the current unit, no conversion is needed.
    if (targetUnit == unit) return value;
    // Otherwise, multiply by the direct conversion factor.
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Mass] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Mass` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final weightInGrams = Mass(1500.0, MassUnit.gram);
  /// final weightInKilogramsObj = weightInGrams.convertTo(MassUnit.kilogram);
  /// // weightInKilogramsObj is Mass(1.5, MassUnit.kilogram)
  /// print(weightInKilogramsObj); // Output: "1.5 kg" (depending on toString formatting)
  /// ```
  @override
  Mass convertTo(MassUnit targetUnit) {
    // If the target unit is the same, return this instance (immutable optimization).
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Mass(newValue, targetUnit);
  }

  /// Compares this [Mass] object to another [Quantity<MassUnit>].
  ///
  /// Comparison is based on the physical magnitude of the masses.
  /// For an accurate comparison, this mass's value is converted to the unit
  /// of the [other] mass before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this mass is less than [other].
  /// - Zero if this mass is equal in magnitude to [other].
  /// - A positive integer if this mass is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final m1 = Mass(1.0, MassUnit.kilogram);    // 1000 g
  /// final m2 = Mass(1000.0, MassUnit.gram);    // 1000 g
  /// final m3 = Mass(2.0, MassUnit.pound);     // approx 907.18 g
  ///
  /// print(m1.compareTo(m2)); // 0 (equal magnitude)
  /// print(m1.compareTo(m3)); // 1 (m1 > m3, since 1kg > 2lb)
  /// print(m3.compareTo(m1)); // -1 (m3 < m1)
  /// ```
  @override
  int compareTo(Quantity<MassUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison of their magnitudes.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this mass to another mass.
  ///
  /// The [other] mass is converted to the unit of this mass before addition.
  /// The result is a new [Mass] instance with the sum, expressed in the unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final item1 = Mass(1.5, MassUnit.kilogram);
  /// final item2 = Mass(500.0, MassUnit.gram); // 0.5 kg
  /// final totalMass = item1 + item2; // Result: Mass(2.0, MassUnit.kilogram)
  /// ```
  Mass operator +(Mass other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Mass(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another mass from this mass.
  ///
  /// The [other] mass is converted to the unit of this mass before subtraction.
  /// The result is a new [Mass] instance with the difference, expressed in the unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final containerWithContents = Mass(5.0, MassUnit.kilogram);
  /// final contents = Mass(1500.0, MassUnit.gram); // 1.5 kg
  /// final emptyContainer = containerWithContents - contents; // Result: Mass(3.5, MassUnit.kilogram)
  /// ```
  Mass operator -(Mass other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Mass(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this mass by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Mass] instance with the scaled value, in the original unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final singleItemMass = Mass(0.25, MassUnit.kilogram);
  /// final massOfFourItems = singleItemMass * 4.0; // Result: Mass(1.0, MassUnit.kilogram)
  /// ```
  Mass operator *(double scalar) {
    return Mass(value * scalar, unit);
  }

  /// Divides this mass by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Mass] instance with the scaled value, in the original unit of this mass.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalMass = Mass(10.0, MassUnit.kilogram);
  /// final massPerPortion = totalMass / 5.0; // Result: Mass(2.0, MassUnit.kilogram)
  /// ```
  Mass operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Mass(value / scalar, unit);
  }

  // Potential future enhancement:
  // Mass / Volume = Density (would require a Density quantity type)
  // Mass * Acceleration = Force (would require Force and Acceleration types)
}

<!-- END FILE: [v0.5.0] lib/src/units/mass/mass.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/mass/mass_extensions.dart -->
import 'mass.dart';
import 'mass_unit.dart';

/// Provides convenient access to [Mass] values in specific units
/// using getter properties.
///
/// These getters simplify retrieving the numerical value of a mass
/// in a desired unit without explicitly calling `getValue()`.
extension MassValueGetters on Mass {
  /// Returns the mass value in Kilograms (kg).
  double get inKilograms => getValue(MassUnit.kilogram);

  /// Returns the mass value in Hectograms (hg).
  double get inHectograms => getValue(MassUnit.hectogram);

  /// Returns the mass value in Decagrams (dag).
  double get inDecagrams => getValue(MassUnit.decagram);

  /// Returns the mass value in Grams (g).
  double get inGrams => getValue(MassUnit.gram);

  /// Returns the mass value in Decigrams (dg).
  double get inDecigrams => getValue(MassUnit.decigram);

  /// Returns the mass value in Centigrams (cg).
  double get inCentigrams => getValue(MassUnit.centigram);

  /// Returns the mass value in Milligrams (mg).
  double get inMilligrams => getValue(MassUnit.milligram);

  /// Returns the mass value in Micrograms (Œºg).
  double get inMicrograms => getValue(MassUnit.microgram);

  /// Returns the mass value in Nanograms (ng).
  double get inNanograms => getValue(MassUnit.nanogram);

  /// Returns the mass value in Megagrams (Mg).
  double get inMegaG => getValue(MassUnit.megagram);

  /// Returns the mass value in Gigagrams (Gg).
  double get inGigaG => getValue(MassUnit.gigagram);

  /// Returns the mass value in Tonnes (t, metric tons).
  double get inTonnes => getValue(MassUnit.tonne);

  /// Returns the mass value in Pounds (lb).
  double get inPounds => getValue(MassUnit.pound);

  /// Returns the mass value in Ounces (oz).
  double get inOunces => getValue(MassUnit.ounce);

  /// Returns the mass value in Stones (st).
  double get inStones => getValue(MassUnit.stone);

  /// Returns the mass value in Slugs (slug).
  double get inSlugs => getValue(MassUnit.slug);

  /// Returns the mass value in Short Tons (US).
  double get inShortTons => getValue(MassUnit.shortTon);

  /// Returns the mass value in Long Tons (UK).
  double get inLongTons => getValue(MassUnit.longTon);

  /// Returns the mass value in Atomic Mass Units (u).
  double get inAtomicMassUnits => getValue(MassUnit.atomicMassUnit);

  /// Returns the mass value in Carats (ct).
  double get inCarats => getValue(MassUnit.carat);

  // --- "As" Getters for new Mass objects ---

  /// Returns a new [Mass] object representing this mass in Kilograms (kg).
  Mass get asKilograms => convertTo(MassUnit.kilogram);

  /// Returns a new [Mass] object representing this mass in Hectograms (hg).
  Mass get asHectograms => convertTo(MassUnit.hectogram);

  /// Returns a new [Mass] object representing this mass in Decagrams (dag).
  Mass get asDecagrams => convertTo(MassUnit.decagram);

  /// Returns a new [Mass] object representing this mass in Grams (g).
  Mass get asGrams => convertTo(MassUnit.gram);

  /// Returns a new [Mass] object representing this mass in Decigrams (dg).
  Mass get asDecigrams => convertTo(MassUnit.decigram);

  /// Returns a new [Mass] object representing this mass in Centigrams (cg).
  Mass get asCentigrams => convertTo(MassUnit.centigram);

  /// Returns a new [Mass] object representing this mass in Milligrams (mg).
  Mass get asMilligrams => convertTo(MassUnit.milligram);

  /// Returns a new [Mass] object representing this mass in Micrograms (Œºg).
  Mass get asMicrograms => convertTo(MassUnit.microgram);

  /// Returns a new [Mass] object representing this mass in Nanograms (ng).
  Mass get asNanograms => convertTo(MassUnit.nanogram);

  /// Returns a new [Mass] object representing this mass in Megagrams (Mg).
  Mass get asMegaG => convertTo(MassUnit.megagram);

  /// Returns a new [Mass] object representing this mass in Gigagrams (Gg).
  Mass get asGigaG => convertTo(MassUnit.gigagram);

  /// Returns a new [Mass] object representing this mass in Tonnes (t).
  Mass get asTonnes => convertTo(MassUnit.tonne);

  /// Returns a new [Mass] object representing this mass in Pounds (lb).
  Mass get asPounds => convertTo(MassUnit.pound);

  /// Returns a new [Mass] object representing this mass in Ounces (oz).
  Mass get asOunces => convertTo(MassUnit.ounce);

  /// Returns a new [Mass] object representing this mass in Stones (st).
  Mass get asStones => convertTo(MassUnit.stone);

  /// Returns a new [Mass] object representing this mass in Slugs (slug).
  Mass get asSlugs => convertTo(MassUnit.slug);

  /// Returns a new [Mass] object representing this mass in Short Tons (US).
  Mass get asShortTons => convertTo(MassUnit.shortTon);

  /// Returns a new [Mass] object representing this mass in Long Tons (UK).
  Mass get asLongTons => convertTo(MassUnit.longTon);

  /// Returns a new [Mass] object representing this mass in Atomic Mass Units (u).
  Mass get asAtomicMassUnits => convertTo(MassUnit.atomicMassUnit);

  /// Returns a new [Mass] object representing this mass in Carats (ct).
  Mass get asCarats => convertTo(MassUnit.carat);
}

/// Provides convenient factory methods for creating [Mass] instances from [num]
/// using getter properties named after common unit symbols or names.
///
/// This allows for an intuitive and concise way to create mass quantities,
/// for example: `70.kg` or `500.grams`.
extension MassCreation on num {
  /// Creates a [Mass] instance representing this numerical value in Kilograms (kg).
  Mass get kg => Mass(toDouble(), MassUnit.kilogram);

  /// Creates a [Mass] instance representing this numerical value in Hectograms (hg).
  Mass get hg => Mass(toDouble(), MassUnit.hectogram);

  /// Creates a [Mass] instance representing this numerical value in Decagrams (dag).
  Mass get dag => Mass(toDouble(), MassUnit.decagram);

  /// Creates a [Mass] instance representing this numerical value in Grams (g).
  Mass get g => Mass(toDouble(), MassUnit.gram);

  /// Creates a [Mass] instance representing this numerical value in Grams (g).
  /// Alias for `g`.
  Mass get grams => Mass(toDouble(), MassUnit.gram);

  /// Creates a [Mass] instance representing this numerical value in Decigrams (dg).
  Mass get dg => Mass(toDouble(), MassUnit.decigram);

  /// Creates a [Mass] instance representing this numerical value in Centigrams (cg).
  Mass get cg => Mass(toDouble(), MassUnit.centigram);

  /// Creates a [Mass] instance representing this numerical value in Milligrams (mg).
  Mass get mg => Mass(toDouble(), MassUnit.milligram);

  /// Creates a [Mass] instance representing this numerical value in Milligrams (mg).
  /// Alias for `mg`.
  Mass get milligrams => Mass(toDouble(), MassUnit.milligram);

  /// Creates a [Mass] instance representing this numerical value in Micrograms (Œºg).
  Mass get ug => Mass(toDouble(), MassUnit.microgram);

  /// Creates a [Mass] instance representing this numerical value in Micrograms (Œºg).
  /// Alias for `ug`.
  Mass get micrograms => Mass(toDouble(), MassUnit.microgram);

  /// Creates a [Mass] instance representing this numerical value in Nanograms (ng).
  Mass get ng => Mass(toDouble(), MassUnit.nanogram);

  /// Creates a [Mass] instance representing this numerical value in Nanograms (ng).
  /// Alias for `ng`.
  Mass get nanograms => Mass(toDouble(), MassUnit.nanogram);

  /// Creates a [Mass] instance representing this numerical value in Megagrams (Mg).
  Mass get megaG => Mass(toDouble(), MassUnit.megagram);

  /// Creates a [Mass] instance representing this numerical value in Gigagrams (Gg).
  Mass get gigaG => Mass(toDouble(), MassUnit.gigagram);

  /// Creates a [Mass] instance representing this numerical value in Tonnes (t, metric tons).
  Mass get t => Mass(toDouble(), MassUnit.tonne);

  /// Creates a [Mass] instance representing this numerical value in Tonnes (t, metric tons).
  /// Alias for `t`.
  Mass get tonnes => Mass(toDouble(), MassUnit.tonne);

  /// Creates a [Mass] instance representing this numerical value in Pounds (lb).
  Mass get lb => Mass(toDouble(), MassUnit.pound);

  /// Creates a [Mass] instance representing this numerical value in Pounds (lb).
  /// Alias for `lb`.
  Mass get pounds => Mass(toDouble(), MassUnit.pound);

  /// Creates a [Mass] instance representing this numerical value in Ounces (oz).
  Mass get oz => Mass(toDouble(), MassUnit.ounce);

  /// Creates a [Mass] instance representing this numerical value in Ounces (oz).
  /// Alias for `oz`.
  Mass get ounces => Mass(toDouble(), MassUnit.ounce);

  /// Creates a [Mass] instance representing this numerical value in Stones (st).
  Mass get st => Mass(toDouble(), MassUnit.stone);

  /// Creates a [Mass] instance representing this numerical value in Stones (st).
  /// Alias for `st`.
  Mass get stones => Mass(toDouble(), MassUnit.stone);

  /// Creates a [Mass] instance representing this numerical value in Slugs (slug).
  Mass get slugs => Mass(toDouble(), MassUnit.slug);

  /// Creates a [Mass] instance representing this numerical value in Short Tons (US).
  Mass get shortTons => Mass(toDouble(), MassUnit.shortTon);

  /// Creates a [Mass] instance representing this numerical value in Long Tons (UK).
  Mass get longTons => Mass(toDouble(), MassUnit.longTon);

  /// Creates a [Mass] instance representing this numerical value in Atomic Mass Units (u).
  Mass get u => Mass(toDouble(), MassUnit.atomicMassUnit);

  /// Creates a [Mass] instance representing this numerical value in Atomic Mass Units (u).
  /// Alias for `u`.
  Mass get atomicMassUnits => Mass(toDouble(), MassUnit.atomicMassUnit);

  /// Creates a [Mass] instance representing this numerical value in Carats (ct).
  Mass get ct => Mass(toDouble(), MassUnit.carat);

  /// Creates a [Mass] instance representing this numerical value in Carats (ct).
  /// Alias for `ct`.
  Mass get carats => Mass(toDouble(), MassUnit.carat);
}

<!-- END FILE: [v0.5.0] lib/src/units/mass/mass_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/mass/mass_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

import '../../../quantify.dart' show Unit;
import '../../core/unit.dart' show Unit;

/// Defines base conversion factors for various mass units relative to the Kilogram (kg),
/// which is the SI base unit for mass.
///
/// These constants are based on international standards and exact definitions where available
/// (e.g., the international avoirdupois pound).
///
/// The structure `X_per_Y` means "how many X are in one Y".
/// However, for consistency with how factors are used (1 [Unit] = X BaseUnit),
/// these constants represent: `1 [Unit] = Z [Kilograms]`.
/// So, `kilogramsPerGram` means `1 gram = kilogramsPerGram kilograms`.
class MassFactors {
  // --- SI Units (relative to Kilogram) ---

  /// Kilograms per Hectogram: 1 hectogram = 0.1 kilograms.
  static const double kilogramsPerHectogram = 0.1;

  /// Kilograms per Decagram: 1 decagram = 0.01 kilograms.
  static const double kilogramsPerDecagram = 0.01;

  /// Kilograms per Gram: 1 gram = 0.001 kilograms.
  static const double kilogramsPerGram = 0.001;

  /// Kilograms per Decigram: 1 decigram = 0.0001 kilograms.
  static const double kilogramsPerDecigram = 0.0001;

  /// Kilograms per Centigram: 1 centigram = 0.00001 kilograms.
  static const double kilogramsPerCentigram = 0.00001;

  /// Kilograms per Milligram: 1 milligram = 0.000001 kilograms.
  /// (1 mg = 0.001 g, and 1 g = 0.001 kg)
  static const double kilogramsPerMilligram = kilogramsPerGram * 0.001;

  /// Kilograms per Microgram: 1 microgram = 1e-9 kilograms.
  static const double kilogramsPerMicrogram = 1e-9;

  /// Kilograms per Nanogram: 1 nanogram = 1e-12 kilograms.
  static const double kilogramsPerNanogram = 1e-12;

  /// Kilograms per Megagram: 1 megagram = 1000 kilograms (equivalent to 1 tonne).
  static const double kilogramsPerMegagram = 1000.0;

  /// Kilograms per Gigagram: 1 gigagram = 1e6 kilograms.
  static const double kilogramsPerGigagram = 1e6;

  /// Kilograms per Tonne (Metric Ton): 1 tonne = 1000 kilograms.
  static const double kilogramsPerTonne = 1000.0;

  // --- Imperial / US Customary Units (relative to Kilogram) ---

  /// Kilograms per Pound (Avoirdupois): 1 pound = 0.45359237 kilograms.
  /// This is an exact definition based on the international pound and yard agreement of 1959.
  static const double kilogramsPerPound = 0.45359237;

  /// Kilograms per Ounce (Avoirdupois): 1 ounce = 1/16 pound.
  /// 1 ounce = (0.45359237 / 16) kilograms.
  static const double kilogramsPerOunce = kilogramsPerPound / 16.0;

  /// Kilograms per Stone: 1 stone = 14 pounds.
  /// 1 stone = (14 * 0.45359237) kilograms.
  static const double kilogramsPerStone = kilogramsPerPound * 14.0;

  /// Kilograms per Slug: 1 slug ‚âà 14.5939029372 kilograms.
  /// The slug is a unit of mass in the gravitational systems of units,
  /// defined as the mass that accelerates by 1 ft/s¬≤ when a force of one pound-force (lbf)
  /// is exerted on it.
  /// 1 slug = 1 lbf‚ãÖs¬≤/ft.
  /// Using g‚ÇÄ = 9.80665 m/s¬≤ (standard gravity) and 1 ft = 0.3048 m:
  /// 1 lbf = 0.45359237 kg * 9.80665 m/s¬≤ (force)
  /// 1 slug = (0.45359237 * 9.80665) / 0.3048 kg (approx, if derived from lbf definition relative to kg-mass and g0)
  /// A more commonly cited direct conversion factor for slug to kg is used here.
  /// For example, NIST Special Publication 811 (2008 edition), Appendix B.8, lists:
  /// slug -> 1.459 390 E+01 kg
  static const double kilogramsPerSlug = 14.5939029372;

  /// Kilograms per Short Ton (US): 1 short ton = 2000 pounds.
  /// 1 short ton = (2000 * 0.45359237) kilograms = 907.18474 kg.
  static const double kilogramsPerShortTon = kilogramsPerPound * 2000.0;

  /// Kilograms per Long Ton (UK): 1 long ton = 2240 pounds.
  /// 1 long ton = (2240 * 0.45359237) kilograms = 1016.0469088 kg.
  static const double kilogramsPerLongTon = kilogramsPerPound * 2240.0;

  // --- Special Units ---

  /// Kilograms per Atomic Mass Unit: 1 u ‚âà 1.66053906660e-27 kilograms.
  /// Based on 2018 CODATA recommended value.
  static const double kilogramsPerAtomicMassUnit = 1.66053906660e-27;

  /// Kilograms per Carat: 1 carat = 0.0002 kilograms (exact).
  /// The metric carat is defined as exactly 200 milligrams.
  static const double kilogramsPerCarat = 0.0002;

  // --- Other potential units (can be added if needed) ---
  // Example: Troy ounce (for precious metals)
  // /// Kilograms per Troy Ounce: 1 troy ounce ‚âà 0.0311034768 kilograms.
  // static const double kilogramsPerTroyOunce = 0.0311034768;
}

<!-- END FILE: [v0.5.0] lib/src/units/mass/mass_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/mass/mass_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'mass_factors.dart';

/// Represents units of mass.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each mass unit.
/// All conversion factors are pre-calculated in the constructor relative to Kilogram (kg),
/// which is the SI base unit for mass.
enum MassUnit implements Unit<MassUnit> {
  /// Kilogram (kg), the SI base unit of mass.
  kilogram(1, 'kg'),

  /// Hectogram (hg), equal to 0.1 kilograms.
  hectogram(MassFactors.kilogramsPerHectogram, 'hg'),

  /// Decagram (dag), equal to 0.01 kilograms.
  decagram(MassFactors.kilogramsPerDecagram, 'dag'),

  /// Gram (g), equal to 0.001 kilograms.
  gram(MassFactors.kilogramsPerGram, 'g'),

  /// Decigram (dg), equal to 0.0001 kilograms.
  decigram(MassFactors.kilogramsPerDecigram, 'dg'),

  /// Centigram (cg), equal to 0.00001 kilograms.
  centigram(MassFactors.kilogramsPerCentigram, 'cg'),

  /// Milligram (mg), equal to 0.000001 kilograms (or 0.001 grams).
  milligram(MassFactors.kilogramsPerMilligram, 'mg'),

  /// Microgram (Œºg), equal to 1e-9 kilograms.
  microgram(MassFactors.kilogramsPerMicrogram, 'Œºg'),

  /// Nanogram (ng), equal to 1e-12 kilograms.
  nanogram(MassFactors.kilogramsPerNanogram, 'ng'),

  /// Megagram (Mg), equal to 1000 kilograms. It is equivalent to a metric ton (tonne).
  megagram(MassFactors.kilogramsPerMegagram, 'Mg'),

  /// Gigagram (Gg), equal to 1e6 kilograms.
  gigagram(MassFactors.kilogramsPerGigagram, 'Gg'),

  /// Tonne (metric ton) (t), equal to 1000 kilograms.
  tonne(MassFactors.kilogramsPerTonne, 't'),

  /// Pound (lb), an avoirdupois pound, defined as exactly 0.45359237 kilograms.
  pound(MassFactors.kilogramsPerPound, 'lb'),

  /// Ounce (oz), an avoirdupois ounce, defined as 1/16 of an avoirdupois pound.
  ounce(MassFactors.kilogramsPerOunce, 'oz'),

  /// Stone (st), a unit of weight in the imperial system, equal to 14 pounds.
  stone(MassFactors.kilogramsPerStone, 'st'),

  /// Slug, a unit of mass in the British Imperial and US customary systems,
  /// defined as the mass that accelerates by 1 ft/s¬≤ when a force of one pound-force (lbf) is exerted on it.
  /// 1 slug ‚âà 14.59390 kilograms.
  slug(MassFactors.kilogramsPerSlug, 'slug'),

  /// Short Ton (US), equal to 2000 pounds or approximately 907.18474 kilograms.
  shortTon(MassFactors.kilogramsPerShortTon, 'short ton'),

  /// Long Ton (UK), equal to 2240 pounds or approximately 1016.0469088 kilograms.
  longTon(MassFactors.kilogramsPerLongTon, 'long ton'),

  /// Atomic Mass Unit (u), approximately 1.66053906660e-27 kilograms.
  /// Used for expressing atomic and molecular masses.
  atomicMassUnit(MassFactors.kilogramsPerAtomicMassUnit, 'u'),

  /// Carat (ct), equal to exactly 0.0002 kilograms (200 milligrams).
  /// Used for measuring the mass of gemstones and pearls.
  carat(MassFactors.kilogramsPerCarat, 'ct');

  /// Constant constructor for enum members.
  ///
  /// [_toKilogramFactor] is the factor to convert from this unit to the base unit (Kilogram).
  /// For Kilogram itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `MassUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used,
  /// where the base unit is Kilogram.
  const MassUnit(double toKilogramFactor, this.symbol)
      : _toKilogramFactor = toKilogramFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToKilogram = toKilogramFactor / 1.0, // Base unit factor for kilogram is 1.0
        _factorToHectogram = toKilogramFactor / MassFactors.kilogramsPerHectogram,
        _factorToDecagram = toKilogramFactor / MassFactors.kilogramsPerDecagram,
        _factorToGram = toKilogramFactor / MassFactors.kilogramsPerGram,
        _factorToDecigram = toKilogramFactor / MassFactors.kilogramsPerDecigram,
        _factorToCentigram = toKilogramFactor / MassFactors.kilogramsPerCentigram,
        _factorToMilligram = toKilogramFactor / MassFactors.kilogramsPerMilligram,
        _factorToMicrogram = toKilogramFactor / MassFactors.kilogramsPerMicrogram,
        _factorToNanogram = toKilogramFactor / MassFactors.kilogramsPerNanogram,
        _factorToMegagram = toKilogramFactor / MassFactors.kilogramsPerMegagram,
        _factorToGigagram = toKilogramFactor / MassFactors.kilogramsPerGigagram,
        _factorToTonne = toKilogramFactor / MassFactors.kilogramsPerTonne,
        _factorToPound = toKilogramFactor / MassFactors.kilogramsPerPound,
        _factorToOunce = toKilogramFactor / MassFactors.kilogramsPerOunce,
        _factorToStone = toKilogramFactor / MassFactors.kilogramsPerStone,
        _factorToSlug = toKilogramFactor / MassFactors.kilogramsPerSlug,
        _factorToShortTon = toKilogramFactor / MassFactors.kilogramsPerShortTon,
        _factorToLongTon = toKilogramFactor / MassFactors.kilogramsPerLongTon,
        _factorToAtomicMassUnit = toKilogramFactor / MassFactors.kilogramsPerAtomicMassUnit,
        _factorToCarat = toKilogramFactor / MassFactors.kilogramsPerCarat;

  /// The factor to convert a value from this unit to the base unit (Kilogram).
  /// Example: For Gram, this is 0.001 (meaning 1 g = 0.001 kg).
  // ignore: unused_field
  final double _toKilogramFactor;

  /// The human-readable symbol for this mass unit (e.g., "kg", "g", "lb").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToKilogram;
  final double _factorToHectogram;
  final double _factorToDecagram;
  final double _factorToGram;
  final double _factorToDecigram;
  final double _factorToCentigram;
  final double _factorToMilligram;
  final double _factorToMicrogram;
  final double _factorToNanogram;
  final double _factorToMegagram;
  final double _factorToGigagram;
  final double _factorToTonne;
  final double _factorToPound;
  final double _factorToOunce;
  final double _factorToStone;
  final double _factorToSlug;
  final double _factorToShortTon;
  final double _factorToLongTon;
  final double _factorToAtomicMassUnit;
  final double _factorToCarat;

  /// Returns the direct conversion factor to convert a value from this [MassUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `Mass`
  /// class for conversions.
  @override
  @internal
  double factorTo(MassUnit targetUnit) {
    switch (targetUnit) {
      case MassUnit.kilogram:
        return _factorToKilogram;
      case MassUnit.hectogram:
        return _factorToHectogram;
      case MassUnit.decagram:
        return _factorToDecagram;
      case MassUnit.gram:
        return _factorToGram;
      case MassUnit.decigram:
        return _factorToDecigram;
      case MassUnit.centigram:
        return _factorToCentigram;
      case MassUnit.milligram:
        return _factorToMilligram;
      case MassUnit.microgram:
        return _factorToMicrogram;
      case MassUnit.nanogram:
        return _factorToNanogram;
      case MassUnit.megagram:
        return _factorToMegagram;
      case MassUnit.gigagram:
        return _factorToGigagram;
      case MassUnit.tonne:
        return _factorToTonne;
      case MassUnit.pound:
        return _factorToPound;
      case MassUnit.ounce:
        return _factorToOunce;
      case MassUnit.stone:
        return _factorToStone;
      case MassUnit.slug:
        return _factorToSlug;
      case MassUnit.shortTon:
        return _factorToShortTon;
      case MassUnit.longTon:
        return _factorToLongTon;
      case MassUnit.atomicMassUnit:
        return _factorToAtomicMassUnit;
      case MassUnit.carat:
        return _factorToCarat;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/mass/mass_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/molar/molar_amount.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'molar_unit.dart';

/// Represents a quantity of amount of substance, typically measured in moles.
///
/// The amount of substance is a measure of the number of elementary entities
/// (such as atoms, molecules, ions, or electrons) in a sample. The SI base unit
/// for amount of substance is the Mole (mol).
///
/// This class provides a type-safe way to handle molar amount values and
/// conversions between different units (e.g., moles, millimoles, kilomoles).
/// It is fundamental in chemistry and related fields.
@immutable
class MolarAmount extends Quantity<MolarUnit> {
  /// Creates a new `MolarAmount` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final glucoseSample = MolarAmount(0.5, MolarUnit.mole);
  /// final reagentAmount = MolarAmount(25.0, MolarUnit.millimole);
  /// ```
  const MolarAmount(super.value, super.unit);

  /// Converts this molar amount's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `MolarUnit`
  /// enum for efficiency, involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final substanceInMoles = MolarAmount(0.05, MolarUnit.mole);
  /// final valueInMillimoles = substanceInMoles.getValue(MolarUnit.millimole); // 50.0
  /// ```
  @override
  double getValue(MolarUnit targetUnit) {
    // If the target unit is the same as the current unit, no conversion is needed.
    if (targetUnit == unit) return value;
    // Otherwise, multiply by the direct conversion factor.
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [MolarAmount] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `MolarAmount` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final amountInMillimoles = MolarAmount(1500.0, MolarUnit.millimole);
  /// final amountInMolesObj = amountInMillimoles.convertTo(MolarUnit.mole);
  /// // amountInMolesObj is MolarAmount(1.5, MolarUnit.mole)
  /// print(amountInMolesObj); // Output: "1.5 mol" (depending on toString formatting)
  /// ```
  @override
  MolarAmount convertTo(MolarUnit targetUnit) {
    // If the target unit is the same, return this instance (immutable optimization).
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return MolarAmount(newValue, targetUnit);
  }

  /// Compares this [MolarAmount] object to another [Quantity<MolarUnit>].
  ///
  /// Comparison is based on the physical magnitude of the amounts of substance.
  /// For an accurate comparison, this molar amount's value is converted to the unit
  /// of the [other] molar amount before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this molar amount is less than [other].
  /// - Zero if this molar amount is equal in magnitude to [other].
  /// - A positive integer if this molar amount is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final ma1 = MolarAmount(1.0, MolarUnit.mole);      // 1000 mmol
  /// final ma2 = MolarAmount(1000.0, MolarUnit.millimole); // 1000 mmol
  /// final ma3 = MolarAmount(0.5, MolarUnit.mole);     // 500 mmol
  ///
  /// print(ma1.compareTo(ma2)); // 0 (equal magnitude)
  /// print(ma1.compareTo(ma3)); // 1 (ma1 > ma3)
  /// print(ma3.compareTo(ma1)); // -1 (ma3 < ma1)
  /// ```
  @override
  int compareTo(Quantity<MolarUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison of their magnitudes.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this molar amount to another molar amount.
  ///
  /// The [other] molar amount is converted to the unit of this molar amount before addition.
  /// The result is a new [MolarAmount] instance with the sum, expressed in the unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final reagentA = MolarAmount(0.2, MolarUnit.mole);
  /// final reagentB = MolarAmount(150.0, MolarUnit.millimole); // 0.15 mol
  /// final totalAmount = reagentA + reagentB; // Result: MolarAmount(0.35, MolarUnit.mole)
  /// ```
  MolarAmount operator +(MolarAmount other) {
    final otherValueInThisUnit = other.getValue(unit);
    return MolarAmount(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another molar amount from this molar amount.
  ///
  /// The [other] molar amount is converted to the unit of this molar amount before subtraction.
  /// The result is a new [MolarAmount] instance with the difference, expressed in the unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final initialAmount = MolarAmount(1.0, MolarUnit.mole);
  /// final amountUsed = MolarAmount(250.0, MolarUnit.millimole); // 0.25 mol
  /// final remainingAmount = initialAmount - amountUsed; // Result: MolarAmount(0.75, MolarUnit.mole)
  /// ```
  MolarAmount operator -(MolarAmount other) {
    final otherValueInThisUnit = other.getValue(unit);
    return MolarAmount(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this molar amount by a scalar value (a dimensionless number).
  ///
  /// Returns a new [MolarAmount] instance with the scaled value, in the original unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final singleReactionAmount = MolarAmount(0.05, MolarUnit.mole);
  /// final amountForTenReactions = singleReactionAmount * 10.0; // Result: MolarAmount(0.5, MolarUnit.mole)
  /// ```
  MolarAmount operator *(double scalar) {
    return MolarAmount(value * scalar, unit);
  }

  /// Divides this molar amount by a scalar value (a dimensionless number).
  ///
  /// Returns a new [MolarAmount] instance with the scaled value, in the original unit of this molar amount.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalStock = MolarAmount(2.0, MolarUnit.mole);
  /// final amountPerAliquot = totalStock / 20.0; // Result: MolarAmount(0.1, MolarUnit.mole)
  /// ```
  MolarAmount operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return MolarAmount(value / scalar, unit);
  }

  // Potential future enhancements for MolarAmount:
  // - MolarAmount / Volume = MolarConcentration (would require Volume and MolarConcentration types)
  // - Mass / MolarAmount = MolarMass (would require Mass and MolarMass types or a way to handle compound units)
}

<!-- END FILE: [v0.5.0] lib/src/units/molar/molar_amount.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/molar/molar_extensions.dart -->
import 'molar_amount.dart';
import 'molar_unit.dart';

/// Provides convenient access to [MolarAmount] values in specific units
/// using getter properties.
///
/// These getters simplify retrieving the numerical value of a molar amount
/// in a desired unit without explicitly calling `getValue()`.
extension MolarAmountValueGetters on MolarAmount {
  /// Returns the molar amount value in Moles (mol).
  double get inMoles => getValue(MolarUnit.mole);

  /// Returns the molar amount value in Millimoles (mmol).
  double get inMillimoles => getValue(MolarUnit.millimole);

  /// Returns the molar amount value in Micromoles (¬µmol).
  double get inMicromoles => getValue(MolarUnit.micromole);

  /// Returns the molar amount value in Nanomoles (nmol).
  double get inNanomoles => getValue(MolarUnit.nanomole);

  /// Returns the molar amount value in Picomoles (pmol).
  double get inPicomoles => getValue(MolarUnit.picomole);

  /// Returns the molar amount value in Kilomoles (kmol).
  double get inKilomoles => getValue(MolarUnit.kilomole);

  // --- "As" Getters for new MolarAmount objects ---

  /// Returns a new [MolarAmount] object representing this amount in Moles (mol).
  MolarAmount get asMoles => convertTo(MolarUnit.mole);

  /// Returns a new [MolarAmount] object representing this amount in Millimoles (mmol).
  MolarAmount get asMillimoles => convertTo(MolarUnit.millimole);

  /// Returns a new [MolarAmount] object representing this amount in Micromoles (¬µmol).
  MolarAmount get asMicromoles => convertTo(MolarUnit.micromole);

  /// Returns a new [MolarAmount] object representing this amount in Nanomoles (nmol).
  MolarAmount get asNanomoles => convertTo(MolarUnit.nanomole);

  /// Returns a new [MolarAmount] object representing this amount in Picomoles (pmol).
  MolarAmount get asPicomoles => convertTo(MolarUnit.picomole);

  /// Returns a new [MolarAmount] object representing this amount in Kilomoles (kmol).
  MolarAmount get asKilomoles => convertTo(MolarUnit.kilomole);
}

/// Provides convenient factory methods for creating [MolarAmount] instances from [num]
/// using getter properties named after common unit symbols or names.
///
/// This allows for an intuitive and concise way to create molar amount quantities,
/// for example: `0.5.mol` or `25.millimoles`.
extension MolarAmountCreation on num {
  /// Creates a [MolarAmount] instance representing this numerical value in Moles (mol).
  MolarAmount get mol => MolarAmount(toDouble(), MolarUnit.mole);

  /// Creates a [MolarAmount] instance representing this numerical value in Moles (mol).
  /// Alias for `mol`.
  MolarAmount get moles => MolarAmount(toDouble(), MolarUnit.mole);

  /// Creates a [MolarAmount] instance representing this numerical value in Millimoles (mmol).
  MolarAmount get mmol => MolarAmount(toDouble(), MolarUnit.millimole);

  /// Creates a [MolarAmount] instance representing this numerical value in Millimoles (mmol).
  /// Alias for `mmol`.
  MolarAmount get millimoles => MolarAmount(toDouble(), MolarUnit.millimole);

  /// Creates a [MolarAmount] instance representing this numerical value in Micromoles (¬µmol).
  MolarAmount get umol => MolarAmount(toDouble(), MolarUnit.micromole); // Using 'u' for micro

  /// Creates a [MolarAmount] instance representing this numerical value in Micromoles (¬µmol).
  /// Alias for `umol`.
  MolarAmount get micromoles => MolarAmount(toDouble(), MolarUnit.micromole);

  /// Creates a [MolarAmount] instance representing this numerical value in Nanomoles (nmol).
  MolarAmount get nmol => MolarAmount(toDouble(), MolarUnit.nanomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Nanomoles (nmol).
  /// Alias for `nmol`.
  MolarAmount get nanomoles => MolarAmount(toDouble(), MolarUnit.nanomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Picomoles (pmol).
  MolarAmount get pmol => MolarAmount(toDouble(), MolarUnit.picomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Picomoles (pmol).
  /// Alias for `pmol`.
  MolarAmount get picomoles => MolarAmount(toDouble(), MolarUnit.picomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Kilomoles (kmol).
  MolarAmount get kmol => MolarAmount(toDouble(), MolarUnit.kilomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Kilomoles (kmol).
  /// Alias for `kmol`.
  MolarAmount get kilomoles => MolarAmount(toDouble(), MolarUnit.kilomole);
}
// END FILE: lib/src/units/molar/molar_extensions.dart

<!-- END FILE: [v0.5.0] lib/src/units/molar/molar_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/molar/molar_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

/// Defines base conversion factors for various molar amount units relative to the Mole (mol),
/// which is the SI base unit for amount of substance.
///
/// These constants represent: `1 [Unit] = Z [Moles]`.
/// So, `molesPerMillimole` means `1 millimole = molesPerMillimole moles`.
class MolarFactors {
  // --- SI Prefixed Units (relative to Mole) ---

  /// Moles per Millimole: 1 millimole (mmol) = 0.001 moles (mol).
  static const double molesPerMillimole = 0.001;

  /// Moles per Micromole: 1 micromole (¬µmol) = 0.000001 moles (mol).
  static const double molesPerMicromole = 0.000001;

  /// Moles per Nanomole: 1 nanomole (nmol) = 1e-9 moles (mol).
  static const double molesPerNanomole = 1.0e-9;

  /// Moles per Picomole: 1 picomole (pmol) = 1e-12 moles (mol).
  static const double molesPerPicomole = 1.0e-12;

  /// Moles per Kilomole: 1 kilomole (kmol) = 1000 moles (mol).
  static const double molesPerKilomole = 1000.0;

  // --- Other potential units (less common for direct amount of substance,
  //      but could be relevant in specific contexts or conversions) ---

  // Example: Pound-mole (lb-mol) - an imperial unit occasionally used in chemical engineering.
  // 1 lb-mol is the amount of a substance whose mass in pounds is numerically equal
  // to its molar mass in g/mol.
  // 1 lb-mol ‚âà 453.59237 mol (since 1 lb ‚âà 453.59237 g)
  // static const double molesPerPoundMole = 453.592370000104; // Derived from lb to g conversion.
  // Using a more direct reference or if precision is critical, this might need verification.
  // For now, focusing on SI prefixed units.
}

<!-- END FILE: [v0.5.0] lib/src/units/molar/molar_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/molar/molar_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'molar_factors.dart';

/// Represents units for amount of substance (molar amount).
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each molar amount unit.
/// All conversion factors are pre-calculated in the constructor relative to Mole (mol),
/// which is the SI base unit for amount of substance.
enum MolarUnit implements Unit<MolarUnit> {
  /// Mole (mol), the SI base unit for amount of substance.
  /// One mole contains exactly 6.02214076 √ó 10¬≤¬≥ elementary entities (Avogadro's number).
  mole(1, 'mol'),

  /// Millimole (mmol), equal to 0.001 moles.
  millimole(MolarFactors.molesPerMillimole, 'mmol'),

  /// Micromole (¬µmol), equal to 1e-6 moles.
  micromole(MolarFactors.molesPerMicromole, '¬µmol'),

  /// Nanomole (nmol), equal to 1e-9 moles.
  nanomole(MolarFactors.molesPerNanomole, 'nmol'),

  /// Picomole (pmol), equal to 1e-12 moles.
  picomole(MolarFactors.molesPerPicomole, 'pmol'),

  /// Kilomole (kmol), equal to 1000 moles.
  kilomole(MolarFactors.molesPerKilomole, 'kmol');

  // If pound-mole were to be added:
  // /// Pound-mole (lb-mol), an imperial unit for amount of substance.
  // /// 1 lb-mol ‚âà 453.59237 mol.
  // poundMole(MolarFactors.molesPerPoundMole, 'lb-mol');

  /// Constant constructor for enum members.
  ///
  /// [_toMoleFactor] is the factor to convert from this unit to the base unit (Mole).
  /// For Mole itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `MolarUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used,
  /// where the base unit is Mole.
  const MolarUnit(double toMoleFactor, this.symbol)
      : _toMoleFactor = toMoleFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToMole = toMoleFactor / 1.0, // Base unit factor for mole is 1.0
        _factorToMillimole = toMoleFactor / MolarFactors.molesPerMillimole,
        _factorToMicromole = toMoleFactor / MolarFactors.molesPerMicromole,
        _factorToNanomole = toMoleFactor / MolarFactors.molesPerNanomole,
        _factorToPicomole = toMoleFactor / MolarFactors.molesPerPicomole,
        _factorToKilomole = toMoleFactor / MolarFactors.molesPerKilomole;
  // If poundMole were added:
  // _factorToPoundMole = toMoleFactor / MolarFactors.molesPerPoundMole;

  /// The factor to convert a value from this unit to the base unit (Mole).
  /// Example: For Millimole, this is 0.001 (meaning 1 mmol = 0.001 mol).
  /// This field is primarily used internally by the constructor to derive
  /// direct inter-unit conversion factors.
  // ignore: unused_field
  final double _toMoleFactor;

  /// The human-readable symbol for this molar amount unit (e.g., "mol", "mmol").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  // These are calculated once in the const constructor for performance.

  final double _factorToMole;
  final double _factorToMillimole;
  final double _factorToMicromole;
  final double _factorToNanomole;
  final double _factorToPicomole;
  final double _factorToKilomole;
  // If poundMole were added:
  // final double _factorToPoundMole;

  /// Returns the direct conversion factor to convert a value from this [MolarUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `MolarAmount`
  /// class for conversions.
  ///
  /// Example: `MolarUnit.millimole.factorTo(MolarUnit.mole)` would return `0.001`.
  /// `MolarUnit.mole.factorTo(MolarUnit.millimole)` would return `1000.0`.
  ///
  /// - [targetUnit]: The `MolarUnit` to which a value should be converted.
  ///
  /// Returns the multiplication factor.
  @override
  @internal
  double factorTo(MolarUnit targetUnit) {
    switch (targetUnit) {
      case MolarUnit.mole:
        return _factorToMole;
      case MolarUnit.millimole:
        return _factorToMillimole;
      case MolarUnit.micromole:
        return _factorToMicromole;
      case MolarUnit.nanomole:
        return _factorToNanomole;
      case MolarUnit.picomole:
        return _factorToPicomole;
      case MolarUnit.kilomole:
        return _factorToKilomole;
      // If poundMole were added:
      // case MolarUnit.poundMole:
      //   return _factorToPoundMole;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/molar/molar_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/pressure/pressure.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'pressure_unit.dart';

/// Represents a quantity of pressure.
///
/// Pressure is a fundamental physical quantity, defined as force per unit area.
/// This class provides a type-safe way to handle pressure values and conversions
/// between different units of pressure.
@immutable
class Pressure extends Quantity<PressureUnit> {
  /// Creates a new Pressure quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final standardAtmosphere = Pressure(1.0, PressureUnit.atmosphere);
  /// final tirePressure = Pressure(32.0, PressureUnit.psi);
  /// ```
  const Pressure(super.value, super.unit);

  /// Converts this pressure's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors for efficiency,
  /// typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final p_atm = Pressure(1.0, PressureUnit.atmosphere);
  /// final p_pascals = p_atm.getValue(PressureUnit.pascal); // 101325.0
  /// ```
  @override
  double getValue(PressureUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Pressure] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Pressure` object in a different unit
  /// while preserving type safety and quantity semantics.
  ///
  /// Example:
  /// ```dart
  /// final p_bar = Pressure(1.5, PressureUnit.bar);
  /// final p_psi = p_bar.convertTo(PressureUnit.psi);
  /// print(p_psi); // Output: approx "21.7557 psi"
  /// ```
  @override
  Pressure convertTo(PressureUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Pressure(newValue, targetUnit);
  }

  /// Compares this [Pressure] object to another [Quantity<PressureUnit>].
  ///
  /// Comparison is based on the physical magnitude of the pressures.
  /// For comparison, this pressure is converted to the unit of the [other] pressure.
  ///
  /// Returns:
  /// - A negative integer if this pressure is less than [other].
  /// - Zero if this pressure is equal to [other].
  /// - A positive integer if this pressure is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final p1 = Pressure(1.0, PressureUnit.bar);    // 100000 Pa
  /// final p2 = Pressure(1000.0, PressureUnit.millibar); // 100000 Pa
  /// final p3 = Pressure(15.0, PressureUnit.psi);   // approx 103421 Pa
  ///
  /// print(p1.compareTo(p2)); // 0 (equal)
  /// print(p1.compareTo(p3)); // -1 (p1 < p3)
  /// ```
  @override
  int compareTo(Quantity<PressureUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this pressure to another pressure.
  /// The [other] pressure is converted to the unit of this pressure before addition.
  /// Returns a new [Pressure] instance with the result in the unit of this pressure.
  Pressure operator +(Pressure other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Pressure(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another pressure from this pressure.
  /// The [other] pressure is converted to the unit of this pressure before subtraction.
  /// Returns a new [Pressure] instance with the result in the unit of this pressure.
  Pressure operator -(Pressure other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Pressure(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this pressure by a scalar value.
  /// Returns a new [Pressure] instance with the scaled value in the original unit.
  Pressure operator *(double scalar) {
    return Pressure(value * scalar, unit);
  }

  /// Divides this pressure by a scalar value.
  /// Returns a new [Pressure] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Pressure operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Pressure(value / scalar, unit);
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/pressure/pressure.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/pressure/pressure_extensions.dart -->
import 'pressure.dart';
import 'pressure_unit.dart';

/// Provides convenient access to [Pressure] values in specific units
/// using shortened unit names where appropriate.
extension PressureValueGetters on Pressure {
  /// Returns the pressure value in Pascals (Pa).
  double get inPa => getValue(PressureUnit.pascal);

  /// Returns the pressure value in Atmospheres (atm).
  double get inAtm => getValue(PressureUnit.atmosphere); // "atm" is already short

  /// Returns the pressure value in Bars (bar).
  double get inBar => getValue(PressureUnit.bar); // "bar" is already short

  /// Returns the pressure value in Pounds per Square Inch (psi).
  double get inPsi => getValue(PressureUnit.psi); // "psi" is already short

  /// Returns the pressure value in Torrs (Torr).
  double get inTorr => getValue(PressureUnit.torr);

  /// Returns the pressure value in Millimeters of Mercury (mmHg).
  double get inMmHg => getValue(PressureUnit.millimeterOfMercury);

  /// Returns the pressure value in Inches of Mercury (inHg).
  double get inInHg => getValue(PressureUnit.inchOfMercury);

  /// Returns the pressure value in Kilopascals (kPa).
  double get inKPa => getValue(PressureUnit.kilopascal);

  /// Returns the pressure value in Hectopascals (hPa).
  double get inHPa => getValue(PressureUnit.hectopascal);

  /// Returns the pressure value in Millibars (mbar).
  double get inMbar => getValue(PressureUnit.millibar);

  /// Returns the pressure value in Centimeters of Water (cmH‚ÇÇO) at 4¬∞C.
  double get inCmH2O => getValue(PressureUnit.centimeterOfWater);

  /// Returns the pressure value in Inches of Water (inH‚ÇÇO) at 4¬∞C.
  double get inInH2O => getValue(PressureUnit.inchOfWater);

  /// Returns a Pressure representing this pressure in Pascals (Pa).
  Pressure get asPa => convertTo(PressureUnit.pascal);

  /// Returns a Pressure representing this pressure in Atmospheres (atm).
  Pressure get asAtm => convertTo(PressureUnit.atmosphere);

  /// Returns a Pressure representing this pressure in Bars (bar).
  Pressure get asBar => convertTo(PressureUnit.bar);

  /// Returns a Pressure representing this pressure in Pounds per Square Inch (psi).
  Pressure get asPsi => convertTo(PressureUnit.psi);

  /// Returns a Pressure representing this pressure in Torrs (Torr).
  Pressure get asTorr => convertTo(PressureUnit.torr);

  /// Returns a Pressure representing this pressure in Millimeters of Mercury (mmHg).
  Pressure get asMmHg => convertTo(PressureUnit.millimeterOfMercury);

  /// Returns a Pressure representing this pressure in Inches of Mercury (inHg).
  Pressure get asInHg => convertTo(PressureUnit.inchOfMercury);

  /// Returns a Pressure representing this pressure in Kilopascals (kPa).
  Pressure get asKPa => convertTo(PressureUnit.kilopascal);

  /// Returns a Pressure representing this pressure in Hectopascals (hPa).
  Pressure get asHPa => convertTo(PressureUnit.hectopascal);

  /// Returns a Pressure representing this pressure in Millibars (mbar).
  Pressure get asMbar => convertTo(PressureUnit.millibar);

  /// Returns a Pressure representing this pressure in Centimeters of Water (cmH‚ÇÇO).
  Pressure get asCmH2O => convertTo(PressureUnit.centimeterOfWater);

  /// Returns a Pressure representing this pressure in Inches of Water (inH‚ÇÇO).
  Pressure get asInH2O => convertTo(PressureUnit.inchOfWater);
}

/// Provides convenient factory methods for creating [Pressure] instances from [num]
/// using shortened unit names where appropriate.
extension PressureCreation on num {
  /// Creates a [Pressure] instance representing this numerical value in Pascals (Pa).
  Pressure get pa => Pressure(toDouble(), PressureUnit.pascal);

  /// Creates a [Pressure] instance representing this numerical value in Atmospheres (atm).
  Pressure get atm => Pressure(toDouble(), PressureUnit.atmosphere);

  /// Creates a [Pressure] instance representing this numerical value in Bars (bar).
  Pressure get bar => Pressure(toDouble(), PressureUnit.bar);

  /// Creates a [Pressure] instance representing this numerical value in Pounds per Square Inch (psi).
  Pressure get psi => Pressure(toDouble(), PressureUnit.psi);

  /// Creates a [Pressure] instance representing this numerical value in Torrs (Torr).
  Pressure get torr => Pressure(toDouble(), PressureUnit.torr);

  /// Creates a [Pressure] instance representing this numerical value in Millimeters of Mercury (mmHg).
  Pressure get mmHg => Pressure(toDouble(), PressureUnit.millimeterOfMercury);

  /// Creates a [Pressure] instance representing this numerical value in Inches of Mercury (inHg).
  Pressure get inHg => Pressure(toDouble(), PressureUnit.inchOfMercury);

  /// Creates a [Pressure] instance representing this numerical value in Kilopascals (kPa).
  Pressure get kPa => Pressure(toDouble(), PressureUnit.kilopascal);

  /// Creates a [Pressure] instance representing this numerical value in Hectopascals (hPa).
  Pressure get hPa => Pressure(toDouble(), PressureUnit.hectopascal);

  /// Creates a [Pressure] instance representing this numerical value in Millibars (mbar).
  Pressure get mbar => Pressure(toDouble(), PressureUnit.millibar);

  /// Creates a [Pressure] instance representing this numerical value in Centimeters of Water (cmH‚ÇÇO) at 4¬∞C.
  Pressure get cmH2O => Pressure(toDouble(), PressureUnit.centimeterOfWater);

  /// Creates a [Pressure] instance representing this numerical value in Inches of Water (inH‚ÇÇO) at 4¬∞C.
  Pressure get inH2O => Pressure(toDouble(), PressureUnit.inchOfWater);

  // Longer aliases (optional)
  // Pressure get pascals => Pressure(toDouble(), PressureUnit.pascal);
  // Pressure get atmospheres => Pressure(toDouble(), PressureUnit.atmosphere);
  // Pressure get bars => Pressure(toDouble(), PressureUnit.bar);
  // Pressure get poundsPerSquareInch => Pressure(toDouble(), PressureUnit.psi);
  // Pressure get torrs => Pressure(toDouble(), PressureUnit.torr);
  // Pressure get millimetersOfMercury => Pressure(toDouble(), PressureUnit.millimeterOfMercury);
  // Pressure get inchesOfMercury => Pressure(toDouble(), PressureUnit.inchOfMercury);
  // Pressure get kilopascals => Pressure(toDouble(), PressureUnit.kilopascal);
  // Pressure get hectopascals => Pressure(toDouble(), PressureUnit.hectopascal);
  // Pressure get millibars => Pressure(toDouble(), PressureUnit.millibar);
  // Pressure get centimetersOfWater => Pressure(toDouble(), PressureUnit.centimeterOfWater);
  // Pressure get inchesOfWater => Pressure(toDouble(), PressureUnit.inchOfWater);
}

<!-- END FILE: [v0.5.0] lib/src/units/pressure/pressure_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/pressure/pressure_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import '../../../quantify.dart' show Unit;
import '../../core/unit.dart' show Unit;

/// Defines base conversion factors for various pressure units relative to Pascal (Pa).
///
/// These constants are based on international standards (e.g., NIST) where available.
/// The base unit for internal calculations is Pascal.
/// Factors represent: 1 [Unit] = X Pascals.
/// All water column units (cmH‚ÇÇO, inH‚ÇÇO) refer to a water temperature of 4¬∞C (39.2¬∞F)
/// unless otherwise specified, aligning with common scientific reference points for water density
/// and conventional values (e.g., NIST SP 811).
class PressureFactors {
  /// Pascals per Standard Atmosphere (atm): 1 atm = 101325 Pa (exact definition).
  static const double pascalsPerAtmosphere = 101325.0;

  /// Pascals per Bar (bar): 1 bar = 100000 Pa (exact definition).
  static const double pascalsPerBar = 100000.0;

  /// Pascals per Pound per Square Inch (psi): 1 psi ‚âà 6894.757293168361 Pa.
  /// Derived from the international yard and pound agreement:
  /// 1 pound-force (lbf) ‚âà 4.4482216152605 N and 1 inch = 0.0254 m.
  static const double pascalsPerPsi = 6894.757293168361;

  /// Pascals per Torr (Torr): 1 Torr ‚âà 133.322368421 Pa.
  /// Defined as 1/760 of a standard atmosphere. Mercury at 0¬∞C.
  static const double pascalsPerTorr = pascalsPerAtmosphere / 760.0;

  /// Pascals per Millimeter of Mercury (mmHg) at 0¬∞C: Same as Torr.
  /// 1 mmHg (at 0¬∞C) ‚âà 133.322368421 Pa.
  static const double pascalsPerMillimeterOfMercury = pascalsPerTorr;

  /// Pascals per Inch of Mercury (inHg) at 0¬∞C: 1 inHg ‚âà 3386.388687636 Pa.
  /// Defined as `pascalsPerMillimeterOfMercury * 25.4` (since 1 inch = 25.4 mm).
  /// Conventional value often cited from NIST SP 811 is 3386.389 Pa.
  /// The calculated value is (101325.0 / 760.0) * 25.4 = 3386.3886876315788
  static const double pascalsPerInchOfMercury = pascalsPerMillimeterOfMercury * 25.4;
  // For reference, NIST SP 811 Appendix B.8 lists:
  // Inch of mercury (0 ¬∞C)  = 3.386 389 E+03 Pa
  // The calculated value is extremely close and based on fundamental definitions.
  // Using the calculated one for consistency, the difference is negligible for doubles.

  /// Pascals per Kilopascal (kPa): 1 kPa = 1000 Pa.
  static const double pascalsPerKilopascal = 1000.0;

  /// Pascals per Hectopascal (hPa): 1 hPa = 100 Pa.
  static const double pascalsPerHectopascal = 100.0;

  /// Pascals per Millibar (mbar): 1 mbar = 100 Pa (same as hPa).
  static const double pascalsPerMillibar = 100.0;

  /// Conventional value for Pascals per Centimeter of Water (cmH‚ÇÇO) at 4¬∞C.
  /// 1 cmH‚ÇÇO (at 4¬∞C) = 98.0665 Pa.
  /// This value is commonly cited, e.g., in NIST SP 811, based on a conventional
  /// standard gravity (g‚Çô = 9.80665 m/s¬≤) and water density of 1000 kg/m¬≥ at 4¬∞C.
  static const double conventionalPascalsPerCentimeterOfWater4C = 98.0665;

  /// Conventional value for Pascals per Inch of Water (inH‚ÇÇO) at 4¬∞C.
  /// 1 inH‚ÇÇO (at 4¬∞C) = 249.08891 Pa.
  /// This value is commonly cited, e.g., in NIST SP 811, and is derived from
  /// `conventionalPascalsPerCentimeterOfWater4C * 2.54` (since 1 inch = 2.54 cm).
  static const double conventionalPascalsPerInchOfWater4C = 249.08891;
}

<!-- END FILE: [v0.5.0] lib/src/units/pressure/pressure_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/pressure/pressure_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'pressure_factors.dart';

/// Represents units of pressure.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each pressure unit.
/// All conversion factors are pre-calculated in the constructor relative to Pascal (Pa).
enum PressureUnit implements Unit<PressureUnit> {
  /// Pascal (Pa), the SI derived unit of pressure.
  pascal(1, 'Pa'),

  /// Atmosphere (atm), standard atmosphere.
  atmosphere(PressureFactors.pascalsPerAtmosphere, 'atm'),

  /// Bar (bar).
  bar(PressureFactors.pascalsPerBar, 'bar'),

  /// Pound per square inch (psi).
  psi(PressureFactors.pascalsPerPsi, 'psi'),

  /// Torr (Torr), approximately 1 mmHg.
  torr(PressureFactors.pascalsPerTorr, 'Torr'),

  /// Millimeter of mercury (mmHg) at 0¬∞C.
  millimeterOfMercury(PressureFactors.pascalsPerMillimeterOfMercury, 'mmHg'),

  /// Inch of mercury (inHg) at 0¬∞C.
  inchOfMercury(PressureFactors.pascalsPerInchOfMercury, 'inHg'),

  /// Kilopascal (kPa).
  kilopascal(PressureFactors.pascalsPerKilopascal, 'kPa'),

  /// Hectopascal (hPa).
  hectopascal(PressureFactors.pascalsPerHectopascal, 'hPa'),

  /// Millibar (mbar), equivalent to hectopascal.
  millibar(PressureFactors.pascalsPerMillibar, 'mbar'),

  /// Centimeter of water (cmH‚ÇÇO) at 4¬∞C.
  centimeterOfWater(PressureFactors.conventionalPascalsPerCentimeterOfWater4C, 'cmH‚ÇÇO'),

  /// Inch of water (inH‚ÇÇO) at 4¬∞C.
  inchOfWater(PressureFactors.conventionalPascalsPerInchOfWater4C, 'inH‚ÇÇO');

  /// Constant constructor for enum members.
  ///
  /// [_toPascalFactor] is the factor to convert from this unit to the base unit (Pascal).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `PressureUnit`.
  /// The formula `factor_A_to_B = _toPascalFactor_A / _toPascalFactor_B` is used.
  const PressureUnit(this._toPascalFactor, this.symbol)
      : _factorToPascal = _toPascalFactor / 1.0, // Pascal's _toPascalFactor is 1.0
        _factorToAtmosphere = _toPascalFactor / PressureFactors.pascalsPerAtmosphere,
        _factorToBar = _toPascalFactor / PressureFactors.pascalsPerBar,
        _factorToPsi = _toPascalFactor / PressureFactors.pascalsPerPsi,
        _factorToTorr = _toPascalFactor / PressureFactors.pascalsPerTorr,
        _factorToMillimeterOfMercury =
            _toPascalFactor / PressureFactors.pascalsPerMillimeterOfMercury,
        _factorToInchOfMercury = _toPascalFactor / PressureFactors.pascalsPerInchOfMercury,
        _factorToKilopascal = _toPascalFactor / PressureFactors.pascalsPerKilopascal,
        _factorToHectopascal = _toPascalFactor / PressureFactors.pascalsPerHectopascal,
        _factorToMillibar = _toPascalFactor / PressureFactors.pascalsPerMillibar,
        _factorToCentimeterOfWater =
            _toPascalFactor / PressureFactors.conventionalPascalsPerCentimeterOfWater4C,
        _factorToInchOfWater =
            _toPascalFactor / PressureFactors.conventionalPascalsPerInchOfWater4C;

  /// The factor to convert a value from this unit to the base unit (Pascal).
  /// Example: For Bar, this is 100000.0 (meaning 1 bar = 100000.0 Pa).
  /// After constructor initialization, its value is primarily baked into
  /// the specific _factorToXxx fields for direct inter-unit conversions.
  /// It's generally not accessed directly by methods outside this enum's constructor
  /// but is crucial for deriving the pre-calculated factors.
  // ignore: unused_field
  final double _toPascalFactor;

  /// The human-readable symbol for this pressure unit (e.g., "Pa", "psi").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  // These are calculated once in the const constructor.

  final double _factorToPascal;
  final double _factorToAtmosphere;
  final double _factorToBar;
  final double _factorToPsi;
  final double _factorToTorr;
  final double _factorToMillimeterOfMercury;
  final double _factorToInchOfMercury;
  final double _factorToKilopascal;
  final double _factorToHectopascal;
  final double _factorToMillibar;
  final double _factorToCentimeterOfWater;
  final double _factorToInchOfWater;

  /// Returns the direct conversion factor to convert a value from this [PressureUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(PressureUnit targetUnit) {
    switch (targetUnit) {
      case PressureUnit.pascal:
        return _factorToPascal;
      case PressureUnit.atmosphere:
        return _factorToAtmosphere;
      case PressureUnit.bar:
        return _factorToBar;
      case PressureUnit.psi:
        return _factorToPsi;
      case PressureUnit.torr:
        return _factorToTorr;
      case PressureUnit.millimeterOfMercury:
        return _factorToMillimeterOfMercury;
      case PressureUnit.inchOfMercury:
        return _factorToInchOfMercury;
      case PressureUnit.kilopascal:
        return _factorToKilopascal;
      case PressureUnit.hectopascal:
        return _factorToHectopascal;
      case PressureUnit.millibar:
        return _factorToMillibar;
      case PressureUnit.centimeterOfWater:
        return _factorToCentimeterOfWater;
      case PressureUnit.inchOfWater:
        return _factorToInchOfWater;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/pressure/pressure_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/temperature/temperature.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'temperature_unit.dart';

/// Represents a quantity of temperature.
///
/// Temperature conversions are affine (involve offsets) and are handled by
/// specific formulas within the [getValue] method, rather than simple
/// multiplicative factors.
@immutable
class Temperature extends Quantity<TemperatureUnit> {
  /// Creates a new Temperature quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final bodyTemp = Temperature(37.0, TemperatureUnit.celsius);
  /// final absoluteZero = Temperature(0.0, TemperatureUnit.kelvin);
  /// ```
  const Temperature(super.value, super.unit);

  // --- Conversion Constants ---
  // These could also be in a separate TemperatureFactors class if they grew more complex
  // or were needed elsewhere, but for direct formulas they are fine here.

  /// The offset of Kelvin from Celsius (0¬∞C = 273.15K).
  static const double kelvinOffsetFromCelsius = 273.15;

  /// The scaling factor for Fahrenheit to Celsius conversion (9/5).
  static const double fahrenheitScaleFactor = 1.8; // 9.0 / 5.0

  /// The offset for Fahrenheit conversion from Celsius (0¬∞C = 32¬∞F).
  static const double fahrenheitOffset = 32.0;

  /// The offset for Rankine conversion from Fahrenheit (0¬∞F = 459.67¬∞R).
  static const double rankineOffsetFromFahrenheit = 459.67;

  /// Converts this temperature's value to the specified [targetUnit]
  /// using direct, optimized formulas for affine conversions.
  ///
  /// Example:
  /// ```dart
  /// final roomTempC = Temperature(20.0, TemperatureUnit.celsius);
  /// final roomTempF = roomTempC.getValue(TemperatureUnit.fahrenheit); // 68.0
  /// ```
  @override
  double getValue(TemperatureUnit targetUnit) {
    if (targetUnit == unit) return value;

    switch (unit) {
      case TemperatureUnit.celsius:
        switch (targetUnit) {
          case TemperatureUnit.kelvin:
            return value + kelvinOffsetFromCelsius;
          case TemperatureUnit.fahrenheit:
            return (value * fahrenheitScaleFactor) + fahrenheitOffset;
          case TemperatureUnit.rankine:
            // Celsius -> Fahrenheit -> Rankine
            final fahrenheitValue = (value * fahrenheitScaleFactor) + fahrenheitOffset;
            return fahrenheitValue + rankineOffsetFromFahrenheit;
          case TemperatureUnit.celsius:
            return value;
        }
      case TemperatureUnit.kelvin:
        switch (targetUnit) {
          case TemperatureUnit.celsius:
            return value - kelvinOffsetFromCelsius;
          case TemperatureUnit.fahrenheit:
            final celsiusValue = value - kelvinOffsetFromCelsius;
            return (celsiusValue * fahrenheitScaleFactor) + fahrenheitOffset;
          case TemperatureUnit.rankine:
            // Kelvin -> Rankine: multiply by 9/5
            return value * fahrenheitScaleFactor;
          case TemperatureUnit.kelvin:
            return value;
        }
      case TemperatureUnit.fahrenheit:
        switch (targetUnit) {
          case TemperatureUnit.celsius:
            return (value - fahrenheitOffset) / fahrenheitScaleFactor;
          case TemperatureUnit.kelvin:
            final celsiusValue = (value - fahrenheitOffset) / fahrenheitScaleFactor;
            return celsiusValue + kelvinOffsetFromCelsius;
          case TemperatureUnit.rankine:
            return value + rankineOffsetFromFahrenheit;
          case TemperatureUnit.fahrenheit:
            return value;
        }
      case TemperatureUnit.rankine:
        switch (targetUnit) {
          case TemperatureUnit.fahrenheit:
            return value - rankineOffsetFromFahrenheit;
          case TemperatureUnit.celsius:
            // Rankine -> Fahrenheit -> Celsius
            final fahrenheitValue = value - rankineOffsetFromFahrenheit;
            return (fahrenheitValue - fahrenheitOffset) / fahrenheitScaleFactor;
          case TemperatureUnit.kelvin:
            // Rankine -> Kelvin: divide by 9/5
            return value / fahrenheitScaleFactor;
          case TemperatureUnit.rankine:
            return value;
        }
    }
  }

  /// Creates a new [Temperature] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final boilingPointC = Temperature(100.0, TemperatureUnit.celsius);
  /// final boilingPointF = boilingPointC.convertTo(TemperatureUnit.fahrenheit);
  /// print(boilingPointF); // Output: "212.0 ¬∞F"
  /// ```
  @override
  Temperature convertTo(TemperatureUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Temperature(newValue, targetUnit);
  }

  /// Compares this [Temperature] object to another [Quantity<TemperatureUnit>].
  ///
  /// Comparison is based on the physical magnitude of the temperatures.
  /// For comparison, this temperature is converted to the unit of the [other] temperature.
  @override
  int compareTo(Quantity<TemperatureUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators (Specific for Temperature) ---

  /// Subtracts another temperature from this temperature, yielding a temperature difference.
  /// The [other] temperature is converted to the unit of this temperature before subtraction.
  /// Returns a [double] representing the difference in the unit of this temperature.
  /// For example, `20.celsius - 10.celsius` yields `10.0` (a difference of 10 Celsius degrees).
  double operator -(Temperature other) {
    final otherValueInThisUnit = other.getValue(unit);
    return value - otherValueInThisUnit;
  }

  // Operator + (Temperature other) is intentionally not implemented as adding
  // absolute temperatures (e.g., 20¬∞C + 10¬∞C) is not physically meaningful.
  // Use the `operator -` to find a temperature difference.

  // Operator * (double scalar) is intentionally not implemented as scaling
  // absolute temperatures is generally not meaningful, except in specific
  // thermodynamic contexts where absolute scales (Kelvin/Rankine) are used.
  // For such cases, it is safer for the user to extract the value and perform the calculation explicitly.

  // Operator / (double scalar) is intentionally not implemented as it's
  // generally not physically meaningful for absolute temperatures.

  /// Divides this temperature by another temperature.
  /// The [other] temperature is converted to the unit of this temperature before division.
  /// Returns a scalar [double] representing the ratio.
  /// Note: This operation is only meaningful in specific thermodynamic contexts (e.g., Carnot efficiency)
  /// and should be used with caution. Both temperatures should ideally be on an absolute scale (Kelvin or Rankine)
  /// for physical meaning, though the calculation will be performed based on converted values.
  /// Throws [ArgumentError] if the effective value of [other] in this unit is zero.
  double operator /(Temperature other) {
    // For ratio calculations, it's often more meaningful if both are converted to Kelvin first,
    // but to keep consistent with other quantity divisions, we convert to `this.unit`.
    final otherValueInThisUnit = other.getValue(unit);
    if (otherValueInThisUnit == 0 && value != 0) {
      // Avoid 0/0 resulting in NaN without error
      // A zero temperature on a non-Kelvin scale might not be absolute zero.
      // However, division by zero magnitude is the primary concern.
      throw ArgumentError('Cannot divide by a zero temperature if the dividend is non-zero.');
    }
    // Handle 0.0 / 0.0 case, which results in NaN. Could throw or return as is.
    // Standard double division handles 0.0/0.0 as NaN.
    if (value == 0 && otherValueInThisUnit == 0) {
      return double.nan; // Or throw, depending on desired strictness for 0/0
    }
    return value / otherValueInThisUnit;
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/temperature/temperature.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/temperature/temperature_extensions.dart -->
import 'temperature.dart';
import 'temperature_unit.dart';

/// Provides convenient access to [Temperature] values in specific units.
extension TemperatureValueGetters on Temperature {
  /// Returns the temperature value in Celsius (¬∞C).
  double get inCelsius => getValue(TemperatureUnit.celsius);

  /// Returns the temperature value in Kelvin (K).
  double get inKelvin => getValue(TemperatureUnit.kelvin);

  /// Returns the temperature value in Fahrenheit (¬∞F).
  double get inFahrenheit => getValue(TemperatureUnit.fahrenheit);

  /// Returns the temperature value in Rankine (¬∞R).
  double get inRankine => getValue(TemperatureUnit.rankine);

  /// Returns a Temperature representing this temperature in Celsius (¬∞C).
  Temperature get asCelsius => convertTo(TemperatureUnit.celsius);

  /// Returns a Temperature representing this temperature in Kelvin (K).
  Temperature get asKelvin => convertTo(TemperatureUnit.kelvin);

  /// Returns a Temperature representing this temperature in Fahrenheit (¬∞F).
  Temperature get asFahrenheit => convertTo(TemperatureUnit.fahrenheit);

  /// Returns a Temperature representing this temperature in Rankine (¬∞R).
  Temperature get asRankine => convertTo(TemperatureUnit.rankine);
}

/// Provides convenient factory methods for creating [Temperature] instances from [num].
extension TemperatureCreation on num {
  /// Creates a [Temperature] instance representing this numerical value in Celsius (¬∞C).
  Temperature get celsius => Temperature(toDouble(), TemperatureUnit.celsius);

  /// Creates a [Temperature] instance representing this numerical value in Kelvin (K).
  Temperature get kelvin => Temperature(toDouble(), TemperatureUnit.kelvin);

  /// Creates a [Temperature] instance representing this numerical value in Fahrenheit (¬∞F).
  Temperature get fahrenheit => Temperature(toDouble(), TemperatureUnit.fahrenheit);

  /// Creates a [Temperature] instance representing this numerical value in Rankine (¬∞R).
  Temperature get rankine => Temperature(toDouble(), TemperatureUnit.rankine);
}

<!-- END FILE: [v0.5.0] lib/src/units/temperature/temperature_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/temperature/temperature_unit.dart -->
import '../../core/unit.dart';
import 'temperature.dart';

/// Represents units of temperature.
///
/// This enum implements the [Unit] interface but its [factorTo] method
/// will throw an [UnsupportedError] because temperature conversions
/// are affine (involve offsets) and cannot be represented by a single
/// multiplicative factor. Use [Temperature.getValue] or [Temperature.convertTo]
/// for proper conversions.
enum TemperatureUnit implements Unit<TemperatureUnit> {
  /// Celsius (¬∞C).
  celsius('¬∞C'),

  /// Kelvin (K), the SI base unit of thermodynamic temperature.
  kelvin('K'),

  /// Fahrenheit (¬∞F).
  fahrenheit('¬∞F'),

  /// Rankine (¬∞R), an absolute temperature scale using Fahrenheit degrees.
  /// ¬∞R = ¬∞F + 459.67, or ¬∞R = ¬∞K √ó 9/5.
  rankine('¬∞R');

  /// Constant constructor for enum members.
  /// [symbol] is the display symbol for the unit.
  const TemperatureUnit(this.symbol);

  @override
  final String symbol;

  /// Throws [UnsupportedError] for temperature units.
  ///
  /// Temperature conversions are affine (involve offsets) and cannot be
  /// represented by a single multiplicative factor.
  /// Use [Temperature.getValue] or [Temperature.convertTo] for proper
  /// temperature conversions.
  @override
  double factorTo(TemperatureUnit targetUnit) {
    throw UnsupportedError(
      'Direct multiplicative factor conversion is not supported for temperature units '
      'due to their affine nature (offsets). '
      'Use Temperature.getValue() or Temperature.convertTo() for proper conversions.',
    );
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/temperature/temperature_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/time/time.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'time_unit.dart';

/// Represents a quantity of time (duration).
@immutable
class Time extends Quantity<TimeUnit> {
  /// Creates a new Time quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final duration = Time(120.0, TimeUnit.second);
  /// final meetingLength = Time(1.5, TimeUnit.hour);
  /// ```
  const Time(super.value, super.unit);

  /// Converts this time's value to the specified [targetUnit].
  @override
  double getValue(TimeUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Time] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final twoMinutes = Time(2.0, TimeUnit.minute);
  /// final inSeconds = twoMinutes.convertTo(TimeUnit.second); // Time(120.0, TimeUnit.second)
  /// print(inSeconds.value); // 120.0
  /// ```
  @override
  Time convertTo(TimeUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Time(newValue, targetUnit);
  }

  /// Compares this [Time] object to another [Quantity<TimeUnit>].
  ///
  /// Comparison is based on the physical magnitude of the durations.
  @override
  int compareTo(Quantity<TimeUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this time duration to another time duration.
  /// The [other] time is converted to the unit of this time before addition.
  /// Returns a new [Time] instance with the result in the unit of this time.
  Time operator +(Time other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Time(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another time duration from this time duration.
  /// The [other] time is converted to the unit of this time before subtraction.
  /// Returns a new [Time] instance with the result in the unit of this time.
  Time operator -(Time other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Time(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this time duration by a scalar value.
  /// Returns a new [Time] instance with the scaled value in the original unit.
  Time operator *(double scalar) {
    return Time(value * scalar, unit);
  }

  /// Divides this time duration by a scalar value.
  /// Returns a new [Time] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Time operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Time(value / scalar, unit);
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/time/time.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/time/time_extensions.dart -->
import 'time.dart';
import 'time_unit.dart';

/// Provides convenient access to [Time] values in specific units.
extension TimeValueGetters on Time {
  /// Returns the time value in Seconds (s).
  double get inSeconds => getValue(TimeUnit.second);

  /// Returns the time value in Microseconds (Œºs).
  double get inMicroseconds => getValue(TimeUnit.microsecond);

  /// Returns the time value in Nanoseconds (ns).
  double get inNanoseconds => getValue(TimeUnit.nanosecond);

  /// Returns the time value in Picoseconds (ps).
  double get inPicoseconds => getValue(TimeUnit.picosecond);

  /// Returns the time value in Milliseconds (ms).
  double get inMilliseconds => getValue(TimeUnit.millisecond);

  /// Returns the time value in Centiseconds (cs).
  double get inCentiseconds => getValue(TimeUnit.centisecond);

  /// Returns the time value in Deciseconds (ds).
  double get inDeciseconds => getValue(TimeUnit.decisecond);

  /// Returns the time value in Decaseconds (das).
  double get inDecaseconds => getValue(TimeUnit.decasecond);

  /// Returns the time value in Hectoseconds (hs).
  double get inHectoseconds => getValue(TimeUnit.hectosecond);

  /// Returns the time value in Kiloseconds (ks).
  double get inKiloseconds => getValue(TimeUnit.kilosecond);

  /// Returns the time value in Megaseconds (Ms).
  double get inMegaseconds => getValue(TimeUnit.megasecond);

  /// Returns the time value in Gigaseconds (Gs).
  double get inGigaseconds => getValue(TimeUnit.gigasecond);

  /// Returns the time value in Minutes (min).
  double get inMinutes => getValue(TimeUnit.minute);

  /// Returns the time value in Hours (h).
  double get inHours => getValue(TimeUnit.hour);

  /// Returns the time value in Days (d).
  double get inDays => getValue(TimeUnit.day);

  /// Returns the time value in Weeks (wk).
  double get inWeeks => getValue(TimeUnit.week);

  /// Returns the time value in Fortnights (fn).
  double get inFortnights => getValue(TimeUnit.fortnight);

  /// Returns the time value in Months (mo).
  double get inMonths => getValue(TimeUnit.month);

  /// Returns the time value in Years (yr).
  double get inYears => getValue(TimeUnit.year);

  /// Returns the time value in Decades (dec).
  double get inDecades => getValue(TimeUnit.decade);

  /// Returns the time value in Centuries (c).
  double get inCenturies => getValue(TimeUnit.century);

  /// Returns a Time representing this time in Seconds (s).
  Time get asSeconds => convertTo(TimeUnit.second);

  /// Returns a Time representing this time in Microseconds (Œºs).
  Time get asMicroseconds => convertTo(TimeUnit.microsecond);

  /// Returns a Time representing this time in Nanoseconds (ns).
  Time get asNanoseconds => convertTo(TimeUnit.nanosecond);

  /// Returns a Time representing this time in Picoseconds (ps).
  Time get asPicoseconds => convertTo(TimeUnit.picosecond);

  /// Returns a Time representing this time in Milliseconds (ms).
  Time get asMilliseconds => convertTo(TimeUnit.millisecond);

  /// Returns a Time representing this time in Centiseconds (cs).
  Time get asCentiseconds => convertTo(TimeUnit.centisecond);

  /// Returns a Time representing this time in Deciseconds (ds).
  Time get asDeciseconds => convertTo(TimeUnit.decisecond);

  /// Returns a Time representing this time in Decaseconds (das).
  Time get asDecaseconds => convertTo(TimeUnit.decasecond);

  /// Returns a Time representing this time in Hectoseconds (hs).
  Time get asHectoseconds => convertTo(TimeUnit.hectosecond);

  /// Returns a Time representing this time in Kiloseconds (ks).
  Time get asKiloseconds => convertTo(TimeUnit.kilosecond);

  /// Returns a Time representing this time in Megaseconds (Ms).
  Time get asMegaseconds => convertTo(TimeUnit.megasecond);

  /// Returns a Time representing this time in Gigaseconds (Gs).
  Time get asGigaseconds => convertTo(TimeUnit.gigasecond);

  /// Returns a Time representing this time in Fortnights (fn).
  Time get asFortnights => convertTo(TimeUnit.fortnight);

  /// Returns a Time representing this time in Decades (dec).
  Time get asDecades => convertTo(TimeUnit.decade);

  /// Returns a Time representing this time in Centuries (c).
  Time get asCenturies => convertTo(TimeUnit.century);

  /// Returns a Time representing this time in Minutes (min).
  Time get asMinutes => convertTo(TimeUnit.minute);

  /// Returns a Time representing this time in Hours (h).
  Time get asHours => convertTo(TimeUnit.hour);

  /// Returns a Time representing this time in Days (d).
  Time get asDays => convertTo(TimeUnit.day);

  /// Returns a Time representing this time in Weeks (wk).
  Time get asWeeks => convertTo(TimeUnit.week);

  /// Returns a Time representing this time in Months (mo).
  Time get asMonths => convertTo(TimeUnit.month);

  /// Returns a Time representing this time in Years (yr).
  Time get asYears => convertTo(TimeUnit.year);
}

/// Provides convenient factory methods for creating [Time] instances from [num].
extension TimeCreation on num {
  /// Creates a [Time] instance representing this numerical value in Seconds (s).
  Time get seconds => Time(toDouble(), TimeUnit.second);

  /// Creates a [Time] instance representing this numerical value in Microseconds (Œºs).
  Time get microseconds => Time(toDouble(), TimeUnit.microsecond);

  /// Creates a [Time] instance representing this numerical value in Nanoseconds (ns).
  Time get nanoseconds => Time(toDouble(), TimeUnit.nanosecond);

  /// Creates a [Time] instance representing this numerical value in Picoseconds (ps).
  Time get picoseconds => Time(toDouble(), TimeUnit.picosecond);

  /// Creates a [Time] instance representing this numerical value in Milliseconds (ms).
  Time get milliseconds => Time(toDouble(), TimeUnit.millisecond);

  /// Creates a [Time] instance from this numerical value in Centiseconds (cs).
  Time get cs => Time(toDouble(), TimeUnit.centisecond);

  /// Creates a [Time] instance from this numerical value in Deciseconds (ds).
  Time get ds => Time(toDouble(), TimeUnit.decisecond);

  /// Creates a [Time] instance from this numerical value in Decaseconds (das).
  Time get das => Time(toDouble(), TimeUnit.decasecond);

  /// Creates a [Time] instance from this numerical value in Hectoseconds (hs).
  Time get hs => Time(toDouble(), TimeUnit.hectosecond);

  /// Creates a [Time] instance from this numerical value in Kiloseconds (ks).
  Time get kiloS => Time(toDouble(), TimeUnit.kilosecond);

  /// Creates a [Time] instance from this numerical value in Megaseconds (Ms).
  Time get megaS => Time(toDouble(), TimeUnit.megasecond);

  /// Creates a [Time] instance from this numerical value in Gigaseconds (Gs).
  Time get gigaS => Time(toDouble(), TimeUnit.gigasecond);

  /// Creates a [Time] instance representing this numerical value in Minutes (min).
  Time get minutes => Time(toDouble(), TimeUnit.minute);

  /// Creates a [Time] instance representing this numerical value in Hours (h).
  Time get hours => Time(toDouble(), TimeUnit.hour);

  /// Creates a [Time] instance representing this numerical value in Days (d).
  Time get days => Time(toDouble(), TimeUnit.day);

  /// Creates a [Time] instance representing this numerical value in Weeks (wk).
  Time get weeks => Time(toDouble(), TimeUnit.week);

  /// Creates a [Time] instance from this numerical value in Fortnights (fn).
  Time get fortnights => Time(toDouble(), TimeUnit.fortnight);

  /// Creates a [Time] instance representing this numerical value in Months (mo).
  Time get months => Time(toDouble(), TimeUnit.month);

  /// Creates a [Time] instance representing this numerical value in Years (yr).
  Time get years => Time(toDouble(), TimeUnit.year);

  /// Creates a [Time] instance from this numerical value in Decades (dec).
  Time get decades => Time(toDouble(), TimeUnit.decade);

  /// Creates a [Time] instance from this numerical value in Centuries (c).
  /// Note: `.c` is avoided due to conflict with 'centi' prefix and Celsius.
  Time get centuries => Time(toDouble(), TimeUnit.century);

  // Short aliases for common units
  /// Creates a [Time] instance representing this numerical value in Seconds (s).
  /// Alias for `seconds`.
  Time get s => Time(toDouble(), TimeUnit.second);

  /// Creates a [Time] instance representing this numerical value in Microseconds (Œºs).
  /// Alias for `microseconds`.
  Time get us => Time(toDouble(), TimeUnit.microsecond);

  /// Creates a [Time] instance representing this numerical value in Nanoseconds (ns).
  /// Alias for `nanoseconds`.
  Time get ns => Time(toDouble(), TimeUnit.nanosecond);

  /// Creates a [Time] instance representing this numerical value in Picoseconds (ps).
  /// Alias for `picoseconds`.
  Time get ps => Time(toDouble(), TimeUnit.picosecond);

  /// Creates a [Time] instance representing this numerical value in Milliseconds (ms).
  /// Alias for `milliseconds`.
  Time get ms => Time(toDouble(), TimeUnit.millisecond);

  /// Creates a [Time] instance representing this numerical value in Minutes (min).
  /// Alias for `minutes`. Note: 'm' is used for meters, so 'min' is better for time.
  Time get min => Time(toDouble(), TimeUnit.minute);

  /// Creates a [Time] instance representing this numerical value in Hours (h).
  /// Alias for `hours`.
  Time get h => Time(toDouble(), TimeUnit.hour);

  /// Creates a [Time] instance representing this numerical value in Days (d).
  /// Alias for `days`.
  Time get d => Time(toDouble(), TimeUnit.day);

  /// Creates a [Time] instance representing this numerical value in Weeks (wk).
  /// Alias for `weeks`.
  Time get wk => Time(toDouble(), TimeUnit.week);

  /// Creates a [Time] instance representing this numerical value in Months (mo).
  /// Alias for `months`.
  Time get mo => Time(toDouble(), TimeUnit.month);

  /// Creates a [Time] instance representing this numerical value in Years (yr).
  /// Alias for `years`.
  Time get yr => Time(toDouble(), TimeUnit.year);
}

<!-- END FILE: [v0.5.0] lib/src/units/time/time_extensions.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/time/time_factors.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

/// Defines base conversion factors for various time units relative to Second (s).
///
/// These constants are based on standard definitions.
class TimeFactors {
  // The base unit for internal calculations is Second.
  // Factors represent: 1 [Unit] = X [Seconds]

  /// Seconds per Gigasecond: 1 Gs = 1e9 seconds.
  static const double secondsPerGigasecond = 1e9;

  /// Seconds per Megasecond: 1 Ms = 1e6 seconds.
  static const double secondsPerMegasecond = 1e6;

  /// Seconds per Kilosecond: 1 ks = 1000.0 seconds.
  static const double secondsPerKilosecond = 1000.0;

  /// Seconds per Hectosecond: 1 hs = 100.0 seconds.
  static const double secondsPerHectosecond = 100.0;

  /// Seconds per Decasecond: 1 das = 10.0 seconds.
  static const double secondsPerDecasecond = 10.0;

  /// Seconds per Microsecond: 1 microsecond = 1e-6 seconds.
  static const double secondsPerMicrosecond = 1e-6;

  /// Seconds per Nanosecond: 1 nanosecond = 1e-9 seconds.
  static const double secondsPerNanosecond = 1e-9;

  /// Seconds per Picosecond: 1 picosecond = 1e-12 seconds.
  static const double secondsPerPicosecond = 1e-12;

  /// Seconds per Millisecond: 1 millisecond = 0.001 seconds.
  static const double secondsPerMillisecond = 0.001;

  /// Seconds per Centisecond: 1 cs = 0.01 seconds.
  static const double secondsPerCentisecond = 0.01;

  /// Seconds per Decisecond: 1 ds = 0.1 seconds.
  static const double secondsPerDecisecond = 0.1;

  /// Seconds per Minute: 1 minute = 60.0 seconds.
  static const double secondsPerMinute = 60.0;

  /// Seconds per Hour: 1 hour = 3600.0 seconds (60 minutes * 60 seconds).
  static const double secondsPerHour = 3600.0;

  /// Seconds per Day: 1 day = 86400.0 seconds (24 hours * 3600 seconds/hour).
  static const double secondsPerDay = 86400.0;

  /// Seconds per Week: 1 week = 604800.0 seconds (7 days * 86400 seconds/day).
  static const double secondsPerWeek = 604800.0;

  /// Seconds per Fortnight: 1 fortnight = 1209600.0 seconds (14 days).
  static const double secondsPerFortnight = secondsPerDay * 14.0;

  /// Seconds per Month: 1 month ‚âà 2629800.0 seconds.
  /// Based on average month length: 365.25 days / 12 months = 30.4375 days/month.
  static const double secondsPerMonth = 2629800.0;

  /// Seconds per Year: 1 year = 31557600.0 seconds.
  /// Based on Julian year: 365.25 days * 24 hours/day * 3600 seconds/hour.
  static const double secondsPerYear = 31557600.0;

  /// Seconds per Decade: 1 decade = 315576000.0 seconds (10 Julian years).
  static const double secondsPerDecade = secondsPerYear * 10.0;

  /// Seconds per Century: 1 century = 3155760000.0 seconds (100 Julian years).
  static const double secondsPerCentury = secondsPerYear * 100.0;
}

<!-- END FILE: [v0.5.0] lib/src/units/time/time_factors.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/src/units/time/time_unit.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'time_factors.dart';

/// Represents units of time.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each time unit.
/// All conversion factors are pre-calculated in the constructor relative to Second (s).
enum TimeUnit implements Unit<TimeUnit> {
  /// Second (s), the SI base unit of time.
  second(1.0, 's'),

  /// Microsecond (Œºs), equal to 1e-6 seconds.
  microsecond(TimeFactors.secondsPerMicrosecond, 'Œºs'),

  /// Nanosecond (ns), equal to 1e-9 seconds.
  nanosecond(TimeFactors.secondsPerNanosecond, 'ns'),

  /// Picosecond (ps), equal to 1e-12 seconds.
  picosecond(TimeFactors.secondsPerPicosecond, 'ps'),

  /// Millisecond (ms), equal to 0.001 seconds.
  millisecond(TimeFactors.secondsPerMillisecond, 'ms'),

  /// Centisecond (cs), equal to 0.01 seconds.
  centisecond(TimeFactors.secondsPerCentisecond, 'cs'),

  /// Decisecond (ds), equal to 0.1 seconds.
  decisecond(TimeFactors.secondsPerDecisecond, 'ds'),

  /// Decasecond (das), equal to 10 seconds.
  decasecond(TimeFactors.secondsPerDecasecond, 'das'),

  /// Hectosecond (hs), equal to 100 seconds.
  hectosecond(TimeFactors.secondsPerHectosecond, 'hs'),

  /// Kilosecond (ks), equal to 1000 seconds.
  kilosecond(TimeFactors.secondsPerKilosecond, 'ks'),

  /// Megasecond (Ms), equal to 1e6 seconds.
  megasecond(TimeFactors.secondsPerMegasecond, 'Ms'),

  /// Gigasecond (Gs), equal to 1e9 seconds.
  gigasecond(TimeFactors.secondsPerGigasecond, 'Gs'),

  /// Minute (min), equal to 60 seconds.
  minute(TimeFactors.secondsPerMinute, 'min'),

  /// Hour (h), equal to 3600 seconds.
  hour(TimeFactors.secondsPerHour, 'h'),

  /// Day (d), equal to 86400 seconds.
  day(TimeFactors.secondsPerDay, 'd'),

  /// Week (wk), equal to 604800 seconds (7 days).
  week(TimeFactors.secondsPerWeek, 'wk'),

  /// Fortnight (fn), equal to 2 weeks or 14 days.
  fortnight(TimeFactors.secondsPerFortnight, 'fn'),

  /// Month (mo), equal to approximately 2629746 seconds.
  /// Based on average month length (365.25 days / 12).
  month(TimeFactors.secondsPerMonth, 'mo'),

  /// Year (yr), equal to 31557600 seconds.
  /// Based on Julian year (365.25 days).
  year(TimeFactors.secondsPerYear, 'yr'),

  /// Decade (dec), equal to 10 Julian years.
  decade(TimeFactors.secondsPerDecade, 'dec'),

  /// Century (c), equal to 100 Julian years.
  century(TimeFactors.secondsPerCentury, 'c');

  /// Constant constructor for enum members.
  ///
  /// [_toSecondFactor] is the factor to convert from this unit to the base unit (Second).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `TimeUnit`.
  const TimeUnit(this._toSecondFactor, this.symbol)
      : _factorToSecond = _toSecondFactor / 1.0, // Second's _toSecondFactor is 1.0
        _factorToMicrosecond = _toSecondFactor / TimeFactors.secondsPerMicrosecond,
        _factorToNanosecond = _toSecondFactor / TimeFactors.secondsPerNanosecond,
        _factorToPicosecond = _toSecondFactor / TimeFactors.secondsPerPicosecond,
        _factorToMillisecond = _toSecondFactor / TimeFactors.secondsPerMillisecond,
        _factorToCentisecond = _toSecondFactor / TimeFactors.secondsPerCentisecond,
        _factorToDecisecond = _toSecondFactor / TimeFactors.secondsPerDecisecond,
        _factorToDecasecond = _toSecondFactor / TimeFactors.secondsPerDecasecond,
        _factorToHectosecond = _toSecondFactor / TimeFactors.secondsPerHectosecond,
        _factorToKilosecond = _toSecondFactor / TimeFactors.secondsPerKilosecond,
        _factorToMegasecond = _toSecondFactor / TimeFactors.secondsPerMegasecond,
        _factorToGigasecond = _toSecondFactor / TimeFactors.secondsPerGigasecond,
        _factorToMinute = _toSecondFactor / TimeFactors.secondsPerMinute,
        _factorToHour = _toSecondFactor / TimeFactors.secondsPerHour,
        _factorToDay = _toSecondFactor / TimeFactors.secondsPerDay,
        _factorToWeek = _toSecondFactor / TimeFactors.secondsPerWeek,
        _factorToFortnight = _toSecondFactor / TimeFactors.secondsPerFortnight,
        _factorToMonth = _toSecondFactor / TimeFactors.secondsPerMonth,
        _factorToYear = _toSecondFactor / TimeFactors.secondsPerYear,
        _factorToDecade = _toSecondFactor / TimeFactors.secondsPerDecade,
        _factorToCentury = _toSecondFactor / TimeFactors.secondsPerCentury;

  /// The factor to convert a value from this unit to the base unit (Second).
  /// After constructor initialization, its value is primarily baked into
  /// the specific _factorToXxx fields for direct inter-unit conversions.
  /// It's generally not accessed directly by methods outside this enum's constructor
  /// but is crucial for deriving the pre-calculated factors.
  // ignore: unused_field
  final double _toSecondFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToSecond;
  final double _factorToMicrosecond;
  final double _factorToNanosecond;
  final double _factorToPicosecond;
  final double _factorToMillisecond;
  final double _factorToCentisecond;
  final double _factorToDecisecond;
  final double _factorToDecasecond;
  final double _factorToHectosecond;
  final double _factorToKilosecond;
  final double _factorToMegasecond;
  final double _factorToGigasecond;
  final double _factorToMinute;
  final double _factorToHour;
  final double _factorToDay;
  final double _factorToWeek;
  final double _factorToFortnight;
  final double _factorToMonth;
  final double _factorToYear;
  final double _factorToDecade;
  final double _factorToCentury;

  /// Returns the direct conversion factor to convert a value from this [TimeUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(TimeUnit targetUnit) {
    switch (targetUnit) {
      case TimeUnit.second:
        return _factorToSecond;
      case TimeUnit.microsecond:
        return _factorToMicrosecond;
      case TimeUnit.nanosecond:
        return _factorToNanosecond;
      case TimeUnit.picosecond:
        return _factorToPicosecond;
      case TimeUnit.millisecond:
        return _factorToMillisecond;
      case TimeUnit.centisecond:
        return _factorToCentisecond;
      case TimeUnit.decisecond:
        return _factorToDecisecond;
      case TimeUnit.decasecond:
        return _factorToDecasecond;
      case TimeUnit.hectosecond:
        return _factorToHectosecond;
      case TimeUnit.kilosecond:
        return _factorToKilosecond;
      case TimeUnit.megasecond:
        return _factorToMegasecond;
      case TimeUnit.gigasecond:
        return _factorToGigasecond;
      case TimeUnit.minute:
        return _factorToMinute;
      case TimeUnit.hour:
        return _factorToHour;
      case TimeUnit.day:
        return _factorToDay;
      case TimeUnit.week:
        return _factorToWeek;
      case TimeUnit.fortnight:
        return _factorToFortnight;
      case TimeUnit.month:
        return _factorToMonth;
      case TimeUnit.year:
        return _factorToYear;
      case TimeUnit.decade:
        return _factorToDecade;
      case TimeUnit.century:
        return _factorToCentury;
    }
  }
}

<!-- END FILE: [v0.5.0] lib/src/units/time/time_unit.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/temperature.dart -->
/// Provides type-safe units for Temperature.
///
/// Import this file to use Temperature quantities and their extensions on `num`
/// (like `25.celsius`, `300.kelvin`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/temperature/temperature.dart';
export 'src/units/temperature/temperature_extensions.dart';
export 'src/units/temperature/temperature_unit.dart';

<!-- END FILE: [v0.5.0] lib/temperature.dart -->

<!-- BEGIN FILE: [v0.5.0] lib/time.dart -->
/// Provides type-safe units for Time.
///
/// Import this file to use Time quantities and their extensions on `num`
/// (like `60.s`, `1.5.h`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/time/time.dart';
export 'src/units/time/time_extensions.dart';
export 'src/units/time/time_unit.dart';

<!-- END FILE: [v0.5.0] lib/time.dart -->

<!-- BEGIN FILE: [v0.5.0] example/analysis_options.yaml -->
include: package:very_good_analysis/analysis_options.yaml

formatter:
  page_width: 100
#  trailing_commas: preserve

analyzer:
  errors:
    unused_import: warning
    todo: ignore

linter:
  rules:
    # Allow relative imports for files within the same package
    always_use_package_imports: false
    # Prefer using relative imports within the same package
    prefer_relative_imports: true
    # Allow lines to exceed 80 characters
    lines_longer_than_80_chars: false
    # Prefer using const constructors where possible
    prefer_const_constructors: true
    # Prefer declaring local variables as final if they are not reassigned
    prefer_final_locals: true
    # Allow mutable literal lists/maps/sets even if they could be const
    prefer_const_literals_to_create_immutables: false
    # Allow explicitly typing closure parameters
    avoid_types_on_closure_parameters: false
    # Use trailing commas for all parameter lists and argument lists.
    require_trailing_commas: true
    # Use enums rather than classes that behave like enums.
    use_enums: true
    # Allow using print() for debugging purposes
    avoid_print: false
<!-- END FILE: [v0.5.0] example/analysis_options.yaml -->

<!-- BEGIN FILE: [v0.5.0] example/lib/constants_example.dart -->
import 'dart:math' as math;

import 'package:quantify/constants.dart';
import 'package:quantify/quantify.dart';

/// Comprehensive example demonstrating the use of physical, astronomical,
/// and engineering constants from the quantify package.
void main() {
  print('=== Quantify Constants Library Demonstration ===\n');

  physicsExamples();
  astronomyExamples();
  engineeringExamples();
  practicalCalculations();
}

/// Demonstrates the use of physical constants and calculations
void physicsExamples() {
  print('--- PHYSICS CONSTANTS AND CALCULATIONS ---');

  // Fundamental constants
  print('Speed of light: ${PhysicalConstants.speedOfLightPerSecond}');
  print(
    'Electron mass: ${PhysicalConstants.electronMass.toString(targetUnit: MassUnit.atomicMassUnit, fractionDigits: 6)}',
  );
  print(
    'Proton mass: ${PhysicalConstants.protonMass.toString(targetUnit: MassUnit.atomicMassUnit, fractionDigits: 6)}',
  );
  print(
    'Bohr radius: ${PhysicalConstants.bohrRadius.toString(targetUnit: LengthUnit.angstrom, fractionDigits: 2)}',
  );

  // Quantum mechanics calculations
  print('\n--- Quantum Mechanics ---');

  // Photon energy calculation
  final blueLight = 450.0.nm; // Blue light wavelength
  final redLight = 650.0.nm; // Red light wavelength
  final bluePhotonEnergy = PhysicalConstants.photonEnergy(blueLight);
  final redPhotonEnergy = PhysicalConstants.photonEnergy(redLight);

  print(
    'Blue light ($blueLight): ${(bluePhotonEnergy / PhysicalConstants.electronVoltInJoules).toStringAsFixed(2)} eV',
  );
  print(
    'Red light ($redLight): ${(redPhotonEnergy / PhysicalConstants.electronVoltInJoules).toStringAsFixed(2)} eV',
  );

  // De Broglie wavelength
  const electronVelocity = 1.0e6; // 1000 km/s
  final electronWavelength = PhysicalConstants.deBroglieWavelength(
    PhysicalConstants.electronMass,
    electronVelocity,
  );
  print(
    'Electron wavelength at ${electronVelocity.toStringAsExponential(1)} m/s: ${electronWavelength.toString(targetUnit: LengthUnit.angstrom, fractionDigits: 3)}',
  );

  // Mass-energy equivalence
  final carbonAtom = 12.0.u;
  final carbonRestEnergy = PhysicalConstants.massEnergyEquivalence(carbonAtom);
  print(
    'Carbon-12 rest energy: ${(carbonRestEnergy / PhysicalConstants.electronVoltInJoules / 1e6).toStringAsFixed(1)} MeV',
  );

  // Thermal energy
  final roomTemp = 295.0.kelvin;
  final thermalEnergy = PhysicalConstants.thermalEnergy(roomTemp);
  print(
    'Thermal energy at room temperature: ${(thermalEnergy / PhysicalConstants.electronVoltInJoules * 1000).toStringAsFixed(1)} meV',
  );

  print('');
}

void astronomyExamples() {
  print('--- ASTRONOMY CONSTANTS AND CALCULATIONS ---');

  // Solar system
  print(
    'Solar mass: ${AstronomicalConstants.solarMass.toString(targetUnit: MassUnit.kilogram, fractionDigits: 2)}',
  );
  print(
    'Earth mass: ${AstronomicalConstants.earthMass.toString(targetUnit: MassUnit.kilogram, fractionDigits: 2)}',
  );
  print(
    'Earth radius: ${AstronomicalConstants.earthRadius.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 1)}',
  );
  print(
    'Earth-Moon distance: ${AstronomicalConstants.earthMoonDistance.toString(targetUnit: LengthUnit.kilometer)}',
  );

  // Planetary comparisons
  print('\n--- Planetary Mass Comparisons ---');
  final planets = [
    ('Mercury', AstronomicalConstants.mercuryMass),
    ('Venus', AstronomicalConstants.venusMass),
    ('Earth', AstronomicalConstants.earthMass),
    ('Mars', AstronomicalConstants.marsMass),
    ('Jupiter', AstronomicalConstants.jupiterMass),
    ('Saturn', AstronomicalConstants.saturnMass),
  ];

  for (final (name, mass) in planets) {
    final earthMasses = mass.getValue(MassUnit.kilogram) /
        AstronomicalConstants.earthMass.getValue(MassUnit.kilogram);
    print('$name: ${earthMasses.toStringAsFixed(3)} Earth masses');
  }

  // Orbital mechanics calculations
  print('\n--- Orbital Mechanics ---');

  // Earth's surface gravity
  final earthSurfaceGravity = AstronomicalConstants.surfaceGravity(
    AstronomicalConstants.earthMass,
    AstronomicalConstants.earthRadius,
  );
  print('Earth surface gravity: ${earthSurfaceGravity.toStringAsFixed(2)} m/s¬≤');

  // Escape velocity from Earth
  final earthEscapeVel = AstronomicalConstants.escapeVelocity(
    AstronomicalConstants.earthMass,
    AstronomicalConstants.earthRadius,
  );
  print('Earth escape velocity: ${(earthEscapeVel / 1000).toStringAsFixed(2)} km/s');

  // ISS orbital velocity (400 km altitude)
  final issAltitude = 400.km;
  final issOrbitalRadius = AstronomicalConstants.earthRadius + issAltitude;
  final issVelocity = AstronomicalConstants.orbitalVelocity(
    AstronomicalConstants.earthMass,
    issOrbitalRadius,
  );
  print('ISS orbital velocity: ${(issVelocity / 1000).toStringAsFixed(2)} km/s');

  // Black hole calculations
  print('\n--- Black Holes ---');
  final solarMassBlackHole = AstronomicalConstants.schwarzschildRadius(
    AstronomicalConstants.solarMass,
  );
  print(
    'Solar mass black hole radius: ${solarMassBlackHole.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2)}',
  );

  // Galactic scales
  print('\n--- Galactic and Cosmological ---');
  print(
    'Distance to galactic center: ${AstronomicalConstants.galacticCenterDistance.toString(targetUnit: LengthUnit.lightYear, fractionDigits: 0)}',
  );
  print(
    'Observable universe radius: ${AstronomicalConstants.observableUniverseRadius.toString(targetUnit: LengthUnit.lightYear, fractionDigits: 1)}',
  );
  print(
    'Age of universe: ${AstronomicalConstants.ageOfUniverse.toString(targetUnit: TimeUnit.year, fractionDigits: 1)}',
  );

  print('');
}

/// Demonstrates the use of engineering constants and practical calculations
void engineeringExamples() {
  print('--- ENGINEERING CONSTANTS AND APPLICATIONS ---');

  // Standard conditions
  print(
    'Standard temperature: ${EngineeringConstants.standardTemperature.toString(targetUnit: TemperatureUnit.celsius, fractionDigits: 2)}',
  );
  print(
    'Standard pressure: ${EngineeringConstants.standardPressure.toString(targetUnit: PressureUnit.atmosphere, fractionDigits: 5)}',
  );
  print(
    'Room temperature: ${EngineeringConstants.roomTemperature.toString(targetUnit: TemperatureUnit.celsius, fractionDigits: 1)}',
  );

  // Material properties
  print('\n--- Material Properties ---');
  print('Water density at STP: ${EngineeringConstants.waterDensitySTP} kg/m¬≥');
  print('Air density at STP: ${EngineeringConstants.airDensitySTP} kg/m¬≥');
  print('Sound speed in air (20¬∞C): ${EngineeringConstants.soundSpeedAir20C} m/s');
  print('Sound speed in water (25¬∞C): ${EngineeringConstants.soundSpeedWater25C} m/s');

  // Thermal properties
  print('\n--- Thermal Properties ---');
  print('Copper thermal conductivity: ${EngineeringConstants.copperThermalConductivity} W/(m‚ãÖK)');
  print('Steel thermal conductivity: ${EngineeringConstants.steelThermalConductivity} W/(m‚ãÖK)');
  print('Water specific heat: ${EngineeringConstants.waterSpecificHeat} J/(kg‚ãÖK)');
  print(
    'Water latent heat of vaporization: ${(EngineeringConstants.waterLatentHeatVaporization / 1e6).toStringAsFixed(2)} MJ/kg',
  );

  // Mechanical properties
  print('\n--- Mechanical Properties ---');
  print(
    "Steel Young's modulus: ${(EngineeringConstants.steelYoungsModulus / 1e9).toStringAsFixed(0)} GPa",
  );
  print(
    "Aluminum Young's modulus: ${(EngineeringConstants.aluminumYoungsModulus / 1e9).toStringAsFixed(0)} GPa",
  );
  print(
    'Steel tensile strength: ${(EngineeringConstants.steelTensileStrength / 1e6).toStringAsFixed(0)} MPa',
  );
  print(
    'Steel thermal expansion: ${(EngineeringConstants.steelThermalExpansion * 1e6).toStringAsFixed(1)} Œºm/(m‚ãÖK)',
  );

  // Electrical properties
  print('\n--- Electrical Properties ---');
  print(
    'Copper resistivity: ${(EngineeringConstants.copperResistivity * 1e8).toStringAsFixed(2)} √ó 10‚Åª‚Å∏ Œ©‚ãÖm',
  );
  print(
    'Silicon resistivity: ${(EngineeringConstants.siliconResistivity / 1e3).toStringAsFixed(1)} kŒ©‚ãÖm',
  );
  print('Water dielectric constant: ${EngineeringConstants.waterDielectricConstant}');

  print('');
}

/// Demonstrates practical engineering calculations using constants
void practicalCalculations() {
  print('--- PRACTICAL ENGINEERING CALCULATIONS ---');

  // Thermal expansion calculation
  print('--- Thermal Expansion ---');
  final steelBridge = 100.0.m;
  const summerWinter = 50.0; // Celsius degrees temperature difference
  final thermalExpansion = EngineeringConstants.thermalExpansion(
    steelBridge,
    EngineeringConstants.steelThermalExpansion,
    const Temperature(summerWinter, TemperatureUnit.kelvin),
  );
  print(
    '100m steel bridge thermal expansion (50¬∞C change): ${thermalExpansion.toString(targetUnit: LengthUnit.centimeter, fractionDigits: 1)}',
  );

  // Electrical resistance calculation
  print('\n--- Electrical Resistance ---');
  final copperWire = 100.0.m; // length
  final wireArea = math.pi * math.pow(1e-3, 2); // 1mm radius = œÄ mm¬≤ area
  final wireResistance = EngineeringConstants.electricalResistance(
    EngineeringConstants.copperResistivity,
    copperWire,
    wireArea,
  );
  print(
    '100m copper wire (2mm diameter) resistance: ${(wireResistance * 1000).toStringAsFixed(1)} mŒ©',
  );

  // Heat transfer calculation
  print('\n--- Heat Transfer ---');
  final wallThickness = 20.0.cm;
  const wallArea = 10.0; // m¬≤
  const indoorOutdoorTempDiff = 25.0; // Celsius degrees
  final heatTransferRate = EngineeringConstants.conductiveHeatTransfer(
    EngineeringConstants.concreteYoungsModulus, // Using as thermal conductivity placeholder
    wallArea,
    wallThickness,
    const Temperature(indoorOutdoorTempDiff, TemperatureUnit.kelvin),
  );
  print(
    'Heat transfer through 20cm concrete wall (25¬∞C diff): ${(heatTransferRate / 1000).toStringAsFixed(1)} kW',
  );

  // Fluid mechanics
  print('\n--- Fluid Mechanics ---');
  const pipeVelocity = 2.0; // m/s
  final pipeDiameter = 10.0.cm;
  const waterKinematicViscosity =
      EngineeringConstants.waterViscosity20C / EngineeringConstants.waterDensitySTP;
  final reynoldsNumber = EngineeringConstants.reynoldsNumberPipe(
    pipeVelocity,
    pipeDiameter,
    waterKinematicViscosity,
  );
  print('Water flow in 10cm pipe at 2 m/s - Reynolds number: ${reynoldsNumber.toStringAsFixed(0)}');
  if (reynoldsNumber > EngineeringConstants.turbulentReynoldsNumber) {
    print('Flow is turbulent');
  } else if (reynoldsNumber < EngineeringConstants.laminarReynoldsNumber) {
    print('Flow is laminar');
  } else {
    print('Flow is transitional');
  }

  // Mechanical stress analysis
  print('\n--- Mechanical Stress ---');
  const appliedForce = 50000.0; // 50 kN
  const beamCrossSection = 0.01; // m¬≤ (100 cm¬≤)
  final stress = EngineeringConstants.mechanicalStress(appliedForce, beamCrossSection);
  final strain =
      EngineeringConstants.mechanicalStrain(stress, EngineeringConstants.steelYoungsModulus);

  print('50 kN force on 100 cm¬≤ steel beam:');
  print('  Stress: ${(stress / 1e6).toStringAsFixed(1)} MPa');
  print('  Strain: ${(strain * 1e6).toStringAsFixed(0)} microstrain');
  print(
    '  Safety factor: ${(EngineeringConstants.steelYieldStrength / stress).toStringAsFixed(1)}',
  );

  // Astronomical engineering
  print('\n--- Space Engineering ---');

  // Satellite orbital period
  final geostationary = 35786.km; // Geostationary orbit altitude above Earth surface
  final geoOrbitRadius = AstronomicalConstants.earthRadius + geostationary;
  final geoVelocity = AstronomicalConstants.orbitalVelocity(
    AstronomicalConstants.earthMass,
    geoOrbitRadius,
  );
  final geoCircumference = 2 * math.pi * geoOrbitRadius.getValue(LengthUnit.meter);
  final geoPeriod = geoCircumference / geoVelocity; // seconds

  print('Geostationary satellite:');
  print('  Altitude: ${geostationary.toString(targetUnit: LengthUnit.kilometer)}');
  print('  Orbital velocity: ${(geoVelocity / 1000).toStringAsFixed(2)} km/s');
  print('  Orbital period: ${(geoPeriod / 3600).toStringAsFixed(1)} hours');

  // Rocket escape velocity
  final rocketMass = 500.t; // Heavy rocket
  final rocketEnergy = PhysicalConstants.massEnergyEquivalence(rocketMass);
  final escapeEnergy = 0.5 *
      rocketMass.getValue(MassUnit.kilogram) *
      math.pow(AstronomicalConstants.earthEscapeVelocity, 2);

  print('500-tonne rocket escape energy: ${(escapeEnergy / 1e9).toStringAsFixed(1)} GJ');
  print(
    'Fraction of rest mass energy: ${(escapeEnergy / rocketEnergy * 1e9).toStringAsFixed(1)} √ó 10‚Åª‚Åπ',
  );

  // Fusion energy comparison
  final deuteriumMass = 2.014.u;
  final tritiumMass = 3.016.u;
  final heliumMass = 4.003.u;
  final neutronMass = 1.009.u;
  final fusionDefect = (deuteriumMass + tritiumMass) -
      (heliumMass + Mass(neutronMass.value, MassUnit.atomicMassUnit));
  final fusionEnergy = PhysicalConstants.massEnergyEquivalence(fusionDefect);

  print('\nDeuterium-Tritium fusion:');
  print(
    '  Mass defect: ${fusionDefect.toString(targetUnit: MassUnit.atomicMassUnit, fractionDigits: 5)}',
  );
  print(
    '  Energy released: ${(fusionEnergy / PhysicalConstants.electronVoltInJoules / 1e6).toStringAsFixed(1)} MeV',
  );
  print(
    '  Energy per gram of fuel: ${(fusionEnergy * PhysicalConstants.avogadroConstant / 5.0 / 1e12).toStringAsFixed(0)} TJ/g',
  );

  print('\n=== End of Constants Demonstration ===');
}

<!-- END FILE: [v0.5.0] example/lib/constants_example.dart -->

<!-- BEGIN FILE: [v0.5.0] example/lib/main.dart -->
import 'package:intl/intl.dart'; // For locale-specific number formatting
import 'package:quantify/quantify.dart';

void main() {
  print('--- Quantify CLI Example ---');

  // 1. Create and convert lengths
  print('\n--- Length ---');
  final pathA = 1500.m; // Using .m as requested
  final pathB = 2.5.km;

  print('Path A: $pathA'); // Default toString
  print('Path A in Kilometers: ${pathA.inKm} km');
  print(
    'Path A (formatted): ${pathA.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 1)}',
  );
  print(
    'Path B in Miles: ${pathB.toString(targetUnit: LengthUnit.mile, fractionDigits: 2)}',
  );

  // 2. Arithmetic with lengths
  final totalDistance = pathA + pathB; // pathB is automatically converted to meters
  print('Total Distance: ${totalDistance.toString(fractionDigits: 0)}');
  print(
    'Total Distance in Yards: ${totalDistance.toString(targetUnit: LengthUnit.yard, fractionDigits: 0, unitSymbolSeparator: '\u00A0')}',
  );

  final scaledDistance = pathA * 3;
  print('Path A scaled by 3: $scaledDistance');

  // 3. Times
  print('\n--- Time ---');
  final duration1 = 90.minutes;
  final duration2 = 0.5.hours;

  print('Duration 1: $duration1');
  print('Duration 1 in Hours: ${duration1.inHours} h');
  print('Duration 2: ${duration2.toString(targetUnit: TimeUnit.minute)}');

  final totalTime = duration1 + duration2; // 90 min + 30 min = 120 min
  print('Total Time: ${totalTime.toString(targetUnit: TimeUnit.hour)}'); // "2.0 h"

  // 4. Temperatures
  print('\n--- Temperature ---');
  final roomTempC = 20.celsius;
  print('Room Temperature: $roomTempC');
  print('Room Temperature in Fahrenheit: ${roomTempC.inFahrenheit} ¬∞F');
  print(
    'Room Temperature in Kelvin: ${roomTempC.convertTo(TemperatureUnit.kelvin)}',
  );

  final boilingPoint = 100.celsius;
  final freezingPoint = 0.celsius;
  final tempDifference = boilingPoint - freezingPoint; // Returns a double
  print('Difference between boiling and freezing point of water: $tempDifference C¬∞');

  // Caution with temperature division (consider physical meaning)
  try {
    final tempRatio = 200.kelvin / 100.kelvin; // Meaningful
    print('Ratio 200K / 100K: $tempRatio');
    // final problematicRatio = 20.celsius / 10.celsius; // Mathematically 2.0, but often not directly interpretable physically
    // print('Ratio 20¬∞C / 10¬∞C: $problematicRatio');
  } on Exception catch (e) {
    print('Error during temperature division: $e');
  }

  // 5. Pressures
  print('\n--- Pressure ---');
  final pAtm = 1.atm; // Standard atmosphere
  print('Standard Atmosphere: $pAtm');
  print('Standard Atmosphere in Pascals: ${pAtm.inPa} Pa');
  print('Standard Atmosphere in PSI: ${pAtm.asPsi.toString(fractionDigits: 2)}');
  print(
    'Standard Atmosphere in bar: ${pAtm.toString(targetUnit: PressureUnit.bar, fractionDigits: 3)}',
  );

  final tirePressure = 32.psi;
  print('Tire Pressure: ${tirePressure.toString(targetUnit: PressureUnit.bar, fractionDigits: 2)}');

  // 6. Comparisons
  print('\n--- Comparisons ---');
  final oneKm = 1.km;
  final oneMile = 1.mi;
  final thousandMeters = 1000.m; // Using .m

  print(
    '1 km == 1000 m (value & unit): ${oneKm == thousandMeters}',
  ); // false (same value, but km vs m unit)
  print('1 km.compareTo(1000 m): ${oneKm.compareTo(thousandMeters)}'); // 0 (same magnitude)
  print('1 km > 1 mile: ${oneKm.compareTo(oneMile) > 0}'); // false
  // print('1 mile > 1 km: ${oneMile > oneKm}'); // true (syntactic sugar for compareTo)

  final lengths = [10.m, 500.cm, 0.002.km, 1.ft];
  print(
    'Unsorted lengths: ${lengths.map((l) => l.toString(targetUnit: LengthUnit.meter)).toList()}',
  );
  lengths.sort();
  print('Sorted lengths: ${lengths.map((l) => l.toString(targetUnit: LengthUnit.meter)).toList()}');

  // 7. Locale-specific Formatting (requires 'intl' package)
  print('\n--- Locale-specific Formatting ---');
  final distanceDE = 1234.567.m; // Using .m
  // Standard (US-like locale from Dart, usually '.')
  print(
    'Distance DE (default locale): ${distanceDE.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2)}',
  );

  // German (de_DE)
  // To use NumberFormat for a specific locale, it needs to be initialized.
  // Usually, this is done globally with `Intl.defaultLocale = 'de_DE';`
  // or it's passed directly to `NumberFormat`.
  // quantify's toString() uses NumberFormat.decimalPatternDigits if locale and fractionDigits are given.
  print(
    'Distance DE (de_DE locale): ${distanceDE.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2, locale: 'de_DE')}',
  );
  // Output: "1,23 km" (with comma as decimal separator)

  // With a custom NumberFormat for decimal pattern
  final valueOnlyFormat = NumberFormat.decimalPatternDigits(locale: 'fr_FR', decimalDigits: 3);
  print(
    'Distance (fr_FR locale, custom NumberFormat, value only): ${distanceDE.toString(numberFormat: valueOnlyFormat, showUnitSymbol: false, targetUnit: LengthUnit.kilometer)}',
  );
  // Output: "1,235" (with comma as decimal separator and 3 decimal places)

  print('\n--- End of Example ---');
}

<!-- END FILE: [v0.5.0] example/lib/main.dart -->

<!-- BEGIN FILE: [v0.5.0] example/pubspec.yaml -->
name: quantify_example
description: A command-line example for the quantify package.
version: 1.0.0
publish_to: "none"

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  intl: ^0.19.0
  quantify: ^0.4.0


dev_dependencies:
  test: ^1.26.0
  very_good_analysis: ^8.0.0

<!-- END FILE: [v0.5.0] example/pubspec.yaml -->

<!-- BEGIN FILE: [v0.5.0] test/units/angle_test.dart -->
// test/units/angle_test.dart
import 'dart:math' as math;

import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('Angle', () {
    const tolerance = 1e-12; // High precision for angular conversions

    // Helper for round trip tests
    void testRoundTrip(
      AngleUnit initialUnit,
      AngleUnit intermediateUnit,
      double initialValue,
    ) {
      final a1 = Angle(initialValue, initialUnit);
      final a2 = a1.convertTo(intermediateUnit);
      final a3 = a2.convertTo(initialUnit);
      expect(
        a3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Angle from num extensions and retrieve values', () {
        final angleDeg = 90.0.degrees;
        expect(angleDeg.value, 90.0);
        expect(angleDeg.unit, AngleUnit.degree);
        expect(angleDeg.inRadians, closeTo(math.pi / 2, tolerance));

        final angleRad = math.pi.radians;
        expect(angleRad.value, math.pi);
        expect(angleRad.unit, AngleUnit.radian);
        expect(angleRad.inDegrees, closeTo(180.0, tolerance));
      });
    });

    group('Conversions', () {
      test('Degree to Radian and Gradian', () {
        final angle = 180.0.degrees;
        expect(angle.inRadians, closeTo(math.pi, tolerance));
        expect(angle.inGradians, closeTo(200.0, tolerance));
        expect(angle.inRevolutions, closeTo(0.5, tolerance));
      });

      test('Radian to Degree and Revolution', () {
        final angle = (2 * math.pi).radians;
        expect(angle.inDegrees, closeTo(360.0, tolerance));
        expect(angle.inRevolutions, closeTo(1.0, tolerance));
      });

      test('Gradian to Degree', () {
        final angle = 100.0.gradians;
        expect(angle.inDegrees, closeTo(90.0, tolerance));
      });

      test('Revolution to other units', () {
        final angle = 0.25.rev; // 90 degrees
        expect(angle.inDegrees, closeTo(90.0, tolerance));
        expect(angle.inRadians, closeTo(math.pi / 2, tolerance));
      });

      test('Arcminute and Arcsecond conversions', () {
        final oneDegree = 1.0.degrees;
        expect(oneDegree.inArcminutes, closeTo(60.0, tolerance));
        expect(oneDegree.inArcseconds, closeTo(3600.0, tolerance));

        final oneArcminute = 1.0.arcminutes;
        expect(oneArcminute.inDegrees, closeTo(1 / 60, tolerance));
      });

      test('Milliradian conversions', () {
        final oneRadian = 1.0.radians;
        expect(oneRadian.inMilliradians, closeTo(1000.0, tolerance));
        final tenMrad = 10.mrad;
        expect(tenMrad.inRadians, closeTo(0.01, tolerance));
      });
    });

    group('Comparison (compareTo)', () {
      test('should correctly compare angles of different units', () {
        final a1 = 90.0.degrees;
        final a2 = (math.pi / 2).radians;
        final a3 = 100.0.gradians;
        final a4 = 89.0.degrees;

        // Diese Vergleiche werden nun alle korrekt sein.
        expect(
          a1.compareTo(a3),
          0,
          reason: '90 degrees should be exactly equal to 100 gradians',
        );

        // Dieser Vergleich kann immer noch eine winzige Abweichung haben,
        // da math.pi/2 selbst eine Ann√§herung ist.
        // Es ist besser, ihn so zu lassen oder einen closeTo Vergleich zu machen.
        // compareTo(a2) sollte aber auch 0 sein, da die internen Faktoren nun konsistenter sind.
        expect(a1.compareTo(a2), 0);

        expect(a1.compareTo(a4), greaterThan(0));
        expect(a4.compareTo(a1), lessThan(0));
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const a1 = Angle(45, AngleUnit.degree);
        const a2 = Angle(45, AngleUnit.degree);
        expect(a1 == a2, isTrue);
        expect(a1.hashCode == a2.hashCode, isTrue);
      });

      test('should not be equal for different value or unit', () {
        final a1 = 45.0.degrees;
        final a2 = (math.pi / 4).radians;
        expect(a1 == a2, isFalse); // Different units
        expect(a1.compareTo(a2), 0); // Same magnitude
      });
    });

    group('Arithmetic Operators', () {
      test('should perform addition and subtraction correctly', () {
        final result = 90.degrees + (math.pi / 4).radians; // 90 + 45 = 135
        expect(result.inDegrees, closeTo(135.0, tolerance));
        expect(result.unit, AngleUnit.degree); // Left operand's unit

        final result2 = result - 45.degrees;
        expect(result2.inDegrees, closeTo(90.0, tolerance));
      });

      test('should perform multiplication and division correctly', () {
        final angle = 30.0.degrees;
        expect((angle * 3.0).inDegrees, closeTo(90.0, tolerance));
        expect((angle / 2.0).inDegrees, closeTo(15.0, tolerance));
        expect(() => angle / 0.0, throwsArgumentError);
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in AngleUnit.values) {
        test('Round trip ${unit.symbol} <-> rad', () {
          testRoundTrip(unit, AngleUnit.radian, 123.456);
        });
      }
      test('Round trip deg <-> grad', () {
        testRoundTrip(AngleUnit.degree, AngleUnit.gradian, 90);
      });
    });

    group('Practical Examples', () {
      test('Trigonometry using dart:math', () {
        final angle = 30.0.degrees;
        // dart:math functions require radians
        final sinValue = math.sin(angle.inRadians);
        expect(sinValue, closeTo(0.5, tolerance));

        final angle45 = (math.pi / 4).radians;
        final cosValue = math.cos(angle45.inRadians);
        final sinValue45 = math.sin(angle45.inRadians);
        expect(cosValue, closeTo(sinValue45, tolerance));
      });

      test('Geometry: sum of angles in a triangle', () {
        final a1 = 60.degrees;
        final a2 = 60.degrees;
        final a3 = 60.degrees;
        final sum = a1 + a2 + a3;
        expect(sum.inDegrees, closeTo(180.0, tolerance));
        expect(sum.inRadians, closeTo(math.pi, tolerance));
      });

      test('Rotational mechanics', () {
        // A wheel turns 3.5 revolutions
        final rotation = 3.5.revolutions;
        expect(rotation.inDegrees, closeTo(3.5 * 360, tolerance));
        // Find angle in a standard coordinate system (modulo 360)
        final finalAngle = rotation.inDegrees % 360;
        expect(finalAngle, closeTo(180.0, tolerance));
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/angle_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/angular_velocity_test.dart -->
// test/units/angular_velocity_test.dart
import 'dart:math' as math;

import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('AngularVelocity', () {
    const tolerance = 1e-12;

    group('Constructors and Getters', () {
      test('should create from num extensions and retrieve values', () {
        final speed = 3000.0.rpm;
        expect(speed.value, 3000.0);
        expect(speed.unit, AngularVelocityUnit.revolutionPerMinute);
        const expectedRadPerSec = 3000.0 * (2 * math.pi) / 60.0;
        expect(speed.inRadiansPerSecond, closeTo(expectedRadPerSec, tolerance));
      });
    });

    group('Conversions', () {
      test('RPM to RPS and Rad/s', () {
        final speed = 60.0.rpm;
        expect(speed.inRps, closeTo(1.0, tolerance));
        expect(speed.inRadiansPerSecond, closeTo(2 * math.pi, tolerance));
      });

      test('Rad/s to others', () {
        final speed = math.pi.radiansPerSecond; // 180¬∞/s or 0.5 rps
        expect(speed.inDegreesPerSecond, closeTo(180.0, tolerance));
        expect(speed.inRps, closeTo(0.5, tolerance));
        expect(speed.inRpm, closeTo(30.0, tolerance));
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final s1 = 60.0.rpm;
        final s2 = 1.0.rps;
        final s3 = 59.0.rpm;

        expect(s1.compareTo(s2), 0);
        expect(s1.compareTo(s3), greaterThan(0));
        expect(s3.compareTo(s1), lessThan(0));
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction', () {
        final sum = 10.rps + 60.rpm; // 10 rps + 1 rps = 11 rps
        expect(sum.inRps, closeTo(11.0, tolerance));
        expect(sum.unit, AngularVelocityUnit.revolutionPerSecond);
      });

      test('should perform scalar multiplication and division', () {
        final speed = 100.0.rpm;
        expect((speed * 2.0).inRpm, closeTo(200.0, tolerance));
        expect((speed / 4.0).inRpm, closeTo(25.0, tolerance));
      });
    });

    group('Dimensional Analysis (Interaction with other Quantities)', () {
      test('AngularVelocity * Time = Angle', () {
        final speed = 3000.0.rpm;
        final duration = 2.0.seconds;
        final totalAngle = speed.totalAngleOver(duration);

        expect(totalAngle, isA<Angle>());
        // 3000 rev/min = 50 rev/sec. Over 2 seconds -> 100 revolutions.
        expect(totalAngle.inRevolutions, closeTo(100.0, tolerance));
        expect(totalAngle.inDegrees, closeTo(100.0 * 360, tolerance));
      });

      test('A full rotation check', () {
        final speed = 360.0.degreesPerSecond;
        final duration = 1.0.seconds;
        final angle = speed.totalAngleOver(duration);

        expect(angle.inRevolutions, closeTo(1.0, tolerance));
      });
    });

    group('Practical Examples', () {
      test('Car Engine', () {
        // An engine idles at 800 rpm and has a redline at 7000 rpm.
        final idleSpeed = 800.rpm;
        final redline = 7000.rpm;

        expect(idleSpeed.compareTo(redline), lessThan(0));
        expect(redline.inRps, closeTo(7000.0 / 60.0, tolerance));

        // How many full rotations in 100 milliseconds at redline?
        final angleTurned = redline.totalAngleOver(100.milliseconds);
        expect(angleTurned.inRevolutions, closeTo(7000.0 / 60.0 * 0.1, tolerance));
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/angular_velocity_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/constants_test.dart -->
import 'dart:math' as math;

import 'package:quantify/constants.dart';
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('Physical Constants', () {
    const tolerance = 1e-12;
    const highTolerance = 1e-9;

    test('fundamental constants have correct values', () {
      // Speed of light (exact by definition)
      expect(PhysicalConstants.speedOfLightPerSecond.getValue(LengthUnit.meter), 299792458.0);

      // Planck constant (exact by definition since 2019)
      expect(PhysicalConstants.planckConstant, 6.62607015e-34);

      // Elementary charge (exact by definition since 2019)
      expect(PhysicalConstants.elementaryCharge, 1.602176634e-19);

      // Avogadro constant (exact by definition since 2019)
      expect(PhysicalConstants.avogadroConstant, 6.02214076e23);
    });

    test('particle masses are correct', () {
      // Electron mass
      expect(
        PhysicalConstants.electronMass.getValue(MassUnit.kilogram),
        closeTo(9.1093837015e-31, tolerance),
      );

      // Proton mass
      expect(
        PhysicalConstants.protonMass.getValue(MassUnit.kilogram),
        closeTo(1.67262192369e-27, tolerance),
      );

      // Atomic mass unit
      expect(
        PhysicalConstants.atomicMassConstant.getValue(MassUnit.kilogram),
        closeTo(1.66053906660e-27, tolerance),
      );
    });

    test('quantum constants are consistent', () {
      // Reduced Planck constant
      const hBar = PhysicalConstants.planckConstant / (2 * math.pi);
      expect(
        PhysicalConstants.reducedPlanckConstant,
        closeTo(hBar, tolerance),
      );

      // Bohr radius should be close to expected value
      expect(
        PhysicalConstants.bohrRadius.getValue(LengthUnit.meter),
        closeTo(5.29177210903e-11, highTolerance),
      );
    });

    test('convenience methods work correctly', () {
      // Light speed calculation
      final oneSecond = 1.0.s;
      final lightDistance = PhysicalConstants.lightSpeed(oneSecond);
      expect(
        lightDistance.getValue(LengthUnit.meter),
        closeTo(299792458.0, tolerance),
      );

      // Mass-energy equivalence for 1 kg
      final oneKg = 1.0.kg;
      final energy = PhysicalConstants.massEnergyEquivalence(oneKg);
      const expectedEnergy = 299792458.0 * 299792458.0; // c¬≤
      expect(energy, closeTo(expectedEnergy, highTolerance));

      // Photon energy for 500 nm light
      final greenLight = 500.0.nm;
      final photonEnergy = PhysicalConstants.photonEnergy(greenLight);
      final expectedEnergy500nm = PhysicalConstants.planckConstant *
          PhysicalConstants.speedOfLightPerSecond.getValue(LengthUnit.meter) /
          greenLight.getValue(LengthUnit.meter);
      expect(photonEnergy, closeTo(expectedEnergy500nm, highTolerance));
    });
  });

  group('Astronomical Constants', () {
    const tolerance = 1e-9;
    const highTolerance = 1e-6;

    test('solar system masses are correct', () {
      // Solar mass
      expect(
        AstronomicalConstants.solarMass.getValue(MassUnit.kilogram),
        closeTo(1.98847e30, 1e25), // Large tolerance due to measurement uncertainty
      );

      // Earth mass
      expect(
        AstronomicalConstants.earthMass.getValue(MassUnit.kilogram),
        closeTo(5.9722e24, 1e20),
      );

      // Jupiter should be much more massive than Earth
      final jupiterToEarthRatio = AstronomicalConstants.jupiterMass.getValue(MassUnit.kilogram) /
          AstronomicalConstants.earthMass.getValue(MassUnit.kilogram);
      expect(jupiterToEarthRatio, greaterThan(300)); // Jupiter is ~318 Earth masses
      expect(jupiterToEarthRatio, lessThan(320));
    });

    test('length scales are reasonable', () {
      // Earth radius
      expect(
        AstronomicalConstants.earthRadius.getValue(LengthUnit.kilometer),
        closeTo(6378.14, 10), // ~6378 km
      );

      // Solar radius
      expect(
        AstronomicalConstants.solarRadius.getValue(LengthUnit.kilometer),
        closeTo(695700, 1000), // ~696,000 km
      );

      // Sun should be much larger than Earth
      final solarToEarthRadius = AstronomicalConstants.solarRadius.getValue(LengthUnit.meter) /
          AstronomicalConstants.earthRadius.getValue(LengthUnit.meter);
      expect(solarToEarthRadius, greaterThan(100)); // Sun is ~109 Earth radii
      expect(solarToEarthRadius, lessThan(120));
    });

    test('astronomical unit consistency', () {
      // Check that built-in AU matches constant
      final builtInAU = 1.0.AU;
      expect(
        AstronomicalConstants.astronomicalUnit.getValue(LengthUnit.meter),
        builtInAU.getValue(LengthUnit.meter),
      );

      // AU should be ~150 million km
      expect(
        AstronomicalConstants.astronomicalUnit.getValue(LengthUnit.kilometer),
        closeTo(149597870.7, 1), // Exact by IAU definition
      );
    });

    test('convenience calculations work', () {
      // Earth surface gravity
      final g = AstronomicalConstants.surfaceGravity(
        AstronomicalConstants.earthMass,
        AstronomicalConstants.earthRadius,
      );
      expect(g, closeTo(9.8, 0.2)); // ~9.8 m/s¬≤

      // Earth escape velocity
      final vEscape = AstronomicalConstants.escapeVelocity(
        AstronomicalConstants.earthMass,
        AstronomicalConstants.earthRadius,
      );
      expect(vEscape, closeTo(11200, 200)); // ~11.2 km/s

      // Schwarzschild radius of solar mass
      final rs = AstronomicalConstants.schwarzschildRadius(AstronomicalConstants.solarMass);
      expect(rs.getValue(LengthUnit.kilometer), closeTo(2.95, 0.1)); // ~3 km
    });
  });

  group('Engineering Constants', () {
    const tolerance = 1e-9;

    test('standard conditions are correct', () {
      // Standard temperature (STP)
      expect(
        EngineeringConstants.standardTemperature.getValue(TemperatureUnit.celsius),
        closeTo(0.0, tolerance),
      );

      // Standard pressure (STP) - IUPAC definition
      expect(
        EngineeringConstants.standardPressure.getValue(PressureUnit.bar),
        closeTo(1.0, tolerance),
      );

      // Standard atmospheric pressure
      expect(
        EngineeringConstants.standardAtmosphere.getValue(PressureUnit.pascal),
        101325.0,
      );

      // Room temperature should be reasonable
      final roomTempC = EngineeringConstants.roomTemperature.getValue(TemperatureUnit.celsius);
      expect(roomTempC, greaterThan(20));
      expect(roomTempC, lessThan(25));
    });

    test('material properties are reasonable', () {
      // Water density at STP should be close to 1000 kg/m¬≥
      expect(EngineeringConstants.waterDensitySTP, closeTo(1000, 1));

      // Air should be much less dense than water
      expect(EngineeringConstants.airDensitySTP, lessThan(10));
      expect(EngineeringConstants.airDensitySTP, greaterThan(1));

      // Sound speed in air should be ~343 m/s at 20¬∞C
      expect(EngineeringConstants.soundSpeedAir20C, closeTo(343, 5));

      // Sound in water should be faster than in air
      expect(
        EngineeringConstants.soundSpeedWater25C,
        greaterThan(EngineeringConstants.soundSpeedAir20C * 3),
      );
    });

    test('thermal properties make sense', () {
      // Copper should have high thermal conductivity
      expect(EngineeringConstants.copperThermalConductivity, greaterThan(300));

      // Air should have very low thermal conductivity
      expect(EngineeringConstants.airThermalConductivity, lessThan(0.1));

      // Water should have high specific heat
      expect(EngineeringConstants.waterSpecificHeat, greaterThan(4000));

      // Latent heat of vaporization should be large
      expect(EngineeringConstants.waterLatentHeatVaporization, greaterThan(2e6));
    });

    test('mechanical properties are reasonable', () {
      // Steel Young's modulus should be ~200 GPa
      expect(EngineeringConstants.steelYoungsModulus, closeTo(2e11, 5e10));

      // Aluminum should be less stiff than steel
      expect(
        EngineeringConstants.aluminumYoungsModulus,
        lessThan(EngineeringConstants.steelYoungsModulus),
      );

      // Concrete should be less stiff than metals
      expect(
        EngineeringConstants.concreteYoungsModulus,
        lessThan(EngineeringConstants.aluminumYoungsModulus),
      );

      // Steel tensile strength should be reasonable
      expect(EngineeringConstants.steelTensileStrength, greaterThan(3e8)); // >300 MPa
      expect(EngineeringConstants.steelTensileStrength, lessThan(8e8)); // <800 MPa
    });

    test('electrical properties are consistent', () {
      // Copper should have low resistivity
      expect(EngineeringConstants.copperResistivity, lessThan(2e-8));

      // Aluminum resistivity should be higher than copper
      expect(
        EngineeringConstants.aluminumResistivity,
        greaterThan(EngineeringConstants.copperResistivity),
      );

      // Silicon should have much higher resistivity
      expect(EngineeringConstants.siliconResistivity, greaterThan(1000));

      // Water should have high dielectric constant
      expect(EngineeringConstants.waterDielectricConstant, greaterThan(80));
    });

    test('convenience calculations work correctly', () {
      // Reynolds number calculation
      const velocity = 2.0; // m/s
      final diameter = 0.1.m; // 10 cm
      const kinematicViscosity = 1e-6; // m¬≤/s (approximately water)
      final re = EngineeringConstants.reynoldsNumberPipe(velocity, diameter, kinematicViscosity);
      expect(re, closeTo(200000, 10000)); // Re = vD/ŒΩ = 2*0.1/1e-6 = 2e5

      // Thermal expansion calculation
      final originalLength = 10.0.m;
      const expansionCoeff = 12e-6; // /K (steel)
      const tempChange = Temperature(100, TemperatureUnit.kelvin);
      final deltaL =
          EngineeringConstants.thermalExpansion(originalLength, expansionCoeff, tempChange);
      expect(
        deltaL.getValue(LengthUnit.meter),
        closeTo(0.012, 1e-6),
      ); // ŒîL = L‚ÇÄŒ±ŒîT = 10*12e-6*100 = 0.012 m
    });
  });

  group('Cross-library consistency', () {
    test('physical and astronomical constants are consistent', () {
      // Gravitational parameter consistency
      // GM_earth should give correct surface gravity
      const G = 6.67430e-11; // From PhysicalConstants
      final earthMass = AstronomicalConstants.earthMass.getValue(MassUnit.kilogram);
      final earthRadius = AstronomicalConstants.earthRadius.getValue(LengthUnit.meter);
      final calculatedG = AstronomicalConstants.surfaceGravity(
            AstronomicalConstants.earthMass,
            AstronomicalConstants.earthRadius,
          ) *
          earthRadius *
          earthRadius /
          earthMass;

      expect(
        calculatedG,
        closeTo(G, G * 0.01),
      ); // Within 1% (accounting for measurement uncertainties)
    });

    test('engineering and physical constants align', () {
      // Standard gravity should be close to calculated Earth gravity
      final earthGravity = AstronomicalConstants.surfaceGravity(
        AstronomicalConstants.earthMass,
        AstronomicalConstants.earthRadius,
      );
      // TODO FIX ME expect(earthGravity, closeTo(EngineeringConstants.standardGravity, 0.5)); // Within 0.5 m/s¬≤

      // Water freezing point consistency
      expect(
        EngineeringConstants.waterFreezingPoint.getValue(TemperatureUnit.kelvin),
        closeTo(273.15, 1e-9),
      );
      expect(
        EngineeringConstants.standardTemperature.getValue(TemperatureUnit.kelvin),
        EngineeringConstants.waterFreezingPoint.getValue(TemperatureUnit.kelvin),
      );
    });

    test('unit conversions work with constants', () {
      // Solar mass in different units
      final solarMassInEarthMasses = AstronomicalConstants.solarMass.getValue(MassUnit.kilogram) /
          AstronomicalConstants.earthMass.getValue(MassUnit.kilogram);
      expect(solarMassInEarthMasses, greaterThan(300000)); // Sun is ~333,000 Earth masses
      expect(solarMassInEarthMasses, lessThan(340000));

      // Speed of light in different units
      final lightSpeedKmS =
          PhysicalConstants.speedOfLightPerSecond.getValue(LengthUnit.meter) / 1000;
      expect(lightSpeedKmS, closeTo(299792.458, 1e-3)); // ~300,000 km/s

      // Bohr radius in angstroms
      final bohrInAngstrom = PhysicalConstants.bohrRadius.getValue(LengthUnit.angstrom);
      expect(bohrInAngstrom, closeTo(0.529, 0.001)); // ~0.529 √Ö
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/constants_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/current_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming Current and CurrentUnit are exported
import 'package:test/test.dart';

void main() {
  group('Current', () {
    const strictTolerance = 1e-12; // For "exact" conversions or small scales
    const defaultTolerance = 1e-9; // General purpose
    const looseTolerance = 1e-6; // For conversions over many orders of magnitude

    // Helper for round trip tests
    void testRoundTrip(
      CurrentUnit initialUnit,
      CurrentUnit intermediateUnit,
      double initialValue, {
      double tol = defaultTolerance,
    }) {
      final c1 = Current(initialValue, initialUnit);
      final c2 = c1.convertTo(intermediateUnit);
      final c3 = c2.convertTo(initialUnit);
      expect(
        c3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${c3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create Current from num extensions and retrieve values correctly', () {
        final curA = 1.5.A; // Using symbol extension
        expect(curA.value, 1.5);
        expect(curA.unit, CurrentUnit.ampere);
        expect(curA.inMilliamperes, closeTo(1500.0, strictTolerance));
        expect(curA.asMilliamperes.value, closeTo(1500.0, strictTolerance));
        expect(curA.asMilliamperes.unit, CurrentUnit.milliampere);

        final curMA = 250.0.milliamperes; // Using alias
        expect(curMA.value, 250.0);
        expect(curMA.unit, CurrentUnit.milliampere);
        expect(curMA.inAmperes, closeTo(0.25, strictTolerance));

        final curUA = 123.0.uA;
        expect(curUA.value, 123.0);
        expect(curUA.unit, CurrentUnit.microampere);
        expect(curUA.inAmperes, closeTo(0.000123, strictTolerance));
        expect(curUA.inNanoamperes, closeTo(123000.0, defaultTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const current = Current(0.01, CurrentUnit.ampere);
        expect(current.getValue(CurrentUnit.ampere), 0.01);
      });
    });

    group('Conversions between various current units', () {
      final oneAmpere = 1.0.A;
      test('1 Ampere to other units', () {
        expect(oneAmpere.inKiloamperes, closeTo(0.001, strictTolerance));
        expect(oneAmpere.inMilliamperes, closeTo(1000.0, strictTolerance));
        expect(oneAmpere.inMicroamperes, closeTo(1.0e6, strictTolerance));
        expect(oneAmpere.inNanoamperes, closeTo(1.0e9, looseTolerance)); // Larger scale
      });

      final oneKiloampere = 1.0.kA;
      test('1 Kiloampere to amperes', () {
        expect(oneKiloampere.inAmperes, closeTo(1000.0, strictTolerance));
      });

      final oneMilliampere = 1.0.mA;
      test('1 Milliampere to microamperes and amperes', () {
        expect(oneMilliampere.inMicroamperes, closeTo(1000.0, strictTolerance));
        expect(oneMilliampere.inAmperes, closeTo(0.001, strictTolerance));
      });

      final fiftyMicroamperes = 50.0.uA;
      test('50 Microamperes to nanoamperes and milliamperes', () {
        expect(fiftyMicroamperes.inNanoamperes, closeTo(50000.0, defaultTolerance));
        expect(fiftyMicroamperes.inMilliamperes, closeTo(0.05, strictTolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Current object with converted value and unit', () {
        final curMA = 1250.0.mA;
        final curA = curMA.convertTo(CurrentUnit.ampere);

        expect(curA.unit, CurrentUnit.ampere);
        expect(curA.value, closeTo(1.25, strictTolerance));
        expect(curMA.unit, CurrentUnit.milliampere); // Original should be unchanged
        expect(curMA.value, 1250.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final c1 = 0.1.A;
        final c2 = c1.convertTo(CurrentUnit.ampere);
        expect(identical(c1, c2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final c1A = 1.0.A;
      final c1000mA = 1000.0.mA;
      final c999mA = 999.0.mA;
      final c0_01kA = 0.01.kA; // 10 A
      final c0_0001kA = 0.0001.kA; // 0.1 A

      test('should correctly compare currents of different units', () {
        expect(c1A.compareTo(c999mA), greaterThan(0)); // 1A > 999mA
        expect(c999mA.compareTo(c1A), lessThan(0)); // 999mA < 1A
        expect(c1A.compareTo(c1000mA), 0); // 1A == 1000mA

        expect(c1A.compareTo(c0_01kA), lessThan(0)); // 1A < 10A
        expect(c1A.compareTo(c0_0001kA), greaterThan(0)); // 1A > 0.1A
      });

      test('should return 0 for equal currents in different units', () {
        final cInUA = 1000000.0.uA; // 1 A in microamperes
        expect(c1A.compareTo(cInUA), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const c1 = Current(0.05, CurrentUnit.ampere);
        const c2 = Current(0.05, CurrentUnit.ampere);
        expect(c1 == c2, isTrue);
        expect(c1.hashCode == c2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const c1 = Current(0.05, CurrentUnit.ampere);
        const c2Diffval = Current(0.051, CurrentUnit.ampere);
        const c3Diffunit = Current(0.05, CurrentUnit.milliampere);

        expect(c1 == c2Diffval, isFalse);
        expect(c1 == c3Diffunit, isFalse);

        expect(c1.hashCode == c2Diffval.hashCode, isFalse);
        expect(c1.hashCode == c3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.A is not equal to 1000.mA', () {
        final oneAmp = 1.A;
        final thousandMilliamp = 1000.mA;
        expect(oneAmp == thousandMilliamp, isFalse);
        expect(oneAmp.compareTo(thousandMilliamp), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(2.5.A.toString(), '2.5\u00A0A');
        expect(15.mA.toString(), '15.0\u00A0mA');
        expect(123.microamperes.toString(), '123.0\u00A0¬µA'); // Note ¬µ symbol
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 0.0123456789;

      for (final unit in CurrentUnit.values) {
        test('Round trip ${unit.symbol} <-> A', () {
          testRoundTrip(
            unit,
            CurrentUnit.ampere,
            testValue,
            tol: (unit == CurrentUnit.ampere ||
                    unit == CurrentUnit.milliampere ||
                    unit == CurrentUnit.kiloampere)
                ? strictTolerance
                : looseTolerance,
          );
        });
      }

      test('Round trip mA <-> ¬µA', () {
        testRoundTrip(CurrentUnit.milliampere, CurrentUnit.microampere, 0.5, tol: strictTolerance);
      });
      test('Round trip ¬µA <-> nA', () {
        testRoundTrip(CurrentUnit.microampere, CurrentUnit.nanoampere, 0.005, tol: strictTolerance);
      });
      test('Round trip A <-> kA', () {
        testRoundTrip(CurrentUnit.ampere, CurrentUnit.kiloampere, 2500.0, tol: strictTolerance);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final cZeroA = 0.0.A;
        for (final unit in CurrentUnit.values) {
          expect(cZeroA.getValue(unit), 0.0, reason: '0 A to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with very small and large values', () {
        final verySmall = 1.0e-10.A; // picoampere range if unit existed
        expect(verySmall.inNanoamperes, closeTo(0.1, strictTolerance));

        final veryLarge = 1.0e4.A; // 10 kA
        expect(veryLarge.inKiloamperes, closeTo(10.0, strictTolerance));
      });
    });

    group('Arithmetic Operators for Current', () {
      final c1A = 1.0.A;
      final c2A = 2.0.A;
      final c500mA = 500.mA; // 0.5 A
      final c100uA = 100.uA; // 0.0001 A

      // Operator +
      test('operator + combines currents, result in unit of left operand', () {
        final sum1 = c2A + c1A;
        expect(sum1.value, closeTo(3.0, defaultTolerance));
        expect(sum1.unit, CurrentUnit.ampere);

        final sum2 = c1A + c500mA; // 1A + 0.5A = 1.5A
        expect(sum2.value, closeTo(1.5, defaultTolerance));
        expect(sum2.unit, CurrentUnit.ampere);

        final sum3 = c500mA + c1A; // 500mA + 1000mA = 1500mA
        expect(sum3.value, closeTo(1500.0, defaultTolerance));
        expect(sum3.unit, CurrentUnit.milliampere);

        final sum4 = c1A + c100uA; // 1A + 0.0001A
        expect(sum4.value, closeTo(1.0 + 0.0001, strictTolerance));
        expect(sum4.unit, CurrentUnit.ampere);
      });

      // Operator -
      test('operator - subtracts currents, result in unit of left operand', () {
        final diff1 = c2A - c1A;
        expect(diff1.value, closeTo(1.0, defaultTolerance));
        expect(diff1.unit, CurrentUnit.ampere);

        final diff2 = c1A - c500mA; // 1A - 0.5A = 0.5A
        expect(diff2.value, closeTo(0.5, defaultTolerance));
        expect(diff2.unit, CurrentUnit.ampere);

        final diff3 = c1A - c100uA; // 1A - 0.0001A
        expect(diff3.value, closeTo(1.0 - 0.0001, strictTolerance));
        expect(diff3.unit, CurrentUnit.ampere);
      });

      // Operator * (scalar)
      test('operator * scales current by a scalar', () {
        final scaled1 = c2A * 1.5;
        expect(scaled1.value, closeTo(3.0, defaultTolerance));
        expect(scaled1.unit, CurrentUnit.ampere);

        final scaled2 = c500mA * 0.2;
        expect(scaled2.value, closeTo(100.0, defaultTolerance));
        expect(scaled2.unit, CurrentUnit.milliampere);
      });

      // Operator / (scalar)
      test('operator / scales current by a scalar', () {
        final scaled1 = c2A / 5.0;
        expect(scaled1.value, closeTo(0.4, defaultTolerance));
        expect(scaled1.unit, CurrentUnit.ampere);

        final scaled2 = c1A / 0.02;
        expect(scaled2.value, closeTo(50.0, defaultTolerance));
        expect(scaled2.unit, CurrentUnit.ampere);

        expect(() => c1A / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialCurrent = 0.5.A;
        final cAdd = initialCurrent + 200.mA; // 0.5A + 0.2A = 0.7A
        final cMul = cAdd * 3.0; // 0.7A * 3 = 2.1A
        final cSub = cMul - 10000.uA; // 2.1A - 0.01A = 2.09A

        expect(initialCurrent.value, 0.5); // Original unchanged
        expect(initialCurrent.unit, CurrentUnit.ampere);

        expect(cAdd.value, closeTo(0.7, defaultTolerance));
        expect(cAdd.unit, CurrentUnit.ampere);

        expect(cMul.value, closeTo(2.1, defaultTolerance));
        expect(cMul.unit, CurrentUnit.ampere);

        final expectedCSubVal = 2.1 - 10000.0.uA.getValue(CurrentUnit.ampere);
        expect(cSub.value, closeTo(expectedCSubVal, strictTolerance));
        expect(cSub.unit, CurrentUnit.ampere);
      });
    });

    group('CGS and Historical Units', () {
      const tolerance = 1e-12;

      test('abampere (biot) conversions', () {
        // Use the new explicit extension `abA`
        final oneAbampere = 1.0.abA;
        expect(oneAbampere.inAmperes, closeTo(10.0, tolerance));

        // Test creation with `Bi` alias
        final oneBiot = 1.0.bi;
        expect(oneBiot.compareTo(oneAbampere), 0);

        // Test conversion from SI
        final fiftyAmperes = 50.0.A;
        expect(fiftyAmperes.inAbamperes, closeTo(5.0, tolerance));
      });

      test('statampere conversions', () {
        // Use the new explicit extension `statA`
        final oneAmpere = 1.0.A;
        const expectedStatA = 1.0 / 3.3356409519815204e-10;
        expect(oneAmpere.inStatamperes, closeTo(expectedStatA, 1e-3));

        // Test creation and conversion back
        final oneStatampere = 1.0.statA;
        expect(oneStatampere.inAmperes, closeTo(3.3356409519815204e-10, tolerance));
      });

      test('comparison between CGS and SI units', () {
        final oneAbampere = 1.0.abA; // 10 A
        final oneAmpere = 1.0.A;
        final oneStatampere = 1.0.statA; // tiny current

        expect(oneAbampere.compareTo(oneAmpere), greaterThan(0));
        expect(oneAmpere.compareTo(oneStatampere), greaterThan(0));
      });

      test('round trip conversions for CGS units', () {
        const testValue = 123.456;

        // Test round trip via amperes
        final originalAbA = testValue.abA;
        final roundTripAbA = originalAbA.asAmperes.asAbamperes;
        expect(roundTripAbA.value, closeTo(testValue, tolerance));

        final originalStatA = testValue.statA;
        final roundTripStatA = originalStatA.asAmperes.asStatamperes;
        expect(
          roundTripStatA.value,
          closeTo(testValue, 1e-3),
        ); // Lower precision due to large factor
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/current_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/length_test.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:quantify/quantify.dart';
import 'package:quantify/src/units/length/length_factors.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons
  const highTolerance = 1e-6; // For very large/small conversions
  const astronomicalTolerance = 1e-4; // For astronomical distances

  group('Length', () {
    // Helper for round trip tests
    void testRoundTrip(
      LengthUnit initialUnit,
      LengthUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final l1 = Length(initialValue, initialUnit);
      final l2 = l1.convertTo(intermediateUnit);
      final l3 = l2.convertTo(initialUnit);
      expect(
        l3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Length from num extensions and retrieve values', () {
        final l1 = 100.0.m;
        expect(l1.value, 100.0);
        expect(l1.unit, LengthUnit.meter);
        expect(l1.inKm, closeTo(0.1, tolerance));

        final l2 = 5.0.ft;
        expect(l2.value, 5.0);
        expect(l2.unit, LengthUnit.foot);
        expect(l2.inInch, closeTo(60.0, tolerance));

        final l3 = 12.inch;
        expect(l3.inFt, closeTo(1.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const l = Length(25.0, LengthUnit.centimeter);
        expect(l.getValue(LengthUnit.centimeter), 25.0);
      });

      test('getValue for all units from Meter base', () {
        final l = 1000.0.m; // 1 km
        expect(l.inM, 1000.0);
        expect(l.inKm, closeTo(1.0, tolerance));
        expect(l.inCm, closeTo(100000.0, tolerance));
        expect(l.inMm, closeTo(1000000.0, tolerance));
        expect(l.inInch, closeTo(1000.0 / 0.0254, 1e-7));
        expect(l.inFt, closeTo(1000.0 / 0.3048, 1e-7));
        expect(l.inYd, closeTo(1000.0 / 0.9144, 1e-7));
        expect(l.inMi, closeTo(1000.0 / 1609.344, 1e-7));
        expect(l.inNmi, closeTo(1000.0 / 1852.0, 1e-7));
      });
    });

    group('Conversions', () {
      final oneMeter = 1.0.m;

      test('1 meter to various units', () {
        expect(oneMeter.inKm, closeTo(0.001, tolerance));
        expect(oneMeter.inCm, closeTo(100.0, tolerance));
        expect(oneMeter.inMm, closeTo(1000.0, tolerance));
        expect(oneMeter.inInch, closeTo(1 / 0.0254, 1e-7)); // 39.3700787...
        expect(oneMeter.inFt, closeTo(1 / 0.3048, 1e-7)); // 3.2808398...
        expect(oneMeter.inYd, closeTo(1 / 0.9144, 1e-7)); // 1.0936132...
      });

      final oneFoot = 1.0.ft;
      test('1 foot to various units', () {
        expect(oneFoot.inM, closeTo(0.3048, tolerance));
        expect(oneFoot.inInch, closeTo(12.0, tolerance));
        expect(oneFoot.inYd, closeTo(1.0 / 3.0, tolerance));
      });

      final oneMile = 1.0.mi;
      test('1 mile to various units', () {
        expect(oneMile.inM, closeTo(1609.344, tolerance));
        expect(oneMile.inFt, closeTo(5280.0, tolerance));
        expect(oneMile.inYd, closeTo(1760.0, tolerance));
        expect(oneMile.inKm, closeTo(1.609344, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Length object with converted value and unit', () {
        final lMeters = 10.0.m;
        final lFeet = lMeters.convertTo(LengthUnit.foot);
        expect(lFeet.unit, LengthUnit.foot);
        expect(lFeet.value, closeTo(lMeters.inFt, tolerance));
        expect(lMeters.unit, LengthUnit.meter); // Original should be unchanged
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final l1 = 10.0.m;
        final l2 = l1.convertTo(LengthUnit.meter);
        expect(identical(l1, l2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final lMeter = 1.0.m;
      final lSlightlyLessCm = 99.0.cm;
      final lSlightlyMoreCm = 101.0.cm;
      final lFoot = 3.0.ft; // 0.9144 meters

      test('should correctly compare lengths of different units', () {
        expect(lMeter.compareTo(lSlightlyLessCm), greaterThan(0));
        expect(lSlightlyLessCm.compareTo(lMeter), lessThan(0));
        expect(lMeter.compareTo(lSlightlyMoreCm), lessThan(0));
        expect(lMeter.compareTo(lFoot), greaterThan(0)); // 1m > 3ft
      });

      test('should return 0 for equal lengths in different units', () {
        final lCm = 100.0.cm;
        final lInches = (1.0 / 0.0254).inch; // 1 meter in inches
        expect(lMeter.compareTo(lCm), 0);
        expect(lCm.compareTo(lMeter), 0);
        expect(lMeter.compareTo(lInches), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const l1 = Length(10.0, LengthUnit.meter);
        const l2 = Length(10.0, LengthUnit.meter);
        expect(l1 == l2, isTrue);
        expect(l1.hashCode == l2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const l1 = Length(10.0, LengthUnit.meter);
        const l2 = Length(10.1, LengthUnit.meter);
        const l3 = Length(10.0, LengthUnit.foot);
        expect(l1 == l2, isFalse);
        expect(l1 == l3, isFalse);
        expect(l1.hashCode == l2.hashCode, isFalse);
        expect(l1.hashCode == l3.hashCode, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(10.5.m.toString(), '10.5¬†m');
        expect(12.0.inch.toString(), '12.0¬†in');
        expect(1.6.km.toString(), '1.6¬†km');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 789.123;
      const highTolerance = 1e-7; // For chains of conversions

      for (final unit in LengthUnit.values) {
        test('Round trip ${unit.symbol} <-> m', () {
          testRoundTrip(
            unit,
            LengthUnit.meter,
            testValue,
            tolerance: (unit == LengthUnit.meter) ? tolerance : highTolerance,
          );
        });
      }

      test('Round trip ft <-> in', () {
        testRoundTrip(LengthUnit.foot, LengthUnit.inch, testValue);
      });
      test('Round trip yd <-> mi', () {
        testRoundTrip(LengthUnit.yard, LengthUnit.mile, 5000.0, tolerance: highTolerance);
      });
      test('Round trip cm <-> km', () {
        testRoundTrip(
          LengthUnit.centimeter,
          LengthUnit.kilometer,
          250000.0,
          tolerance: highTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final lZero = 0.0.m;
        for (final unit in LengthUnit.values) {
          expect(lZero.getValue(unit), 0.0, reason: '0 m to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for Length', () {
      final l1Meter = 1.0.m;
      final l2Meters = 2.0.m;
      final l50Cm = 50.cm; // 0.5 meters

      // Operator +
      test('operator + combines lengths', () {
        final sum1 = l2Meters + l1Meter;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, LengthUnit.meter);

        final sum2 = l1Meter + l50Cm; // 1m + 0.5m = 1.5m
        expect(sum2.value, closeTo(1.5, tolerance));
        expect(sum2.unit, LengthUnit.meter);

        final sum3 = l50Cm + l1Meter; // 50cm + 100cm = 150cm
        expect(sum3.value, closeTo(150.0, tolerance));
        expect(sum3.unit, LengthUnit.centimeter);
      });

      // Operator -
      test('operator - subtracts lengths', () {
        final diff1 = l2Meters - l1Meter;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, LengthUnit.meter);

        final diff2 = l1Meter - l50Cm; // 1m - 0.5m = 0.5m
        expect(diff2.value, closeTo(0.5, tolerance));
        expect(diff2.unit, LengthUnit.meter);

        final diff3 = l2Meters - l50Cm.convertTo(LengthUnit.meter); // 2m - 0.5m = 1.5m
        expect(diff3.value, closeTo(1.5, tolerance));
        expect(diff3.unit, LengthUnit.meter);
      });

      // Operator * (scalar)
      test('operator * scales length by a scalar', () {
        final scaled = l2Meters * 3.0;
        expect(scaled.value, closeTo(6.0, tolerance));
        expect(scaled.unit, LengthUnit.meter);

        final scaledCm = l50Cm * 2.5;
        expect(scaledCm.value, closeTo(125.0, tolerance));
        expect(scaledCm.unit, LengthUnit.centimeter);
      });

      // Operator / (scalar)
      test('operator / scales length by a scalar', () {
        final scaled = l2Meters / 2.0;
        expect(scaled.value, closeTo(1.0, tolerance));
        expect(scaled.unit, LengthUnit.meter);

        expect(() => l1Meter / 0.0, throwsArgumentError);
      });

      test('operator chaining preserves immutability', () {
        final initialLength = 10.m;
        final l1 = initialLength + 5.m; // 15m
        final l2 = l1 * 2.0; // 30m
        final l3 = l2 - 100.cm; // 30m - 1m = 29m

        expect(initialLength.value, 10.0); // Original unchanged
        expect(l1.value, closeTo(15.0, tolerance));
        expect(l2.value, closeTo(30.0, tolerance));
        expect(l3.value, closeTo(29.0, tolerance));
        expect(l3.unit, LengthUnit.meter);
      });
    });
  });

  group('Extended Length Units', () {
    group('SI Prefix Units', () {
      test('hectometer conversions', () {
        final oneHectometer = 1.0.hm;
        expect(oneHectometer.inM, closeTo(100.0, tolerance));
        expect(oneHectometer.inKm, closeTo(0.1, tolerance));
        expect(oneHectometer.inCm, closeTo(10000.0, tolerance));
      });

      test('decameter conversions', () {
        final oneDecameter = 1.0.dam;
        expect(oneDecameter.inM, closeTo(10.0, tolerance));
        expect(oneDecameter.inHm, closeTo(0.1, tolerance));
        expect(oneDecameter.inDm, closeTo(100.0, tolerance));
      });

      test('decimeter conversions', () {
        final oneDecimeter = 1.0.dm;
        expect(oneDecimeter.inM, closeTo(0.1, tolerance));
        expect(oneDecimeter.inCm, closeTo(10.0, tolerance));
        expect(oneDecimeter.inMm, closeTo(100.0, tolerance));
      });

      test('micrometer conversions', () {
        final oneMicrometer = 1.0.um;
        expect(oneMicrometer.inM, closeTo(1e-6, tolerance));
        expect(oneMicrometer.inMm, closeTo(0.001, tolerance));
        expect(oneMicrometer.inNm, closeTo(1000.0, tolerance));
      });

      test('nanometer conversions', () {
        final oneNanometer = 1.0.nm;
        expect(oneNanometer.inM, closeTo(1e-9, tolerance));
        expect(oneNanometer.inUm, closeTo(0.001, tolerance));
        expect(oneNanometer.inPm, closeTo(1000.0, tolerance));
      });

      test('picometer conversions', () {
        final onePicometer = 1.0.pm;
        expect(onePicometer.inM, closeTo(1e-12, tolerance));
        expect(onePicometer.inNm, closeTo(0.001, tolerance));
        expect(onePicometer.inFm, closeTo(1000.0, tolerance));
      });

      test('femtometer conversions', () {
        final oneFemtometer = 1.0.fm;
        expect(oneFemtometer.inM, closeTo(1e-15, tolerance));
        expect(oneFemtometer.inPm, closeTo(0.001, tolerance));
      });
    });

    group('Astronomical Units', () {
      test('astronomical unit conversions', () {
        final oneAU = 1.0.AU;
        expect(oneAU.inM, closeTo(149597870700.0, tolerance));
        expect(oneAU.inKm, closeTo(149597870.7, highTolerance));

        // Test practical astronomy example
        final marsDistance = 1.5.AU; // Mars at average distance
        expect(marsDistance.inKm, closeTo(224396806.05, highTolerance));
      });

      test('light year conversions', () {
        final oneLightYear = 1.0.ly;
        // Expected value calculated using the library's own factors
        const expectedAUperLY =
            LengthFactors.metersPerLightYear / LengthFactors.metersPerAstronomicalUnit;

        expect(oneLightYear.inAU, closeTo(expectedAUperLY, astronomicalTolerance));

        // Test nearby star distance
        final proximaCentauri = 4.24.ly;
        const expectedProximaInAU = 4.24 * expectedAUperLY; // Calculate expected value
        expect(proximaCentauri.inAU, closeTo(expectedProximaInAU, astronomicalTolerance));
      });

      test('parsec conversions', () {
        final oneParsec = 1.0.pc;
        const expectedAUperPC =
            LengthFactors.metersPerParsec / LengthFactors.metersPerAstronomicalUnit;

        expect(oneParsec.inLy, closeTo(3.26156, astronomicalTolerance));
        expect(oneParsec.inAU, closeTo(expectedAUperPC, astronomicalTolerance));
        expect(oneParsec.inM, closeTo(3.0856775814913673e16, astronomicalTolerance));
      });

      test('astronomical distance relationships', () {
        // Test the relationship: 1 pc ‚âà 3.26 ly
        final oneParsec = 1.0.pc;
        final equivalentLy = oneParsec.inLy;
        expect(equivalentLy, closeTo(3.26156, astronomicalTolerance));

        // Test parallax relationship: distance in parsecs = 1 / parallax in arcseconds
        // For a star with 0.1 arcsecond parallax, distance should be 10 parsecs
        final starDistance = 10.0.pc;
        expect(starDistance.inLy, closeTo(32.6156, astronomicalTolerance));
      });
    });

    group('√Öngstr√∂m conversions', () {
      test('√•ngstr√∂m basic conversions', () {
        final oneAngstrom = 1.0.angstrom;
        expect(oneAngstrom.inM, closeTo(1e-10, tolerance));
        expect(oneAngstrom.inNm, closeTo(0.1, tolerance));
        expect(oneAngstrom.inPm, closeTo(100.0, tolerance));
      });

      test('atomic scale measurements', () {
        // Hydrogen atom radius ‚âà 0.529 √Ö (Bohr radius)
        final hydrogenRadius = 0.529.angstrom;
        expect(hydrogenRadius.inPm, closeTo(52.9, tolerance));
        expect(hydrogenRadius.inNm, closeTo(0.0529, tolerance));

        // X-ray wavelength ‚âà 1-10 √Ö
        final xrayWavelength = 1.54.angstrom; // Cu KŒ± radiation
        expect(xrayWavelength.inNm, closeTo(0.154, tolerance));
      });
    });

    group('Mixed unit arithmetic and comparisons', () {
      test('very different scales addition', () {
        final bigDistance = 1.0.ly;
        final smallDistance = 1.0.m;
        final combined = bigDistance + smallDistance;

        // The meter should be insignificant compared to light year
        expect(combined.inLy, closeTo(1.0, astronomicalTolerance));
        expect(combined.unit, LengthUnit.lightYear);
      });

      test('practical scientific measurements', () {
        // DNA double helix diameter ‚âà 20 √Ö
        final dnaDiameter = 20.0.angstrom;
        expect(dnaDiameter.inNm, closeTo(2.0, tolerance));

        // Wavelength of visible light: 400-700 nm
        final blueLight = 450.0.nm;
        final redLight = 650.0.nm;
        expect(blueLight.inAngstrom, closeTo(4500.0, tolerance));
        expect(redLight.inAngstrom, closeTo(6500.0, tolerance));

        // Compare with X-ray
        final xray = 1.0.angstrom;
        expect(blueLight.compareTo(xray), greaterThan(0)); // Visible light has longer wavelength
      });

      test('sorting astronomical distances', () {
        final distances = [
          1.pc, // ~3.26 ly
          10.ly, // 10 ly
          1000.AU, // ~0.016 ly
          1.ly, // 1 ly
          100000.AU, // ~1.58 ly
        ];

        distances.sort();

        // Should be sorted by magnitude: 1000 AU < 100000 AU < 1 ly < 1 pc < 10 ly
        expect(distances[0].unit, LengthUnit.astronomicalUnit);
        expect(distances[0].value, 1000.0);
        expect(distances[4].value, 10.0);
        expect(distances[4].unit, LengthUnit.lightYear);
      });
    });

    group('Round trip conversions for new units', () {
      const testValue = 123.456;

      test('SI prefix round trips', () {
        final units = [
          LengthUnit.hectometer,
          LengthUnit.decameter,
          LengthUnit.decimeter,
          LengthUnit.micrometer,
          LengthUnit.nanometer,
          LengthUnit.picometer,
          LengthUnit.femtometer,
        ];

        for (final unit in units) {
          final original = Length(testValue, unit);
          final converted = original.convertTo(LengthUnit.meter).convertTo(unit);
          expect(
            converted.value,
            closeTo(testValue, highTolerance),
            reason: 'Round trip failed for ${unit.symbol}',
          );
        }
      });

      test('astronomical unit round trips', () {
        final astronomicalUnits = [
          LengthUnit.astronomicalUnit,
          LengthUnit.lightYear,
          LengthUnit.parsec,
        ];

        for (final unit in astronomicalUnits) {
          final original = Length(testValue, unit);
          final converted = original.convertTo(LengthUnit.meter).convertTo(unit);
          expect(
            converted.value,
            closeTo(testValue, astronomicalTolerance),
            reason: 'Round trip failed for ${unit.symbol}',
          );
        }
      });

      test('√•ngstr√∂m round trip', () {
        const original = Length(testValue, LengthUnit.angstrom);
        final converted = original.convertTo(LengthUnit.meter).convertTo(LengthUnit.angstrom);
        expect(converted.value, closeTo(testValue, tolerance));
      });
    });

    group('toString formatting for new units', () {
      test('should display correct symbols', () {
        expect(1.0.hm.toString(), '1.0\u00A0hm');
        expect(1.0.dam.toString(), '1.0\u00A0dam');
        expect(1.0.dm.toString(), '1.0\u00A0dm');
        expect(1.0.um.toString(), '1.0\u00A0Œºm');
        expect(1.0.nm.toString(), '1.0\u00A0nm');
        expect(1.0.pm.toString(), '1.0\u00A0pm');
        expect(1.0.fm.toString(), '1.0\u00A0fm');
        expect(1.0.AU.toString(), '1.0\u00A0AU');
        expect(1.0.ly.toString(), '1.0\u00A0ly');
        expect(1.0.pc.toString(), '1.0\u00A0pc');
        expect(1.0.angstrom.toString(), '1.0\u00A0√Ö');
      });
    });
    group('Mega and Giga Units', () {
      const tolerance = 1e-9;

      test('megameter conversions', () {
        final oneMegameter = 1.0.megaM;
        expect(oneMegameter.inM, closeTo(1e6, tolerance));
        expect(oneMegameter.inKm, closeTo(1000.0, tolerance));
        expect(oneMegameter.inGigaM, closeTo(0.001, tolerance));
      });

      test('gigameter conversions', () {
        final oneGigameter = 1.0.gigaM;
        expect(oneGigameter.inM, closeTo(1e9, tolerance));
        expect(oneGigameter.inKm, closeTo(1e6, tolerance));
        expect(oneGigameter.inMegaM, closeTo(1000.0, tolerance));
      });

      test('astronomical scale examples', () {
        // Earth's diameter is about 12.742 Mm
        final earthDiameter = 12.742.megaM;
        expect(earthDiameter.inKm, closeTo(12742.0, tolerance));

        // Sun's diameter is about 1.3927 Gm
        final sunDiameter = 1.3927.gigaM;
        expect(sunDiameter.inMegaM, closeTo(1392.7, tolerance));
        expect(sunDiameter.inKm, closeTo(1392700.0, tolerance));

        // Compare Earth and Sun
        expect(sunDiameter.compareTo(earthDiameter), greaterThan(0));
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/length_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/luminous_intensity_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming LuminousIntensity and Unit are exported
import 'package:test/test.dart';

void main() {
  group('LuminousIntensity', () {
    const strictTolerance = 1e-12; // For "exact" conversions
    const defaultTolerance = 1e-9; // General purpose

    // Helper for round trip tests
    void testRoundTrip(
      LuminousIntensityUnit initialUnit,
      LuminousIntensityUnit intermediateUnit,
      double initialValue, {
      double tol = defaultTolerance,
    }) {
      final li1 = LuminousIntensity(initialValue, initialUnit);
      final li2 = li1.convertTo(intermediateUnit);
      final li3 = li2.convertTo(initialUnit);
      expect(
        li3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${li3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create LuminousIntensity from num extensions and retrieve values', () {
        final liCd = 100.0.cd;
        expect(liCd.value, 100.0);
        expect(liCd.unit, LuminousIntensityUnit.candela);
        expect(liCd.inMillicandelas, closeTo(100000.0, strictTolerance));
        expect(liCd.asMillicandelas.value, closeTo(100000.0, strictTolerance));
        expect(liCd.asMillicandelas.unit, LuminousIntensityUnit.millicandela);

        final liMcd = 250.0.millicandelas; // Using alias
        expect(liMcd.value, 250.0);
        expect(liMcd.unit, LuminousIntensityUnit.millicandela);
        expect(liMcd.inCandelas, closeTo(0.25, strictTolerance));

        final liKcd = 0.5.kcd;
        expect(liKcd.value, 0.5);
        expect(liKcd.unit, LuminousIntensityUnit.kilocandela);
        expect(liKcd.inCandelas, closeTo(500.0, strictTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const intensity = LuminousIntensity(15.0, LuminousIntensityUnit.candela);
        expect(intensity.getValue(LuminousIntensityUnit.candela), 15.0);
      });
    });

    group('Conversions between various luminous intensity units', () {
      final oneCandela = 1.0.cd;
      test('1 Candela to other units', () {
        expect(oneCandela.inMillicandelas, closeTo(1000.0, strictTolerance));
        expect(oneCandela.inKilocandelas, closeTo(0.001, strictTolerance));
      });

      final oneKilocandela = 1.0.kcd;
      test('1 Kilocandela to candelas and millicandelas', () {
        expect(oneKilocandela.inCandelas, closeTo(1000.0, strictTolerance));
        expect(oneKilocandela.inMillicandelas, closeTo(1000000.0, strictTolerance));
      });

      final oneMillicandela = 1.0.mcd;
      test('1 Millicandela to candelas', () {
        expect(oneMillicandela.inCandelas, closeTo(0.001, strictTolerance));
      });
    });

    group('convertTo method', () {
      test('should return new LuminousIntensity object with converted value and unit', () {
        final liMcd = 12500.0.mcd;
        final liCd = liMcd.convertTo(LuminousIntensityUnit.candela);

        expect(liCd.unit, LuminousIntensityUnit.candela);
        expect(liCd.value, closeTo(12.5, strictTolerance));
        expect(liMcd.unit, LuminousIntensityUnit.millicandela); // Original unchanged
        expect(liMcd.value, 12500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final li1 = 10.0.cd;
        final li2 = li1.convertTo(LuminousIntensityUnit.candela);
        expect(identical(li1, li2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final li1Cd = 1.0.cd;
      final li1000Mcd = 1000.0.mcd;
      final li999Mcd = 999.0.mcd;
      final li0_002Kcd = 0.002.kcd; // 2 cd
      final li0_0005Kcd = 0.0005.kcd; // 0.5 cd

      test('should correctly compare luminous intensities of different units', () {
        expect(li1Cd.compareTo(li999Mcd), greaterThan(0)); // 1cd > 999mcd
        expect(li999Mcd.compareTo(li1Cd), lessThan(0)); // 999mcd < 1cd
        expect(li1Cd.compareTo(li1000Mcd), 0); // 1cd == 1000mcd

        expect(li1Cd.compareTo(li0_002Kcd), lessThan(0)); // 1cd < 2cd
        expect(li1Cd.compareTo(li0_0005Kcd), greaterThan(0)); // 1cd > 0.5cd
      });

      test('should return 0 for equal luminous intensities in different units', () {
        final liInKcd = 0.001.kcd; // 1 cd in kilocandelas
        expect(li1Cd.compareTo(liInKcd), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const li1 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        const li2 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        expect(li1 == li2, isTrue);
        expect(li1.hashCode == li2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const li1 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        const li2Diffval = LuminousIntensity(50.1, LuminousIntensityUnit.candela);
        const li3Diffunit = LuminousIntensity(50.0, LuminousIntensityUnit.millicandela);

        expect(li1 == li2Diffval, isFalse);
        expect(li1 == li3Diffunit, isFalse);

        expect(li1.hashCode == li2Diffval.hashCode, isFalse);
        expect(li1.hashCode == li3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.cd is not equal to 1000.mcd', () {
        final oneCd = 1.cd;
        final thousandMcd = 1000.mcd;
        expect(oneCd == thousandMcd, isFalse);
        expect(oneCd.compareTo(thousandMcd), 0);
      });
    });

    group('toString() (basic check)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(75.5.cd.toString(), '75.5\u00A0cd');
        expect(120.mcd.toString(), '120.0\u00A0mcd');
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 123.456;

      for (final unit in LuminousIntensityUnit.values) {
        test('Round trip ${unit.symbol} <-> cd', () {
          testRoundTrip(
            unit,
            LuminousIntensityUnit.candela,
            testValue,
            tol: strictTolerance, // Factors are exact powers of 10
          );
        });
      }

      test('Round trip mcd <-> kcd', () {
        // Test with a value that doesn't become too small/large after conversion
        testRoundTrip(
          LuminousIntensityUnit.millicandela,
          LuminousIntensityUnit.kilocandela,
          500000.0,
          tol: strictTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final liZeroCd = 0.0.cd;
        for (final unit in LuminousIntensityUnit.values) {
          expect(liZeroCd.getValue(unit), 0.0, reason: '0 cd to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for LuminousIntensity', () {
      final li100cd = 100.0.cd;
      final li200cd = 200.0.cd;
      final li50000mcd = 50000.0.mcd; // 50 cd

      // Operator +
      test('operator + combines luminous intensities', () {
        final sum1 = li200cd + li100cd;
        expect(sum1.value, closeTo(300.0, defaultTolerance));
        expect(sum1.unit, LuminousIntensityUnit.candela);

        final sum2 = li100cd + li50000mcd; // 100cd + 50cd = 150cd
        expect(sum2.value, closeTo(150.0, defaultTolerance));
        expect(sum2.unit, LuminousIntensityUnit.candela);

        final sum3 = li50000mcd + li100cd; // 50000mcd + 100000mcd = 150000mcd
        expect(sum3.value, closeTo(150000.0, defaultTolerance));
        expect(sum3.unit, LuminousIntensityUnit.millicandela);
      });

      // Operator -
      test('operator - subtracts luminous intensities', () {
        final diff1 = li200cd - li100cd;
        expect(diff1.value, closeTo(100.0, defaultTolerance));
        expect(diff1.unit, LuminousIntensityUnit.candela);

        final diff2 = li100cd - li50000mcd; // 100cd - 50cd = 50cd
        expect(diff2.value, closeTo(50.0, defaultTolerance));
        expect(diff2.unit, LuminousIntensityUnit.candela);
      });

      // Operator * (scalar)
      test('operator * scales luminous intensity by a scalar', () {
        final scaled1 = li100cd * 2.5;
        expect(scaled1.value, closeTo(250.0, defaultTolerance));
        expect(scaled1.unit, LuminousIntensityUnit.candela);
      });

      // Operator / (scalar)
      test('operator / scales luminous intensity by a scalar', () {
        final scaled1 = li200cd / 4.0;
        expect(scaled1.value, closeTo(50.0, defaultTolerance));
        expect(scaled1.unit, LuminousIntensityUnit.candela);

        expect(() => li100cd / 0.0, throwsArgumentError);
      });

      test('operator chaining preserves immutability', () {
        final initialIntensity = 50.cd;
        final liAdd = initialIntensity + 10000.mcd; // 50cd + 10cd = 60cd
        final liMul = liAdd * 2.0; // 60cd * 2 = 120cd
        final liSub = liMul - 0.01.kcd; // 120cd - 10cd = 110cd

        expect(initialIntensity.value, 50.0);
        expect(initialIntensity.unit, LuminousIntensityUnit.candela);

        expect(liAdd.value, closeTo(60.0, defaultTolerance));
        expect(liAdd.unit, LuminousIntensityUnit.candela);

        expect(liMul.value, closeTo(120.0, defaultTolerance));
        expect(liMul.unit, LuminousIntensityUnit.candela);

        final expectedLiSubVal = 120.0 - 0.01.kcd.getValue(LuminousIntensityUnit.candela);
        expect(liSub.value, closeTo(expectedLiSubVal, defaultTolerance));
        expect(liSub.unit, LuminousIntensityUnit.candela);
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/luminous_intensity_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/mass_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming Mass and MassUnit are exported via quantify.dart
import 'package:quantify/src/units/mass/mass_factors.dart';
import 'package:test/test.dart';

void main() {
  const highPrecisiontolerance = 1e-12; // High precision for mass
  const highTolerance = 1e-7; // Higher tolerance for chained conversions or inexact factors
  const tolerance = 1e-9; // Tolerance for double comparisons
  const atomicTolerance = 1e-30; // For atomic mass units

  group('Mass', () {
    // Helper for round trip tests
    void testRoundTrip(
      MassUnit initialUnit,
      MassUnit intermediateUnit,
      double initialValue, {
      double tol = highTolerance, // Use highTolerance as default for round trips
    }) {
      final m1 = Mass(initialValue, initialUnit);
      final m2 = m1.convertTo(intermediateUnit);
      final m3 = m2.convertTo(initialUnit);
      expect(
        m3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${m3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create Mass from num extensions and retrieve values correctly', () {
        final mKg = 10.0.kg;
        expect(mKg.value, 10.0);
        expect(mKg.unit, MassUnit.kilogram);
        expect(mKg.inGrams, closeTo(10000.0, tolerance));
        expect(mKg.asGrams.value, closeTo(10000.0, tolerance));
        expect(mKg.asGrams.unit, MassUnit.gram);

        final mGrams = 500.0.grams; // Using alias
        expect(mGrams.value, 500.0);
        expect(mGrams.unit, MassUnit.gram);
        expect(mGrams.inKilograms, closeTo(0.5, tolerance));

        final mLbs = 2.0.pounds; // Using alias
        expect(mLbs.value, 2.0);
        expect(mLbs.unit, MassUnit.pound);
        // 2 lb * 0.45359237 kg/lb = 0.90718474 kg
        expect(mLbs.inKilograms, closeTo(0.90718474, highTolerance));

        final mOz = 16.0.oz; // 1 pound
        expect(mOz.value, 16.0);
        expect(mOz.unit, MassUnit.ounce);
        expect(mOz.inPounds, closeTo(1.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const mass = Mass(25.0, MassUnit.gram);
        expect(mass.getValue(MassUnit.gram), 25.0);
      });
    });

    group('Conversions between various units', () {
      final oneKg = 1.0.kg;
      test('1 Kilogram to other units', () {
        expect(oneKg.inGrams, closeTo(1000.0, tolerance));
        expect(oneKg.inMilligrams, closeTo(1000000.0, tolerance));
        expect(oneKg.inTonnes, closeTo(0.001, tolerance));
        expect(oneKg.inPounds, closeTo(1.0 / 0.45359237, highTolerance)); // ~2.20462 lbs
        expect(oneKg.inOunces, closeTo(16.0 / 0.45359237, highTolerance)); // ~35.27396 oz
        expect(oneKg.inStones, closeTo(1.0 / (14.0 * 0.45359237), highTolerance)); // ~0.15747 st
        expect(oneKg.inSlugs, closeTo(1.0 / 14.5939029372, highTolerance)); // ~0.06852 slugs
      });

      final onePound = 1.0.lb;
      test('1 Pound to other units', () {
        expect(onePound.inKilograms, closeTo(0.45359237, tolerance));
        expect(onePound.inGrams, closeTo(453.59237, tolerance));
        expect(onePound.inOunces, closeTo(16.0, tolerance));
        expect(onePound.inStones, closeTo(1.0 / 14.0, highTolerance));
      });

      final oneOunce = 1.0.oz;
      test('1 Ounce to grams', () {
        expect(oneOunce.inGrams, closeTo(0.45359237 * 1000.0 / 16.0, highTolerance)); // ~28.3495 g
      });

      final oneTonne = 1.0.t;
      test('1 Tonne to kilograms and pounds', () {
        expect(oneTonne.inKilograms, closeTo(1000.0, tolerance));
        expect(oneTonne.inPounds, closeTo(1000.0 / 0.45359237, highTolerance));
      });

      final oneSlug = 1.0.slugs;
      test('1 Slug to kilograms and pounds', () {
        expect(oneSlug.inKilograms, closeTo(14.5939029372, tolerance));
        expect(oneSlug.inPounds, closeTo(14.5939029372 / 0.45359237, highTolerance)); // ~32.174 lbs
      });
    });

    group('convertTo method', () {
      test('should return new Mass object with converted value and unit', () {
        final massGrams = 1500.0.g;
        final massKilograms = massGrams.convertTo(MassUnit.kilogram);

        expect(massKilograms.unit, MassUnit.kilogram);
        expect(massKilograms.value, closeTo(1.5, tolerance));
        expect(massGrams.unit, MassUnit.gram); // Original should be unchanged
        expect(massGrams.value, 1500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final m1 = 10.0.kg;
        final m2 = m1.convertTo(MassUnit.kilogram);
        expect(identical(m1, m2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final m1Kg = 1.0.kg;
      final m1000g = 1000.0.g;
      final m999g = 999.0.g;
      final m2lb = 2.0.lb; // approx 0.907 kg
      final m3lb = 3.0.lb; // approx 1.360 kg

      test('should correctly compare masses of different units', () {
        expect(m1Kg.compareTo(m999g), greaterThan(0)); // 1kg > 999g
        expect(m999g.compareTo(m1Kg), lessThan(0)); // 999g < 1kg
        expect(m1Kg.compareTo(m1000g), 0); // 1kg == 1000g

        expect(m1Kg.compareTo(m2lb), greaterThan(0)); // 1kg > 2lb
        expect(m1Kg.compareTo(m3lb), lessThan(0)); // 1kg < 3lb
      });

      test('should return 0 for equal masses in different units', () {
        final mInLbs = (1.0 / 0.45359237).pounds; // 1 kg in pounds
        expect(m1Kg.compareTo(mInLbs), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const m1 = Mass(10.0, MassUnit.kilogram);
        const m2 = Mass(10.0, MassUnit.kilogram);
        expect(m1 == m2, isTrue);
        expect(m1.hashCode == m2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const m1 = Mass(10.0, MassUnit.kilogram);
        const m2Diffval = Mass(10.1, MassUnit.kilogram);
        const m3Diffunit = Mass(10.0, MassUnit.gram);
        const m4Diffvalandunit = Mass(1.0, MassUnit.pound);

        expect(m1 == m2Diffval, isFalse);
        expect(m1 == m3Diffunit, isFalse);
        expect(m1 == m4Diffvalandunit, isFalse);

        expect(m1.hashCode == m2Diffval.hashCode, isFalse);
        // Hash collisions are possible but unlikely for these simple diffs
        expect(m1.hashCode == m3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.kg is not equal to 1000.g', () {
        // This confirms that `==` checks unit, not just magnitude.
        // For magnitude, `compareTo` is used.
        final oneKg = 1.kg;
        final thousandGrams = 1000.g;
        expect(oneKg == thousandGrams, isFalse);
        expect(oneKg.compareTo(thousandGrams), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(10.5.kg.toString(), '10.5\u00A0kg'); // \u00A0 is non-breaking space
        expect(500.grams.toString(), '500.0\u00A0g');
        expect(2.2.pounds.toString(), '2.2\u00A0lb');
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 123.456;

      // Test all units via Kilogram (the base for MassUnit)
      for (final unit in MassUnit.values) {
        test('Round trip ${unit.symbol} <-> kg', () {
          testRoundTrip(
            unit,
            MassUnit.kilogram,
            testValue,
            tol: (unit == MassUnit.kilogram) ? tolerance : highTolerance,
          );
        });
      }

      // Test some other common pairs
      test('Round trip g <-> mg', () {
        testRoundTrip(MassUnit.gram, MassUnit.milligram, testValue);
      });
      test('Round trip lb <-> oz', () {
        testRoundTrip(MassUnit.pound, MassUnit.ounce, testValue);
      });
      test('Round trip lb <-> st', () {
        testRoundTrip(
          MassUnit.pound,
          MassUnit.stone,
          28.0,
        ); // Test with a value that easily converts
      });
      test('Round trip kg <-> tonne', () {
        testRoundTrip(MassUnit.kilogram, MassUnit.tonne, 5000.0);
      });
      test('Round trip kg <-> slug', () {
        testRoundTrip(MassUnit.kilogram, MassUnit.slug, testValue);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final mZeroKg = 0.0.kg;
        for (final unit in MassUnit.values) {
          expect(mZeroKg.getValue(unit), 0.0, reason: '0 kg to ${unit.symbol} should be 0');
        }

        final mZeroLb = 0.0.lb;
        for (final unit in MassUnit.values) {
          expect(mZeroLb.getValue(unit), 0.0, reason: '0 lb to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with negative value (mass is typically positive, but math should work)', () {
        final mNegativeKg = (-10.0).kg;
        expect(mNegativeKg.inGrams, closeTo(-10000.0, tolerance));
        expect(mNegativeKg.inPounds, closeTo(-10.0 / 0.45359237, highTolerance));
      });
    });

    group('Arithmetic Operators for Mass', () {
      final m1kg = 1.0.kg;
      final m2kg = 2.0.kg;
      final m500g = 500.g; // 0.5 kg
      final m1lb = 1.lb; // 0.45359237 kg

      // Operator +
      test('operator + combines masses, result in unit of left operand', () {
        final sum1 = m2kg + m1kg;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, MassUnit.kilogram);

        final sum2 = m1kg + m500g; // 1kg + 0.5kg = 1.5kg
        expect(sum2.value, closeTo(1.5, tolerance));
        expect(sum2.unit, MassUnit.kilogram);

        final sum3 = m500g + m1kg; // 500g + 1000g = 1500g
        expect(sum3.value, closeTo(1500.0, tolerance));
        expect(sum3.unit, MassUnit.gram);

        final sum4 = m1kg + m1lb; // 1kg + 0.45359237kg
        expect(sum4.value, closeTo(1.0 + 0.45359237, highTolerance));
        expect(sum4.unit, MassUnit.kilogram);
      });

      // Operator -
      test('operator - subtracts masses, result in unit of left operand', () {
        final diff1 = m2kg - m1kg;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, MassUnit.kilogram);

        final diff2 = m1kg - m500g; // 1kg - 0.5kg = 0.5kg
        expect(diff2.value, closeTo(0.5, tolerance));
        expect(diff2.unit, MassUnit.kilogram);

        final diff3 = m1kg - m1lb; // 1kg - 0.45359237kg
        expect(diff3.value, closeTo(1.0 - 0.45359237, highTolerance));
        expect(diff3.unit, MassUnit.kilogram);
      });

      // Operator * (scalar)
      test('operator * scales mass by a scalar', () {
        final scaled1 = m2kg * 3.5;
        expect(scaled1.value, closeTo(7.0, tolerance));
        expect(scaled1.unit, MassUnit.kilogram);

        final scaled2 = m500g * 0.5;
        expect(scaled2.value, closeTo(250.0, tolerance));
        expect(scaled2.unit, MassUnit.gram);
      });

      // Operator / (scalar)
      test('operator / scales mass by a scalar', () {
        final scaled1 = m2kg / 4.0;
        expect(scaled1.value, closeTo(0.5, tolerance));
        expect(scaled1.unit, MassUnit.kilogram);

        final scaled2 = m1kg / 0.1;
        expect(scaled2.value, closeTo(10.0, tolerance));
        expect(scaled2.unit, MassUnit.kilogram);

        expect(() => m1kg / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialMass = 10.kg;
        final mAdd = initialMass + 500.g; // 10kg + 0.5kg = 10.5kg
        final mMul = mAdd * 2.0; // 10.5kg * 2 = 21kg
        final mSub = mMul - 1.lb; // 21kg - ~0.45kg

        expect(initialMass.value, 10.0); // Original unchanged
        expect(initialMass.unit, MassUnit.kilogram);

        expect(mAdd.value, closeTo(10.5, tolerance));
        expect(mAdd.unit, MassUnit.kilogram);

        expect(mMul.value, closeTo(21.0, tolerance));
        expect(mMul.unit, MassUnit.kilogram);

        final expectedMSubVal = 21.0 - 1.0.lb.getValue(MassUnit.kilogram);
        expect(mSub.value, closeTo(expectedMSubVal, highTolerance));
        expect(mSub.unit, MassUnit.kilogram);
      });
    });
  });

  group('Extended Mass Units', () {
    group('SI Prefix Units', () {
      test('hectogram conversions', () {
        final oneHectogram = 1.0.hg;
        expect(oneHectogram.inKilograms, closeTo(0.1, highPrecisiontolerance));
        expect(oneHectogram.inGrams, closeTo(100.0, highPrecisiontolerance));
        expect(oneHectogram.inDecagrams, closeTo(10.0, highPrecisiontolerance));
      });

      test('decagram conversions', () {
        final oneDecagram = 1.0.dag;
        expect(oneDecagram.inKilograms, closeTo(0.01, highPrecisiontolerance));
        expect(oneDecagram.inGrams, closeTo(10.0, highPrecisiontolerance));
        expect(oneDecagram.inHectograms, closeTo(0.1, highPrecisiontolerance));
      });

      test('decigram conversions', () {
        final oneDecigram = 1.0.dg;
        expect(oneDecigram.inGrams, closeTo(0.1, highPrecisiontolerance));
        expect(oneDecigram.inCentigrams, closeTo(10.0, highPrecisiontolerance));
        expect(oneDecigram.inMilligrams, closeTo(100.0, highPrecisiontolerance));
      });

      test('centigram conversions', () {
        final oneCentigram = 1.0.cg;
        expect(oneCentigram.inGrams, closeTo(0.01, highPrecisiontolerance));
        expect(oneCentigram.inDecigrams, closeTo(0.1, highPrecisiontolerance));
        expect(oneCentigram.inMilligrams, closeTo(10.0, highPrecisiontolerance));
      });

      test('microgram conversions', () {
        final oneMicrogram = 1.0.ug;
        expect(oneMicrogram.inGrams, closeTo(1e-6, highPrecisiontolerance));
        expect(oneMicrogram.inMilligrams, closeTo(0.001, highPrecisiontolerance));
        expect(oneMicrogram.inNanograms, closeTo(1000.0, highPrecisiontolerance));
      });

      test('nanogram conversions', () {
        final oneNanogram = 1.0.ng;
        expect(oneNanogram.inGrams, closeTo(1e-9, highPrecisiontolerance));
        expect(oneNanogram.inMicrograms, closeTo(0.001, highPrecisiontolerance));
        expect(oneNanogram.inKilograms, closeTo(1e-12, highPrecisiontolerance));
      });
    });

    group('Imperial Ton Units', () {
      test('short ton (US) conversions', () {
        final oneShortTon = 1.0.shortTons;
        expect(oneShortTon.inPounds, closeTo(2000.0, highPrecisiontolerance));
        expect(oneShortTon.inKilograms, closeTo(907.18474, tolerance));
        expect(oneShortTon.inTonnes, closeTo(0.90718474, tolerance));
      });

      test('long ton (UK) conversions', () {
        final oneLongTon = 1.0.longTons;
        expect(oneLongTon.inPounds, closeTo(2240.0, highPrecisiontolerance));
        expect(oneLongTon.inKilograms, closeTo(1016.0469088, tolerance));
        expect(oneLongTon.inTonnes, closeTo(1.0160469088, tolerance));
      });

      test('ton comparisons', () {
        final shortTon = 1.0.shortTons;
        final longTon = 1.0.longTons;
        final metricTon = 1.0.tonnes;

        // Long ton > Metric ton > Short ton
        expect(longTon.compareTo(metricTon), greaterThan(0));
        expect(metricTon.compareTo(shortTon), greaterThan(0));
        expect(longTon.compareTo(shortTon), greaterThan(0));
      });
    });

    group('Special Units', () {
      test('atomic mass unit conversions', () {
        final oneAMU = 1.0.u;
        expect(oneAMU.inKilograms, closeTo(1.66053906660e-27, atomicTolerance));
        expect(oneAMU.inGrams, closeTo(1.66053906660e-24, atomicTolerance));

        // Carbon-12 has exactly 12 u
        final carbon12 = 12.0.u;
        expect(carbon12.inKilograms, closeTo(12.0 * 1.66053906660e-27, atomicTolerance));

        // Test Avogadro's number relationship
        // 1 mole of carbon-12 = 12 g = 12 u √ó N_A
        const avogadroNumber = 6.02214076e23;
        const oneMoleCarbon12InKg = 0.012; // 12 g
        final oneAtomCarbon12InKg = carbon12.inKilograms;
        final calculatedAvogadro = oneMoleCarbon12InKg / oneAtomCarbon12InKg;
        expect(calculatedAvogadro, closeTo(avogadroNumber, avogadroNumber * 1e-6));
      });

      test('carat conversions', () {
        final oneCarat = 1.0.ct;
        expect(oneCarat.inGrams, closeTo(0.2, highPrecisiontolerance));
        expect(oneCarat.inKilograms, closeTo(0.0002, highPrecisiontolerance));
        expect(oneCarat.inMilligrams, closeTo(200.0, highPrecisiontolerance));

        // Typical diamond weights
        final halfCarat = 0.5.ct;
        final twoCarats = 2.0.ct;
        expect(halfCarat.inGrams, closeTo(0.1, highPrecisiontolerance));
        expect(twoCarats.inGrams, closeTo(0.4, highPrecisiontolerance));
      });

      test('atomic scale examples', () {
        // Hydrogen atom mass ‚âà 1.008 u
        final hydrogenMass = 1.008.u;
        const expectedHydrogenInKg = 1.008 * MassFactors.kilogramsPerAtomicMassUnit;
        expect(hydrogenMass.inKilograms, closeTo(expectedHydrogenInKg, 1e-30));

        // Electron mass ‚âà 0.000549 u
        final electronMassInU = 0.000549.u;
        const expectedElectronInKg = 0.000549 * MassFactors.kilogramsPerAtomicMassUnit;
        // Test the conversion, not the standard value of electron mass in kg
        expect(electronMassInU.inKilograms, closeTo(expectedElectronInKg, 1e-34));

        // Compare electron to proton (‚âà 1.007 u)
        final protonMass = 1.007.u;
        expect(protonMass.compareTo(electronMassInU), greaterThan(0));
      });

      group('Practical measurement examples', () {
        test('pharmaceutical dosages', () {
          // Common drug dosages are in milligrams
          final aspirinTablet = 325.mg;
          final vitaminC = 1000.mg;

          expect(aspirinTablet.inGrams, closeTo(0.325, highPrecisiontolerance));
          expect(vitaminC.inGrams, closeTo(1.0, highPrecisiontolerance));

          // Microgram dosages for potent drugs
          final folicAcid = 400.ug;
          expect(folicAcid.inMilligrams, closeTo(0.4, highPrecisiontolerance));
        });

        test('jewelry and precious materials', () {
          // Gold jewelry - typical weights
          final goldRing = 3.5.g;
          final goldNecklace = 15.2.g;

          expect(goldRing.inOunces, closeTo(0.1235, 1e-4));
          expect(goldNecklace.inOunces, closeTo(0.53616, 1e-4));

          // Diamond weights in carats
          final engagementRing = 1.5.ct;
          final earrings = 0.75.ct; // Total for both

          expect(engagementRing.inGrams, closeTo(0.3, highPrecisiontolerance));
          expect(earrings.inGrams, closeTo(0.15, highPrecisiontolerance));
        });

        test('shipping and cargo', () {
          // Freight shipping weights
          final containerLimit = 30.tonnes;
          final truckLoad = 40000.pounds;

          expect(containerLimit.inKilograms, closeTo(30000.0, highPrecisiontolerance));
          expect(truckLoad.inTonnes, closeTo(18.1436948, tolerance));

          // Compare different ton types for cargo
          final usShipping = 20.shortTons;
          final ukShipping = 20.longTons;
          final metricShipping = 20.tonnes;

          expect(ukShipping.compareTo(metricShipping), greaterThan(0));
          expect(metricShipping.compareTo(usShipping), greaterThan(0));
        });
      });

      group('Round trip conversions for new units', () {
        const testValue = 567.89;

        test('SI prefix round trips', () {
          final units = [
            MassUnit.hectogram,
            MassUnit.decagram,
            MassUnit.decigram,
            MassUnit.centigram,
            MassUnit.microgram,
            MassUnit.nanogram,
          ];

          for (final unit in units) {
            final original = Mass(testValue, unit);
            final converted = original.convertTo(MassUnit.kilogram).convertTo(unit);
            expect(
              converted.value,
              closeTo(testValue, tolerance),
              reason: 'Round trip failed for ${unit.symbol}',
            );
          }
        });

        test('special unit round trips', () {
          // Test atomic mass unit with smaller value due to extreme scale
          const amuOriginal = Mass(12.011, MassUnit.atomicMassUnit); // Carbon average
          final amuConverted =
              amuOriginal.convertTo(MassUnit.kilogram).convertTo(MassUnit.atomicMassUnit);
          expect(amuConverted.value, closeTo(12.011, tolerance));

          // Test carat
          const caratOriginal = Mass(testValue, MassUnit.carat);
          final caratConverted =
              caratOriginal.convertTo(MassUnit.kilogram).convertTo(MassUnit.carat);
          expect(caratConverted.value, closeTo(testValue, highPrecisiontolerance));

          // Test tons
          const shortTonOriginal = Mass(testValue, MassUnit.shortTon);
          final shortTonConverted =
              shortTonOriginal.convertTo(MassUnit.kilogram).convertTo(MassUnit.shortTon);
          expect(shortTonConverted.value, closeTo(testValue, tolerance));
        });
      });

      group('toString formatting for new units', () {
        test('should display correct symbols', () {
          expect(1.0.hg.toString(), '1.0\u00A0hg');
          expect(1.0.dag.toString(), '1.0\u00A0dag');
          expect(1.0.dg.toString(), '1.0\u00A0dg');
          expect(1.0.cg.toString(), '1.0\u00A0cg');
          expect(1.0.ug.toString(), '1.0\u00A0Œºg');
          expect(1.0.ng.toString(), '1.0\u00A0ng');
          expect(1.0.shortTons.toString(), '1.0\u00A0short ton');
          expect(1.0.longTons.toString(), '1.0\u00A0long ton');
          expect(1.0.u.toString(), '1.0\u00A0u');
          expect(1.0.ct.toString(), '1.0\u00A0ct');
        });
      });

      group('Mixed unit arithmetic', () {
        test('adding very different scales', () {
          final bigMass = 1.0.tonnes;
          final smallMass = 1.0.mg;
          final combined = bigMass + smallMass;

          // Milligram should be negligible compared to tonne
          expect(combined.inTonnes, closeTo(1.0, highTolerance));
          expect(combined.unit, MassUnit.tonne);
        });

        test('precision in small scale arithmetic', () {
          final drug1 = 250.ug; // micrograms
          final drug2 = 750.ug;
          final totalDose = drug1 + drug2;

          expect(totalDose.inMicrograms, closeTo(1000.0, highPrecisiontolerance));
          expect(totalDose.inMilligrams, closeTo(1.0, highPrecisiontolerance));
        });

        test('atomic mass arithmetic', () {
          // Water molecule: 2 H + 1 O
          final hydrogen = 1.008.u;
          final oxygen = 15.999.u;
          final waterMass = (hydrogen * 2) + oxygen;

          expect(waterMass.inAtomicMassUnits, closeTo(18.015, highPrecisiontolerance));
        });
      });
    });

    group('Mega and Giga Units', () {
      const tolerance = 1e-9;

      test('megagram conversions and equivalence with tonne', () {
        // Use the new explicit extension `megaG`
        final oneMegagram = 1.0.megaG;
        expect(oneMegagram.inKilograms, closeTo(1000.0, tolerance));
        expect(oneMegagram.inGrams, closeTo(1e6, tolerance));

        // Megagram should be equivalent to tonne
        final oneTonne = 1.0.t;
        expect(oneMegagram.compareTo(oneTonne), 0);
        expect(oneMegagram.inTonnes, closeTo(1.0, tolerance));
      });

      test('gigagram conversions', () {
        // Use the new explicit extension `gigaG`
        final oneGigagram = 1.0.gigaG;
        expect(oneGigagram.inKilograms, closeTo(1e6, tolerance));
        // Use the new explicit getter `inMegaG`
        expect(oneGigagram.inMegaG, closeTo(1000.0, tolerance));
        expect(oneGigagram.inTonnes, closeTo(1000.0, tolerance));
      });

      test('large scale mass examples', () {
        // Mass of a large bridge might be in gigagrams
        final bridgeMass = 50.0.gigaG; // 50,000 tonnes
        expect(bridgeMass.inTonnes, closeTo(50000.0, tolerance));

        // Compare with a space shuttle mass (~2 Gg)
        final shuttleMass = 2.0.gigaG;
        expect(bridgeMass.compareTo(shuttleMass), greaterThan(0));
      });

      test('round trip conversions for mega and giga', () {
        const testValue = 123.456;
        // Test round trip via kilograms
        final originalMega = testValue.megaG;
        final roundTripMega = originalMega.asKilograms.asMegaG;
        expect(roundTripMega.value, closeTo(testValue, tolerance));

        final originalGiga = testValue.gigaG;
        final roundTripGiga = originalGiga.asKilograms.asGigaG;
        expect(roundTripGiga.value, closeTo(testValue, tolerance));
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/mass_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/molar_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming MolarAmount and MolarUnit are exported
import 'package:test/test.dart';

void main() {
  group('MolarAmount', () {
    const tolerance = 1e-12; // Molar amounts can be very small, requiring higher precision
    const defaultTolerance = 1e-9; // For general comparisons

    // Helper for round trip tests
    void testRoundTrip(
      MolarUnit initialUnit,
      MolarUnit intermediateUnit,
      double initialValue, {
      double tol = tolerance, // Default to higher precision for molar round trips
    }) {
      final ma1 = MolarAmount(initialValue, initialUnit);
      final ma2 = ma1.convertTo(intermediateUnit);
      final ma3 = ma2.convertTo(initialUnit);
      expect(
        ma3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${ma3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create MolarAmount from num extensions and retrieve values correctly', () {
        final maMol = 0.5.mol;
        expect(maMol.value, 0.5);
        expect(maMol.unit, MolarUnit.mole);
        expect(maMol.inMillimoles, closeTo(500.0, tolerance));
        expect(maMol.asMillimoles.value, closeTo(500.0, tolerance));
        expect(maMol.asMillimoles.unit, MolarUnit.millimole);

        final maMmol = 2500.0.millimoles; // Using alias
        expect(maMmol.value, 2500.0);
        expect(maMmol.unit, MolarUnit.millimole);
        expect(maMmol.inMoles, closeTo(2.5, tolerance));

        final maUmol = 1234.0.umol;
        expect(maUmol.value, 1234.0);
        expect(maUmol.unit, MolarUnit.micromole);
        expect(maUmol.inMoles, closeTo(0.001234, tolerance));
        expect(maUmol.inNanomoles, closeTo(1234000.0, 1e-9));
      });

      test('getValue should return correct value for same unit', () {
        const molarAmount = MolarAmount(0.025, MolarUnit.mole);
        expect(molarAmount.getValue(MolarUnit.mole), 0.025);
      });
    });

    group('Conversions between various molar units', () {
      final oneMole = 1.0.mol;
      test('1 Mole to other units', () {
        expect(oneMole.inKilomoles, closeTo(0.001, tolerance));
        expect(oneMole.inMillimoles, closeTo(1000.0, tolerance));
        expect(oneMole.inMicromoles, closeTo(1000000.0, tolerance));
        expect(oneMole.inNanomoles, closeTo(1.0e9, 1e-6));
        expect(oneMole.inPicomoles, closeTo(1.0e12, tolerance));
      });

      final oneKiloMole = 1.0.kmol;
      test('1 Kilomole to moles', () {
        expect(oneKiloMole.inMoles, closeTo(1000.0, tolerance));
      });

      final oneMilliMole = 1.0.mmol;
      test('1 Millimole to micromoles and moles', () {
        expect(oneMilliMole.inMicromoles, closeTo(1000.0, tolerance));
        expect(oneMilliMole.inMoles, closeTo(0.001, tolerance));
      });

      final oneNanoMole = 123.0.nmol;
      test('123 Nanomoles to picomoles and micromoles', () {
        expect(oneNanoMole.inPicomoles, closeTo(123000.0, 1e-10));
        expect(oneNanoMole.inMicromoles, closeTo(0.123, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new MolarAmount object with converted value and unit', () {
        final maMmol = 1500.0.mmol;
        final maMol = maMmol.convertTo(MolarUnit.mole);

        expect(maMol.unit, MolarUnit.mole);
        expect(maMol.value, closeTo(1.5, tolerance));
        expect(maMmol.unit, MolarUnit.millimole); // Original should be unchanged
        expect(maMmol.value, 1500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final ma1 = 0.1.mol;
        final ma2 = ma1.convertTo(MolarUnit.mole);
        expect(identical(ma1, ma2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final ma1Mol = 1.0.mol;
      final ma1000Mmol = 1000.0.mmol;
      final ma999Mmol = 999.0.mmol;
      final ma0_1Kmol = 0.1.kmol; // 100 mol
      final ma0_0001Kmol = 0.0001.kmol; // 0.1 mol

      test('should correctly compare molar amounts of different units', () {
        expect(ma1Mol.compareTo(ma999Mmol), greaterThan(0)); // 1mol > 999mmol
        expect(ma999Mmol.compareTo(ma1Mol), lessThan(0)); // 999mmol < 1mol
        expect(ma1Mol.compareTo(ma1000Mmol), 0); // 1mol == 1000mmol

        expect(ma1Mol.compareTo(ma0_1Kmol), lessThan(0)); // 1mol < 100mol
        expect(ma1Mol.compareTo(ma0_0001Kmol), greaterThan(0)); // 1mol > 0.1mol
      });

      test('should return 0 for equal molar amounts in different units', () {
        final maInUmol = 1000000.0.umol; // 1 mol in micromoles
        expect(ma1Mol.compareTo(maInUmol), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const ma1 = MolarAmount(0.05, MolarUnit.mole);
        const ma2 = MolarAmount(0.05, MolarUnit.mole);
        expect(ma1 == ma2, isTrue);
        expect(ma1.hashCode == ma2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const ma1 = MolarAmount(0.05, MolarUnit.mole);
        const ma2Diffval = MolarAmount(0.051, MolarUnit.mole);
        const ma3Diffunit = MolarAmount(0.05, MolarUnit.millimole);
        const ma4Diffvalandunit = MolarAmount(1.0, MolarUnit.kilomole);

        expect(ma1 == ma2Diffval, isFalse);
        expect(ma1 == ma3Diffunit, isFalse);
        expect(ma1 == ma4Diffvalandunit, isFalse);

        expect(ma1.hashCode == ma2Diffval.hashCode, isFalse);
        expect(ma1.hashCode == ma3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.mol is not equal to 1000.mmol', () {
        final oneMol = 1.mol;
        final thousandMmol = 1000.mmol;
        expect(oneMol == thousandMmol, isFalse);
        expect(oneMol.compareTo(thousandMmol), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(0.25.mol.toString(), '0.25\u00A0mol');
        expect(123.micromoles.toString(), '123.0\u00A0¬µmol'); // Note ¬µ symbol
        expect(
          1.5e-9.nmol.toString(),
          '1.5e-9\u00A0nmol',
        ); // Scientific notation from double.toString()
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 0.0123456789;

      // Test all units via Mole (the base for MolarUnit)
      for (final unit in MolarUnit.values) {
        test('Round trip ${unit.symbol} <-> mol', () {
          testRoundTrip(
            unit,
            MolarUnit.mole,
            testValue,
            tol: (unit == MolarUnit.mole) ? tolerance : tolerance, // Use high precision always
          );
        });
      }

      // Test some other common pairs
      test('Round trip mmol <-> ¬µmol', () {
        testRoundTrip(MolarUnit.millimole, MolarUnit.micromole, 0.5);
      });
      test('Round trip nmol <-> pmol', () {
        testRoundTrip(MolarUnit.nanomole, MolarUnit.picomole, 0.005);
      });
      test('Round trip mol <-> kmol', () {
        testRoundTrip(MolarUnit.mole, MolarUnit.kilomole, 2500.0);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final maZeroMol = 0.0.mol;
        for (final unit in MolarUnit.values) {
          expect(maZeroMol.getValue(unit), 0.0, reason: '0 mol to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with very small and large values', () {
        final verySmall = 1.0e-15.mol; // femtomoles range
        expect(verySmall.inPicomoles, closeTo(0.001, tolerance));

        final veryLarge = 1.0e6.mol; // megamoles range
        expect(veryLarge.inKilomoles, closeTo(1000.0, tolerance));
      });
    });

    group('Arithmetic Operators for MolarAmount', () {
      final ma1mol = 1.0.mol;
      final ma2mol = 2.0.mol;
      final ma500mmol = 500.mmol; // 0.5 mol
      final ma100umol = 100.umol; // 0.0001 mol

      // Operator +
      test('operator + combines molar amounts, result in unit of left operand', () {
        final sum1 = ma2mol + ma1mol;
        expect(sum1.value, closeTo(3.0, defaultTolerance));
        expect(sum1.unit, MolarUnit.mole);

        final sum2 = ma1mol + ma500mmol; // 1mol + 0.5mol = 1.5mol
        expect(sum2.value, closeTo(1.5, defaultTolerance));
        expect(sum2.unit, MolarUnit.mole);

        final sum3 = ma500mmol + ma1mol; // 500mmol + 1000mmol = 1500mmol
        expect(sum3.value, closeTo(1500.0, defaultTolerance));
        expect(sum3.unit, MolarUnit.millimole);

        final sum4 = ma1mol + ma100umol; // 1mol + 0.0001mol
        expect(sum4.value, closeTo(1.0 + 0.0001, tolerance));
        expect(sum4.unit, MolarUnit.mole);
      });

      // Operator -
      test('operator - subtracts molar amounts, result in unit of left operand', () {
        final diff1 = ma2mol - ma1mol;
        expect(diff1.value, closeTo(1.0, defaultTolerance));
        expect(diff1.unit, MolarUnit.mole);

        final diff2 = ma1mol - ma500mmol; // 1mol - 0.5mol = 0.5mol
        expect(diff2.value, closeTo(0.5, defaultTolerance));
        expect(diff2.unit, MolarUnit.mole);

        final diff3 = ma1mol - ma100umol; // 1mol - 0.0001mol
        expect(diff3.value, closeTo(1.0 - 0.0001, tolerance));
        expect(diff3.unit, MolarUnit.mole);
      });

      // Operator * (scalar)
      test('operator * scales molar amount by a scalar', () {
        final scaled1 = ma2mol * 3.5;
        expect(scaled1.value, closeTo(7.0, defaultTolerance));
        expect(scaled1.unit, MolarUnit.mole);

        final scaled2 = ma500mmol * 0.1;
        expect(scaled2.value, closeTo(50.0, defaultTolerance));
        expect(scaled2.unit, MolarUnit.millimole);
      });

      // Operator / (scalar)
      test('operator / scales molar amount by a scalar', () {
        final scaled1 = ma2mol / 4.0;
        expect(scaled1.value, closeTo(0.5, defaultTolerance));
        expect(scaled1.unit, MolarUnit.mole);

        final scaled2 = ma1mol / 0.01;
        expect(scaled2.value, closeTo(100.0, defaultTolerance));
        expect(scaled2.unit, MolarUnit.mole);

        expect(() => ma1mol / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialAmount = 0.1.mol;
        final maAdd = initialAmount + 50.mmol; // 0.1mol + 0.05mol = 0.15mol
        final maMul = maAdd * 10.0; // 0.15mol * 10 = 1.5mol
        final maSub = maMul - 100000.umol; // 1.5mol - 0.1mol = 1.4mol

        expect(initialAmount.value, 0.1); // Original unchanged
        expect(initialAmount.unit, MolarUnit.mole);

        expect(maAdd.value, closeTo(0.15, tolerance));
        expect(maAdd.unit, MolarUnit.mole);

        expect(maMul.value, closeTo(1.5, tolerance));
        expect(maMul.unit, MolarUnit.mole);

        final expectedMaSubVal = 1.5 - 100000.0.umol.getValue(MolarUnit.mole);
        expect(maSub.value, closeTo(expectedMaSubVal, tolerance));
        expect(maSub.unit, MolarUnit.mole);
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/molar_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/pressure_test.dart -->
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons

  group('Pressure', () {
    // Helper for round trip tests
    void testRoundTrip(
      PressureUnit initialUnit,
      PressureUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final p1 = Pressure(initialValue, initialUnit);
      final p2 = p1.convertTo(intermediateUnit);
      final p3 = p2.convertTo(initialUnit);
      expect(
        p3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Pressure from num extensions and retrieve values', () {
        final p1 = 101325.0.pa;
        expect(p1.value, 101325.0);
        expect(p1.unit, PressureUnit.pascal);
        expect(p1.inAtm, closeTo(1.0, 1e-9));

        final p2 = 1.0.atm;
        expect(p2.value, 1.0);
        expect(p2.unit, PressureUnit.atmosphere);
        expect(p2.inPa, closeTo(101325.0, 1e-9));

        final p3 = 30.0.psi;
        expect(p3.inPsi, 30.0);
        expect(p3.unit, PressureUnit.psi);

        final p4 = 1000.mbar; // millibars
        expect(p4.inMbar, 1000.0);
        expect(p4.inHPa, closeTo(1000.0, 1e-9)); // mbar and hPa are often same scale
        expect(p4.inBar, closeTo(1.0, 1e-9));
      });

      test('getValue should return correct value for same unit', () {
        const p = Pressure(15, PressureUnit.psi);
        expect(p.getValue(PressureUnit.psi), 15.0);
      });

      test('getValue for all units from Pascal base', () {
        final p = 100000.0.pa; // 1 bar
        expect(p.inPa, 100000.0);
        expect(p.inAtm, closeTo(100000.0 / 101325.0, 1e-7));
        expect(p.inBar, closeTo(1.0, 1e-9));
        expect(p.inPsi, closeTo(100000.0 / 6894.757293168361, 1e-7));
        expect(p.inTorr, closeTo(100000.0 / (101325.0 / 760.0), 1e-7));
        expect(p.inMmHg, closeTo(100000.0 / (101325.0 / 760.0), 1e-7));
        expect(
          p.inInHg,
          closeTo(
            100000.0 / ((101325.0 / 760.0) * 25.4),
            1e-6,
          ),
        ); // Higher tolerance due to more factors
        expect(p.inKPa, closeTo(100.0, 1e-9));
        expect(p.inHPa, closeTo(1000.0, 1e-9));
        expect(p.inMbar, closeTo(1000.0, 1e-9));
        expect(p.inCmH2O, closeTo(100000.0 / 98.0665, 1e-7));
        expect(p.inInH2O, closeTo(100000.0 / 249.08891, 1e-7));
      });
    });

    group('Conversions', () {
      final oneAtm = 1.0.atm;

      test('1 atm to Pascals', () {
        expect(oneAtm.inPa, closeTo(101325.0, 1e-9));
      });
      test('1 atm to Bars', () {
        expect(oneAtm.inBar, closeTo(1.01325, 1e-9));
      });
      test('1 atm to PSI', () {
        expect(oneAtm.inPsi, closeTo(14.695948775513, 1e-7));
      });
      test('1 atm to Torr (mmHg)', () {
        expect(oneAtm.inTorr, closeTo(760.0, 1e-9));
        expect(oneAtm.inMmHg, closeTo(760.0, 1e-9));
      });
      test('1 atm to Inches of Mercury', () {
        expect(oneAtm.inInHg, closeTo(760.0 / 25.4, 1e-7));
      });
      test('1 atm to Kilopascals', () {
        expect(oneAtm.inKPa, closeTo(101.325, 1e-9));
      });
      test('1 atm to Hectopascals/Millibars', () {
        expect(oneAtm.inHPa, closeTo(1013.25, 1e-9));
        expect(oneAtm.inMbar, closeTo(1013.25, 1e-9));
      });
      test('1 atm to cmH2O', () {
        expect(oneAtm.inCmH2O, closeTo(101325.0 / 98.0665, 1e-7));
      });
      test('1 atm to inH2O', () {
        expect(oneAtm.inInH2O, closeTo(101325.0 / 249.08891, 1e-7));
      });

      // Test specific tricky conversions
      test('PSI to Bar', () {
        final pPsi = 29.0.psi; // Approx 1.99948 bar
        expect(pPsi.inBar, closeTo(29.0 * 6894.757293168361 / 100000.0, 1e-7));
      });

      test('Bar to PSI', () {
        final pBar = 2.0.bar; // Approx 29.0075 psi
        expect(pBar.inPsi, closeTo(2.0 * 100000.0 / 6894.757293168361, 1e-7));
      });

      test('inH2O to Pa', () {
        final pInH2O = 10.0.inH2O;
        expect(pInH2O.inPa, closeTo(10.0 * 249.08891, 1e-7));
      });
    });

    group('convertTo method', () {
      test('should return new Pressure object with converted value and unit', () {
        final pPsi = 29.0.psi;
        final pBar = pPsi.convertTo(PressureUnit.bar);
        expect(pBar.unit, PressureUnit.bar);
        expect(pBar.value, closeTo(pPsi.inBar, 1e-9));
        expect(pPsi.unit, PressureUnit.psi); // Original should be unchanged
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final p1 = 10.0.pa;
        final p2 = p1.convertTo(PressureUnit.pascal);
        expect(identical(p1, p2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final pBar = 1.0.bar; // 100000 Pa
      final pPsiSlightlyLess = 14.5.psi; // 14.5 * 6894.757... ‚âà 99973.98 Pa
      final pPsiSlightlyMore = 14.6.psi; // 14.6 * 6894.757... ‚âà 100663.4 Pa
      final pAtm = 1.0.atm; // 101325 Pa

      test('should correctly compare pressures of different units', () {
        expect(pBar.compareTo(pPsiSlightlyLess), greaterThan(0)); // 1 bar > 14.5 psi
        expect(pPsiSlightlyLess.compareTo(pBar), lessThan(0)); // 14.5 psi < 1 bar
        expect(pBar.compareTo(pPsiSlightlyMore), lessThan(0)); // 1 bar < 14.6 psi
        expect(pBar.compareTo(pAtm), lessThan(0)); // 1 bar < 1 atm
      });

      test('should return 0 for equal pressures in different units', () {
        final pPascals = 100000.0.pa;
        final pMillibars = 1000.0.mbar;
        expect(pBar.compareTo(pPascals), 0);
        expect(pPascals.compareTo(pBar), 0);
        expect(pBar.compareTo(pMillibars), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const p1 = Pressure(10, PressureUnit.bar);
        const p2 = Pressure(10, PressureUnit.bar);
        expect(p1 == p2, isTrue);
        expect(p1.hashCode == p2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const p1 = Pressure(10, PressureUnit.bar);
        const p2 = Pressure(10.1, PressureUnit.bar);
        const p3 = Pressure(10, PressureUnit.psi);
        expect(p1 == p2, isFalse);
        expect(p1 == p3, isFalse);
        expect(p1.hashCode == p2.hashCode, isFalse); // Likely false
        expect(p1.hashCode == p3.hashCode, isFalse); // Likely false
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(14.7.psi.toString(), '14.7¬†psi');
        expect(1013.25.mbar.toString(), '1013.25¬†mbar');
        expect(1.0.atm.toString(), '1.0¬†atm');
        expect(25.0.cmH2O.toString(), '25.0¬†cmH‚ÇÇO');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 123.456;
      const highTolerance = 1e-6; // For chains of conversions

      // Test all units via Pascal
      for (final unit in PressureUnit.values) {
        test('Round trip ${unit.symbol} <-> Pa', () {
          testRoundTrip(
            unit,
            PressureUnit.pascal,
            testValue,
            tolerance: (unit == PressureUnit.pascal) ? 1e-9 : highTolerance,
          );
        });
      }

      // Test some other common pairs
      test('Round trip psi <-> bar', () {
        testRoundTrip(PressureUnit.psi, PressureUnit.bar, testValue, tolerance: highTolerance);
      });
      test('Round trip atm <-> mmHg', () {
        testRoundTrip(
          PressureUnit.atmosphere,
          PressureUnit.millimeterOfMercury,
          2.5,
          tolerance: highTolerance,
        );
      });
      test('Round trip kPa <-> psi', () {
        testRoundTrip(PressureUnit.kilopascal, PressureUnit.psi, 350, tolerance: highTolerance);
      });
      test('Round trip inH2O <-> cmH2O', () {
        testRoundTrip(
          PressureUnit.inchOfWater,
          PressureUnit.centimeterOfWater,
          10,
          tolerance: highTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final pZero = 0.0.pa;
        for (final unit in PressureUnit.values) {
          expect(pZero.getValue(unit), 0.0, reason: '0 Pa to ${unit.symbol} should be 0');
        }
        final pPsiZero = 0.0.psi;
        for (final unit in PressureUnit.values) {
          expect(pPsiZero.getValue(unit), 0.0, reason: '0 psi to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with negative value (if meaningful for pressure, though usually positive)',
          () {
        // Pressure is typically positive, but the math should still work.
        final pNegative = (-100.0).pa;
        expect(pNegative.inBar, closeTo(-0.001, 1e-9));
      });
    });

    group('Arithmetic Operators for Pressure', () {
      final p1Bar = 1.0.bar;
      final p2Bar = 2.0.bar;
      final p10Psi = 10.psi; // approx 0.689 bar

      // Operator +
      test('operator + combines pressures', () {
        final sum1 = p2Bar + p1Bar;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, PressureUnit.bar);

        final sum2 = p1Bar + p10Psi; // 1 bar + ~0.689 bar
        final expectedSum2Value = 1.0 + p10Psi.getValue(PressureUnit.bar);
        expect(sum2.value, closeTo(expectedSum2Value, tolerance));
        expect(sum2.unit, PressureUnit.bar);

        final sum3 = p10Psi + p1Bar; // 10 psi + (1 bar in psi)
        final expectedSum3Value = 10.0 + p1Bar.getValue(PressureUnit.psi);
        expect(sum3.value, closeTo(expectedSum3Value, tolerance));
        expect(sum3.unit, PressureUnit.psi);
      });

      // Operator -
      test('operator - subtracts pressures', () {
        final diff1 = p2Bar - p1Bar;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, PressureUnit.bar);

        final diff2 = p1Bar - p10Psi; // 1 bar - ~0.689 bar
        final expectedDiff2Value = 1.0 - p10Psi.getValue(PressureUnit.bar);
        expect(diff2.value, closeTo(expectedDiff2Value, tolerance));
        expect(diff2.unit, PressureUnit.bar);
      });

      // Operator * (scalar)
      test('operator * scales pressure by a scalar', () {
        final scaled = p2Bar * 1.5;
        expect(scaled.value, closeTo(3.0, tolerance));
        expect(scaled.unit, PressureUnit.bar);
      });

      // Operator / (scalar)
      test('operator / scales pressure by a scalar', () {
        final scaled = p2Bar / 4.0;
        expect(scaled.value, closeTo(0.5, tolerance));
        expect(scaled.unit, PressureUnit.bar);
        expect(() => p1Bar / 0.0, throwsArgumentError);
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/pressure_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/temperature_test.dart -->
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons

  group('Temperature', () {
    group('Constructors and Getters', () {
      test('should create Temperature from num extensions and retrieve values', () {
        final t1 = 25.0.celsius;
        expect(t1.value, 25.0);
        expect(t1.unit, TemperatureUnit.celsius);
        expect(t1.inFahrenheit, closeTo(77.0, tolerance));

        final t2 = 0.0.kelvin;
        expect(t2.value, 0.0);
        expect(t2.unit, TemperatureUnit.kelvin);
        expect(t2.inCelsius, closeTo(-273.15, tolerance));

        final t3 = 32.fahrenheit;
        expect(t3.value, 32.0);
        expect(t3.unit, TemperatureUnit.fahrenheit);
        expect(t3.inCelsius, closeTo(0.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const temp = Temperature(100, TemperatureUnit.celsius);
        expect(temp.getValue(TemperatureUnit.celsius), 100.0);
      });

      test('Unit.factorTo should throw UnsupportedError for TemperatureUnit', () {
        expect(
          // ignore: invalid_use_of_protected_member : protected member access
          () => TemperatureUnit.celsius.factorTo(TemperatureUnit.fahrenheit),
          throwsUnsupportedError,
        );
        expect(
          // ignore: invalid_use_of_protected_member : protected member access
          () => TemperatureUnit.kelvin.factorTo(TemperatureUnit.celsius),
          throwsUnsupportedError,
        );
      });
    });

    group('Conversions', () {
      // Celsius to others
      test('0¬∞C to Fahrenheit and Kelvin', () {
        final tempC = 0.0.celsius;
        expect(tempC.inFahrenheit, closeTo(32.0, tolerance));
        expect(tempC.inKelvin, closeTo(273.15, tolerance));
      });
      test('100¬∞C to Fahrenheit and Kelvin', () {
        final tempC = 100.0.celsius;
        expect(tempC.inFahrenheit, closeTo(212.0, tolerance));
        expect(tempC.inKelvin, closeTo(373.15, tolerance));
      });
      test('-40¬∞C to Fahrenheit and Kelvin', () {
        final tempC = (-40.0).celsius;
        expect(tempC.inFahrenheit, closeTo(-40.0, tolerance));
        expect(tempC.inKelvin, closeTo(233.15, tolerance));
      });

      // Kelvin to others
      test('0K to Celsius and Fahrenheit', () {
        final tempK = 0.0.kelvin;
        expect(tempK.inCelsius, closeTo(-273.15, tolerance));
        // (-273.15 * 1.8) + 32 = -491.67 + 32 = -459.67
        expect(tempK.inFahrenheit, closeTo(-459.67, tolerance));
      });
      test('273.15K to Celsius and Fahrenheit', () {
        final tempK = 273.15.kelvin;
        expect(tempK.inCelsius, closeTo(0.0, tolerance));
        expect(tempK.inFahrenheit, closeTo(32.0, tolerance));
      });

      // Fahrenheit to others
      test('32¬∞F to Celsius and Kelvin', () {
        final tempF = 32.0.fahrenheit;
        expect(tempF.inCelsius, closeTo(0.0, tolerance));
        expect(tempF.inKelvin, closeTo(273.15, tolerance));
      });
      test('212¬∞F to Celsius and Kelvin', () {
        final tempF = 212.0.fahrenheit;
        expect(tempF.inCelsius, closeTo(100.0, tolerance));
        expect(tempF.inKelvin, closeTo(373.15, tolerance));
      });
      test('-40¬∞F to Celsius and Kelvin', () {
        final tempF = (-40.0).fahrenheit;
        expect(tempF.inCelsius, closeTo(-40.0, tolerance));
        expect(tempF.inKelvin, closeTo(233.15, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Temperature object with converted value and unit', () {
        final tempC = 20.0.celsius;
        final tempF = tempC.convertTo(TemperatureUnit.fahrenheit);

        expect(tempF.unit, TemperatureUnit.fahrenheit);
        expect(tempF.value, closeTo(68.0, tolerance));
        expect(tempC.unit, TemperatureUnit.celsius); // Original should be unchanged
        expect(tempC.value, 20.0);
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final t1 = 10.0.kelvin;
        final t2 = t1.convertTo(TemperatureUnit.kelvin);
        expect(identical(t1, t2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final t0c = 0.0.celsius;
      final t32f = 32.0.fahrenheit;
      final t273k = 273.15.kelvin;

      final t10c = 10.0.celsius;
      final t50f = 50.0.fahrenheit; // 10¬∞C

      test('should correctly compare temperatures of different units', () {
        expect(t0c.compareTo(t32f), 0); // 0¬∞C == 32¬∞F
        expect(t0c.compareTo(t273k), 0); // 0¬∞C == 273.15K
        expect(t32f.compareTo(t273k), 0); // 32¬∞F == 273.15K

        expect(t10c.compareTo(t0c), greaterThan(0)); // 10¬∞C > 0¬∞C
        expect(t50f.compareTo(t32f), greaterThan(0)); // 50¬∞F > 32¬∞F (10¬∞C > 0¬∞C)
        expect(t10c.compareTo(t32f), greaterThan(0)); // 10¬∞C > 32¬∞F (0¬∞C)
        expect(t0c.compareTo(t10c), lessThan(0));
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const t1 = Temperature(25, TemperatureUnit.celsius);
        const t2 = Temperature(25, TemperatureUnit.celsius);
        expect(t1 == t2, isTrue);
        expect(t1.hashCode == t2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const t1 = Temperature(25, TemperatureUnit.celsius);
        const t2 = Temperature(25.1, TemperatureUnit.celsius);
        const t3 = Temperature(25, TemperatureUnit.fahrenheit);
        expect(t1 == t2, isFalse);
        expect(t1 == t3, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(25.0.celsius.toString(), '25.0¬†¬∞C');
        expect(0.0.kelvin.toString(), '0.0¬†K');
        expect(77.fahrenheit.toString(), '77.0¬†¬∞F');
      });
    });

    group('Round Trip Conversions (via direct methods)', () {
      const initialCelsius = 23.45;
      const initialKelvin = 300.12;
      const initialFahrenheit = 68.78;

      test('Celsius round trips', () {
        final c1 = initialCelsius.celsius;
        expect(
          c1.convertTo(TemperatureUnit.fahrenheit).convertTo(TemperatureUnit.celsius).value,
          closeTo(initialCelsius, tolerance),
        );
        expect(
          c1.convertTo(TemperatureUnit.kelvin).convertTo(TemperatureUnit.celsius).value,
          closeTo(initialCelsius, tolerance),
        );
      });

      test('Kelvin round trips', () {
        final k1 = initialKelvin.kelvin;
        expect(
          k1.convertTo(TemperatureUnit.celsius).convertTo(TemperatureUnit.kelvin).value,
          closeTo(initialKelvin, tolerance),
        );
        expect(
          k1.convertTo(TemperatureUnit.fahrenheit).convertTo(TemperatureUnit.kelvin).value,
          closeTo(initialKelvin, tolerance),
        );
      });

      test('Fahrenheit round trips', () {
        final f1 = initialFahrenheit.fahrenheit;
        expect(
          f1.convertTo(TemperatureUnit.celsius).convertTo(TemperatureUnit.fahrenheit).value,
          closeTo(initialFahrenheit, tolerance),
        );
        expect(
          f1.convertTo(TemperatureUnit.kelvin).convertTo(TemperatureUnit.fahrenheit).value,
          closeTo(initialFahrenheit, tolerance),
        );
      });
    });
    group('Arithmetic Operators for Temperature', () {
      final t20C = 20.0.celsius;
      final t10C = 10.0.celsius;
      final t50F = 50.0.fahrenheit; // 10 ¬∞C
      final t283K = 283.15.kelvin; // 10 ¬∞C

      // Operator - (Temperature) -> double (difference)
      test('operator - calculates temperature difference as double', () {
        final diffC = t20C - t10C; // 20¬∞C - 10¬∞C = 10 C¬∞
        expect(diffC, closeTo(10.0, tolerance));

        final diffCFromF = t20C - t50F; // 20¬∞C - 10¬∞C = 10 C¬∞
        expect(diffCFromF, closeTo(10.0, tolerance));

        // Corrected from previous state where 'diffF_direct' was not used:
        // Original operation: t50F - t20C.convertTo(TemperatureUnit.fahrenheit)
        // This is 50¬∞F - (20¬∞C as ¬∞F which is 68¬∞F) = -18 F¬∞
        final temp20CAsFahrenheit = t20C.convertTo(TemperatureUnit.fahrenheit);
        final diffF = t50F - temp20CAsFahrenheit;
        expect(
          diffF,
          closeTo(-18.0, tolerance),
          reason: '50F - 20C (as F) should be -18 F difference',
        );

        final diffkOperation = t283K - t20C; // 283.15K (10¬∞C) - 20¬∞C (converted to K)
        // 283.15K - (20 + 273.15)K = 283.15K - 293.15K = -10.0
        expect(diffkOperation, closeTo(-10.0, tolerance));

        // This was the variable causing the warning. Let's ensure it's used.
        // It will hold the same value as diffK_operation in this case.
        final diffkVariable = t283K - t20C;
        expect(
          diffkVariable,
          closeTo(-10.0, tolerance),
          reason: 'Variable diffK should hold -10.0',
        );

        final zeroDiff = t10C - t50F; // 10C - 10C (50F)
        expect(zeroDiff, closeTo(0.0, tolerance));
      });

      // Operator / (Temperature) -> double (ratio)
      test('operator / divides temperature by another, returning double ratio', () {
        // Note: Ratios of Celsius or Fahrenheit are generally not physically meaningful.
        // Kelvin should be used for meaningful ratios. Test calculates as per implementation.

        final t200K = 200.0.kelvin;
        final t100K = 100.0.kelvin;
        final ratioK = t200K / t100K;
        expect(ratioK, closeTo(2.0, tolerance));

        final t10CVal = 10.0.celsius; // Not 283.15K
        final t20CVal = 20.0.celsius; // Not 293.15K
        // Ratio based on C values: 20/10 = 2.0. If converted to K first, result would be different.
        // The implementation converts the 'other' to 'this.unit'
        final ratioC = t20CVal / t10CVal;
        expect(ratioC, closeTo(2.0, tolerance));

        // 20 C / 50 F => 20 C / 10 C (as 50F is 10C)
        final ratioCF = t20CVal / 50.0.fahrenheit;
        expect(ratioCF, closeTo(2.0, tolerance));

        expect(
          () => t20C / 0.0.celsius,
          throwsArgumentError,
          reason: 'Should throw on division by zero magnitude if dividend is non-zero',
        );
        expect(0.0.celsius / 0.0.celsius, isNaN, reason: '0.0/0.0 should be NaN');
        expect(0.0.kelvin / 0.0.kelvin, isNaN);

        final tZeroKelvin = 0.0.kelvin;
        final tNonZeroKelvin = 10.0.kelvin;
        expect(() => tNonZeroKelvin / tZeroKelvin, throwsArgumentError);
      });

      test('operator + is not defined for Temperature + Temperature', () {
        // This is a check that the operator isn't inadvertently available.
        // Since Dart doesn't allow removing operators via inheritance easily
        // without an abstract method in the base or a linter rule,
        // we just ensure it's not implemented directly in Temperature.
        // If it were inherited from a base that defined it, this test would need adjustment.
        // For now, it's just a conceptual check.
        final dynamic tempA = 10.celsius;
        final dynamic tempB = 20.celsius;
        // Check if calling the '+' operator results in an error,
        // typically NoSuchMethodError if not defined, or TypeError in some dynamic contexts.
        expect(
          // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
          () => tempA + tempB,
          throwsA(
            anyOf(
              isA<NoSuchMethodError>(),
              isA<TypeError>(),
              // Falls eine Basisklasse es doch implementieren w√ºrde und Temperature es blockiert:
              // isA<UnsupportedError>()
            ),
          ),
        );
      });

      test('operator * (scalar) is not defined for Temperature', () {
        final dynamic tempA = 10.celsius;
        // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
        expect(() => tempA * 2.0, throwsA(anyOf(isA<NoSuchMethodError>(), isA<TypeError>())));
      });
      test('operator / (scalar) is not defined for Temperature', () {
        final dynamic tempA = 10.celsius;
        // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
        expect(() => tempA / 2.0, throwsA(anyOf(isA<NoSuchMethodError>(), isA<TypeError>())));
      });
    });
  });

  group('Rankine Conversions', () {
    test('absolute zero conversions', () {
      final absoluteZeroK = 0.0.kelvin;
      final absoluteZeroR = 0.0.rankine;
      final absoluteZeroC = (-273.15).celsius;
      final absoluteZeroF = (-459.67).fahrenheit;

      // All should represent absolute zero
      expect(absoluteZeroK.inRankine, closeTo(0.0, tolerance));
      expect(absoluteZeroR.inKelvin, closeTo(0.0, tolerance));
      expect(absoluteZeroC.inRankine, closeTo(0.0, tolerance));
      expect(absoluteZeroF.inRankine, closeTo(0.0, tolerance));
    });

    test('freezing point of water conversions', () {
      final freezingC = 0.0.celsius;
      final freezingF = 32.0.fahrenheit;
      final freezingK = 273.15.kelvin;
      final freezingR = 491.67.rankine; // 32¬∞F + 459.67

      expect(freezingC.inRankine, closeTo(491.67, tolerance));
      expect(freezingF.inRankine, closeTo(491.67, tolerance));
      expect(freezingK.inRankine, closeTo(491.67, tolerance));
      expect(freezingR.inCelsius, closeTo(0.0, tolerance));
      expect(freezingR.inFahrenheit, closeTo(32.0, tolerance));
      expect(freezingR.inKelvin, closeTo(273.15, tolerance));
    });

    test('boiling point of water conversions', () {
      final boilingC = 100.0.celsius;
      final boilingF = 212.0.fahrenheit;
      final boilingK = 373.15.kelvin;
      final boilingR = 671.67.rankine; // 212¬∞F + 459.67

      expect(boilingC.inRankine, closeTo(671.67, tolerance));
      expect(boilingF.inRankine, closeTo(671.67, tolerance));
      expect(boilingK.inRankine, closeTo(671.67, tolerance));
      expect(boilingR.inCelsius, closeTo(100.0, tolerance));
      expect(boilingR.inFahrenheit, closeTo(212.0, tolerance));
      expect(boilingR.inKelvin, closeTo(373.15, tolerance));
    });

    test('rankine to other units', () {
      final temp500R = 500.0.rankine;
      const tolerance = 1e-9;

      const expectedF = 500.0 - Temperature.rankineOffsetFromFahrenheit;
      const expectedC =
          (expectedF - Temperature.fahrenheitOffset) / Temperature.fahrenheitScaleFactor;
      const expectedK = 500.0 / Temperature.fahrenheitScaleFactor;

      expect(temp500R.inFahrenheit, closeTo(expectedF, tolerance));
      expect(temp500R.inCelsius, closeTo(expectedC, tolerance));
      expect(temp500R.inKelvin, closeTo(expectedK, tolerance));
    });

    test('engineering temperature examples', () {
      // Gas turbine inlet temperature ‚âà 2500¬∞R
      final turbineTemp = 2500.0.rankine;
      const tolerance = 1e-9;

      const expectedF = 2500.0 - Temperature.rankineOffsetFromFahrenheit;
      const expectedC =
          (expectedF - Temperature.fahrenheitOffset) / Temperature.fahrenheitScaleFactor;
      const expectedK = 2500.0 / Temperature.fahrenheitScaleFactor;

      expect(turbineTemp.inFahrenheit, closeTo(expectedF, tolerance));
      expect(turbineTemp.inCelsius, closeTo(expectedC, tolerance));
      expect(turbineTemp.inKelvin, closeTo(expectedK, tolerance));

      // Cryogenic nitrogen ‚âà 140¬∞R
      final liquidNitrogen = 140.0.rankine;

      const expectedFahrenheit = 140.0 - Temperature.rankineOffsetFromFahrenheit;
      const expectedCelsius =
          (expectedFahrenheit - Temperature.fahrenheitOffset) / Temperature.fahrenheitScaleFactor;
      const expectedKelvin =
          140.0 / Temperature.fahrenheitScaleFactor; // Direct conversion from Rankine to Kelvin

      expect(liquidNitrogen.inFahrenheit, closeTo(expectedFahrenheit, tolerance));
      expect(liquidNitrogen.inCelsius, closeTo(expectedCelsius, tolerance));
      expect(liquidNitrogen.inKelvin, closeTo(expectedKelvin, tolerance));
    });
  });

  group('Rankine Scale Properties', () {
    test('rankine is absolute scale like kelvin', () {
      // Both Rankine and Kelvin start at absolute zero
      final absoluteZeroR = 0.0.rankine;
      final absoluteZeroK = 0.0.kelvin;

      expect(absoluteZeroR.inKelvin, closeTo(0.0, tolerance));
      expect(absoluteZeroK.inRankine, closeTo(0.0, tolerance));
    });

    test('rankine degree size equals fahrenheit degree size', () {
      // Temperature difference should be the same in ¬∞R and ¬∞F
      final temp1R = 100.0.rankine;
      final temp2R = 200.0.rankine;
      final diffR = temp2R - temp1R; // 100 degree difference

      final temp1F = temp1R.inFahrenheit;
      final temp2F = temp2R.inFahrenheit;
      final diffF = temp2F - temp1F;

      expect(diffR, closeTo(diffF, tolerance));
      expect(diffR, closeTo(100.0, tolerance));
    });

    test('kelvin to rankine conversion factor', () {
      // 1 K = 9/5 ¬∞R (same ratio as C to F degree size)
      final oneKelvin = 1.0.kelvin;
      final zeroKelvin = 0.0.kelvin;

      final oneKelvinInRankine = oneKelvin.inRankine;
      final zeroKelvinInRankine = zeroKelvin.inRankine;

      final conversionFactor = oneKelvinInRankine - zeroKelvinInRankine;
      expect(conversionFactor, closeTo(1.8, tolerance)); // 9/5
    });
  });

  group('Round Trip Conversions with Rankine', () {
    test('all temperature units round trip through rankine', () {
      const testTemps = [0.0, 100.0, 273.15, 373.15, 500.0];

      for (final temp in testTemps) {
        // Celsius round trip
        final celsius = temp.celsius;
        final celsiusRoundTrip = celsius.asRankine.asCelsius;
        expect(celsiusRoundTrip.value, closeTo(temp, tolerance));

        // Kelvin round trip
        final kelvin = temp.kelvin;
        final kelvinRoundTrip = kelvin.asRankine.asKelvin;
        expect(kelvinRoundTrip.value, closeTo(temp, tolerance));

        // Fahrenheit round trip
        final fahrenheit = temp.fahrenheit;
        final fahrenheitRoundTrip = fahrenheit.asRankine.asFahrenheit;
        expect(fahrenheitRoundTrip.value, closeTo(temp, tolerance));

        // Rankine round trip
        final rankine = temp.rankine;
        final rankineRoundTrip = rankine.asKelvin.asRankine;
        expect(rankineRoundTrip.value, closeTo(temp, tolerance));
      }
    });
  });

  group('Temperature Arithmetic with Rankine', () {
    test('temperature difference calculations', () {
      final temp1 = 500.0.rankine;
      final temp2 = 600.0.rankine;

      final difference = temp2 - temp1;
      expect(difference, closeTo(100.0, tolerance));

      // Same difference in other units
      final temp1F = temp1.asFahrenheit;
      final temp2F = temp2.asFahrenheit;
      final differenceF = temp2F - temp1F;
      expect(differenceF, closeTo(100.0, tolerance));
    });

    test('temperature ratios on absolute scales', () {
      final temp1 = 200.0.rankine;
      final temp2 = 400.0.rankine;

      final ratio = temp2 / temp1;
      expect(ratio, closeTo(2.0, tolerance));

      // Same ratio in Kelvin
      final temp1K = temp1.asKelvin;
      final temp2K = temp2.asKelvin;
      final ratioK = temp2K / temp1K;
      expect(ratioK, closeTo(2.0, tolerance));
    });
  });

  group('Engineering Applications', () {
    test('thermodynamic cycle calculations', () {
      // Simple heat engine with Rankine cycle
      final hotReservoir = 1000.0.rankine; // High temperature
      final coldReservoir = 500.0.rankine; // Low temperature

      // Carnot efficiency = 1 - T_cold/T_hot (absolute temperatures)
      final carnotEfficiency = 1.0 - (coldReservoir / hotReservoir);
      expect(carnotEfficiency, closeTo(0.5, tolerance)); // 50% efficiency

      // Same calculation in Kelvin should give same result
      final hotK = hotReservoir.asKelvin;
      final coldK = coldReservoir.asKelvin;
      final carnotEfficiencyK = 1.0 - (coldK / hotK);
      expect(carnotEfficiencyK, closeTo(carnotEfficiency, tolerance));
    });

    test('gas law calculations', () {
      // Ideal gas law: PV = nRT (requires absolute temperature)
      final roomTemp = 70.0.fahrenheit; // Room temperature
      final roomTempR = roomTemp.inRankine;
      final roomTempK = roomTemp.inKelvin;

      // Both should be above absolute zero
      expect(roomTempR, greaterThan(0.0));
      expect(roomTempK, greaterThan(0.0));

      // Ratio should be the conversion factor
      final tempRatio = roomTempR / roomTempK;
      expect(tempRatio, closeTo(1.8, tolerance)); // 9/5
    });
  });

  group('Comparison and Sorting with Rankine', () {
    test('temperature comparison across all scales', () {
      final freezingC = 0.0.celsius;
      final freezingR = 491.67.rankine;
      final boilingF = 212.0.fahrenheit;
      final roomTempK = 295.0.kelvin; // About 22¬∞C

      // All should be comparable
      expect(freezingC.compareTo(freezingR), 0); // Equal
      expect(roomTempK.compareTo(freezingC), greaterThan(0)); // Room temp > freezing
      expect(boilingF.compareTo(roomTempK), greaterThan(0)); // Boiling > room temp
    });

    test('sorting mixed temperature units', () {
      final temps = [
        100.0.celsius, // Boiling water
        32.0.fahrenheit, // Freezing water
        300.0.kelvin, // Room temperature
        671.67.rankine, // Boiling water in Rankine
        0.0.kelvin, // Absolute zero
      ];

      temps.sort();

      // Should be sorted by actual temperature value
      expect(temps[0].unit, TemperatureUnit.kelvin); // Absolute zero
      expect(temps[0].value, 0.0);
      expect(temps[1].unit, TemperatureUnit.fahrenheit); // Freezing
      expect(temps[2].unit, TemperatureUnit.kelvin); // Room temp
      // Last two should be boiling point (equal temperatures)
      expect(temps[3].inCelsius, closeTo(100.0, tolerance));
      expect(temps[4].inCelsius, closeTo(100.0, tolerance));
    });
  });

  group('toString formatting for Rankine', () {
    test('should display correct symbol', () {
      expect(100.0.rankine.toString(), '100.0\u00A0¬∞R');
      expect(459.67.rankine.toString(), '459.67\u00A0¬∞R');
    });

    test('formatting with conversion', () {
      final tempR = 600.0.rankine;
      // Check the Fahrenheit conversion first
      expect(
        tempR.toString(targetUnit: TemperatureUnit.fahrenheit, fractionDigits: 1),
        '140.3\u00A0¬∞F', // Use non-breaking space
      );
      // Now check the Celsius conversion with the correct rounded value
      expect(
        tempR.toString(targetUnit: TemperatureUnit.celsius, fractionDigits: 2),
        '60.18\u00A0¬∞C', // Corrected value and non-breaking space
      );
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/temperature_test.dart -->

<!-- BEGIN FILE: [v0.5.0] test/units/time_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart';
import 'package:quantify/src/units/time/time_factors.dart';
import 'package:test/test.dart';

void main() {
  const highprecisionTolerance = 1e-12; // High precision for time
  const tolerance = 1e-9; // General purpose
  const lowprecisionTolerance = 1e-6; // For calendar units (months, years)

  group('Time', () {
    // Helper for round trip tests
    void testRoundTrip(
      TimeUnit initialUnit,
      TimeUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final t1 = Time(initialValue, initialUnit);
      final t2 = t1.convertTo(intermediateUnit);
      final t3 = t2.convertTo(initialUnit);
      expect(
        t3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Time from num extensions and retrieve values', () {
        final t1 = 60.0.seconds;
        expect(t1.value, 60.0);
        expect(t1.unit, TimeUnit.second);
        expect(t1.inMinutes, closeTo(1.0, highprecisionTolerance));

        final t2 = 1.5.hours;
        expect(t2.value, 1.5);
        expect(t2.unit, TimeUnit.hour);
        expect(t2.inMinutes, closeTo(90.0, highprecisionTolerance));
        expect(t2.inSeconds, closeTo(1.5 * 3600.0, highprecisionTolerance));

        final t3 = 500.milliseconds;
        expect(t3.inSeconds, closeTo(0.5, highprecisionTolerance));

        final t4 = 1.days;
        expect(t4.inHours, closeTo(24.0, highprecisionTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const t = Time(25.0, TimeUnit.minute);
        expect(t.getValue(TimeUnit.minute), 25.0);
      });

      test('getValue for all units from Second base', () {
        final t = 3600.0.seconds; // 1 hour
        expect(t.inSeconds, 3600.0);
        expect(t.inMilliseconds, closeTo(3600.0 * 1000.0, highprecisionTolerance));
        expect(t.inMinutes, closeTo(60.0, highprecisionTolerance));
        expect(t.inHours, closeTo(1.0, highprecisionTolerance));
        expect(t.inDays, closeTo(1.0 / 24.0, highprecisionTolerance));
      });
    });

    group('Conversions', () {
      final oneHour = 1.0.hours;

      test('1 hour to various units', () {
        expect(oneHour.inMinutes, closeTo(60.0, highprecisionTolerance));
        expect(oneHour.inSeconds, closeTo(3600.0, highprecisionTolerance));
        expect(oneHour.inMilliseconds, closeTo(3600.0 * 1000.0, highprecisionTolerance));
      });

      final oneDay = 1.0.days;
      test('1 day to various units', () {
        expect(oneDay.inHours, closeTo(24.0, highprecisionTolerance));
        expect(oneDay.inMinutes, closeTo(24.0 * 60.0, highprecisionTolerance));
        expect(oneDay.inSeconds, closeTo(24.0 * 3600.0, highprecisionTolerance));
      });

      final thirtyMinutes = 30.0.minutes;
      test('30 minutes to hours and seconds', () {
        expect(thirtyMinutes.inHours, closeTo(0.5, highprecisionTolerance));
        expect(thirtyMinutes.inSeconds, closeTo(30.0 * 60.0, highprecisionTolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Time object with converted value and unit', () {
        final tMinutes = 90.0.minutes;
        final tHours = tMinutes.convertTo(TimeUnit.hour);
        expect(tHours.unit, TimeUnit.hour);
        expect(tHours.value, closeTo(1.5, highprecisionTolerance));
        expect(tMinutes.unit, TimeUnit.minute); // Original should be unchanged
      });

      test('convertTo same unit should return same instance', () {
        final t1 = 10.0.seconds;
        final t2 = t1.convertTo(TimeUnit.second);
        expect(identical(t1, t2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final t1Hour = 1.0.hours;
      final t59Minutes = 59.0.minutes;
      final t61Minutes = 61.0.minutes;
      final t3600Seconds = 3600.0.seconds;

      test('should correctly compare times of different units', () {
        expect(t1Hour.compareTo(t59Minutes), greaterThan(0));
        expect(t59Minutes.compareTo(t1Hour), lessThan(0));
        expect(t1Hour.compareTo(t61Minutes), lessThan(0));
      });

      test('should return 0 for equal times in different units', () {
        expect(t1Hour.compareTo(t3600Seconds), 0);
        expect(t3600Seconds.compareTo(t1Hour), 0);
        final tPoint5Hours = 0.5.hours;
        final t30Minutes = 30.0.minutes;
        expect(tPoint5Hours.compareTo(t30Minutes), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const t1 = Time(10.0, TimeUnit.second);
        const t2 = Time(10.0, TimeUnit.second);
        expect(t1 == t2, isTrue);
        expect(t1.hashCode == t2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const t1 = Time(10.0, TimeUnit.second);
        const t2 = Time(10.1, TimeUnit.second);
        const t3 = Time(10.0, TimeUnit.minute);
        expect(t1 == t2, isFalse);
        expect(t1 == t3, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(10.5.seconds.toString(), '10.5¬†s');
        expect(120.0.minutes.toString(), '120.0¬†min');
        expect(2.5.hours.toString(), '2.5¬†h');
        expect(1.days.toString(), '1.0¬†d');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 789.123;
      const highTolerance = 1e-7;

      for (final unit in TimeUnit.values) {
        test('Round trip ${unit.symbol} <-> s', () {
          testRoundTrip(
            unit,
            TimeUnit.second,
            testValue,
            tolerance: (unit == TimeUnit.second) ? 1e-9 : highTolerance,
          );
        });
      }

      test('Round trip min <-> h', () {
        testRoundTrip(TimeUnit.minute, TimeUnit.hour, 120.0, tolerance: highTolerance);
      });
      test('Round trip ms <-> s', () {
        testRoundTrip(TimeUnit.millisecond, TimeUnit.second, 2500.0, tolerance: highTolerance);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final tZero = 0.0.seconds;
        for (final unit in TimeUnit.values) {
          expect(tZero.getValue(unit), 0.0, reason: '0 s to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for Time', () {
      final t1Hour = 1.0.hours;
      final t2Hours = 2.0.hours;
      final t30Minutes = 30.minutes; // 0.5 hours

      // Operator +
      test('operator + combines time durations', () {
        final sum1 = t2Hours + t1Hour;
        expect(sum1.value, closeTo(3.0, highprecisionTolerance));
        expect(sum1.unit, TimeUnit.hour);

        final sum2 = t1Hour + t30Minutes; // 1h + 0.5h = 1.5h
        expect(sum2.value, closeTo(1.5, highprecisionTolerance));
        expect(sum2.unit, TimeUnit.hour);

        final sum3 = t30Minutes + t1Hour; // 30min + 60min = 90min
        expect(sum3.value, closeTo(90.0, highprecisionTolerance));
        expect(sum3.unit, TimeUnit.minute);
      });

      // Operator -
      test('operator - subtracts time durations', () {
        final diff1 = t2Hours - t1Hour;
        expect(diff1.value, closeTo(1.0, highprecisionTolerance));
        expect(diff1.unit, TimeUnit.hour);

        final diff2 = t1Hour - t30Minutes; // 1h - 0.5h = 0.5h
        expect(diff2.value, closeTo(0.5, highprecisionTolerance));
        expect(diff2.unit, TimeUnit.hour);
      });

      // Operator * (scalar)
      test('operator * scales time duration by a scalar', () {
        final scaled = t2Hours * 0.5;
        expect(scaled.value, closeTo(1.0, highprecisionTolerance));
        expect(scaled.unit, TimeUnit.hour);
      });

      // Operator / (scalar)
      test('operator / scales time duration by a scalar', () {
        final scaled = t2Hours / 2.0;
        expect(scaled.value, closeTo(1.0, highprecisionTolerance));
        expect(scaled.unit, TimeUnit.hour);
        expect(() => t1Hour / 0.0, throwsArgumentError);
      });
    });
  });

  group('Extended Time Units', () {
    group('SI Prefix Units (sub-second)', () {
      test('microsecond conversions', () {
        final oneMicrosecond = 1.0.us;
        expect(oneMicrosecond.inSeconds, closeTo(1e-6, highprecisionTolerance));
        expect(oneMicrosecond.inMilliseconds, closeTo(0.001, highprecisionTolerance));
        expect(oneMicrosecond.inNanoseconds, closeTo(1000.0, highprecisionTolerance));
      });

      test('nanosecond conversions', () {
        final oneNanosecond = 1.0.ns;
        expect(oneNanosecond.inSeconds, closeTo(1e-9, highprecisionTolerance));
        expect(oneNanosecond.inMicroseconds, closeTo(0.001, highprecisionTolerance));
        expect(oneNanosecond.inPicoseconds, closeTo(1000.0, highprecisionTolerance));
      });

      test('picosecond conversions', () {
        final onePicosecond = 1.0.ps;
        expect(onePicosecond.inSeconds, closeTo(1e-12, highprecisionTolerance));
        expect(onePicosecond.inNanoseconds, closeTo(0.001, highprecisionTolerance));
        expect(onePicosecond.inMicroseconds, closeTo(1e-6, highprecisionTolerance));
      });

      test('sub-second scale relationships', () {
        // Test the progression: s -> ms -> Œºs -> ns -> ps
        final oneSecond = 1.0.s;
        expect(oneSecond.inMilliseconds, closeTo(1000.0, highprecisionTolerance));
        expect(oneSecond.inMicroseconds, closeTo(1e6, highprecisionTolerance));
        expect(oneSecond.inNanoseconds, closeTo(1e9, lowprecisionTolerance));
        expect(oneSecond.inPicoseconds, closeTo(1e12, highprecisionTolerance));
      });
    });

    group('Calendar Units', () {
      test('week conversions', () {
        final oneWeek = 1.0.wk;
        expect(oneWeek.inDays, closeTo(7.0, highprecisionTolerance));
        expect(oneWeek.inHours, closeTo(168.0, highprecisionTolerance)); // 7 * 24
        expect(oneWeek.inMinutes, closeTo(10080.0, highprecisionTolerance)); // 7 * 24 * 60
        expect(oneWeek.inSeconds, closeTo(604800.0, highprecisionTolerance)); // 7 * 24 * 60 * 60
      });

      test('month conversions', () {
        final oneMonth = 1.0.mo;
        // Based on average month: 365.25 days / 12 = 30.4375 days
        expect(oneMonth.inDays, closeTo(30.4375, tolerance));
        expect(oneMonth.inWeeks, closeTo(4.348214286, tolerance));
        expect(oneMonth.inHours, closeTo(730.5, tolerance));
        expect(oneMonth.inSeconds, closeTo(2629800.0, tolerance));
      });

      test('year conversions', () {
        final oneYear = 1.0.yr;
        // Based on Julian year: 365.25 days
        expect(oneYear.inDays, closeTo(365.25, highprecisionTolerance));
        expect(oneYear.inWeeks, closeTo(52.178571429, lowprecisionTolerance));
        expect(oneYear.inMonths, closeTo(12.0, lowprecisionTolerance));
        expect(oneYear.inHours, closeTo(8766.0, highprecisionTolerance)); // 365.25 * 24
        expect(
          oneYear.inSeconds,
          closeTo(31557600.0, highprecisionTolerance),
        ); // 365.25 * 24 * 60 * 60
      });

      test('calendar relationships', () {
        // Test approximate relationships
        final oneYear = 1.0.yr;
        final twelveMonths = 12.0.mo;
        final fiftyTwoWeeks = 52.0.wk;

        // Based on the definitions, a Julian year is now exactly 12 average months.
        expect(oneYear.compareTo(twelveMonths), 0);

        // Year should be slightly more than 52 weeks
        expect(oneYear.compareTo(fiftyTwoWeeks), greaterThan(0));

        // Differences should be small
        expect(oneYear.inMonths, closeTo(12.0, 0.1));
        expect(oneYear.inWeeks, closeTo(52.18, 0.2));
      });
    });

    group('Practical time measurements', () {
      test('computer processing times', () {
        // CPU clock cycles at 3 GHz
        final cpuCycle = (1.0 / 3e9).s; // 1/3 nanosecond
        expect(cpuCycle.inNanoseconds, closeTo(1.0 / 3.0, tolerance));

        // Memory access time ‚âà 100 ns
        final memoryAccess = 100.0.ns;
        expect(memoryAccess.inMicroseconds, closeTo(0.1, highprecisionTolerance));

        // SSD access time ‚âà 0.1 ms
        final ssdAccess = 0.1.ms;
        expect(ssdAccess.inMicroseconds, closeTo(100.0, highprecisionTolerance));
      });

      test('scientific measurements', () {
        // Light travel times
        final lightToMoon = 1.28.s; // Light travel time to moon
        final lightAroundEarth = 0.134.s; // Light travel around Earth's equator

        expect(lightToMoon.inMilliseconds, closeTo(1280.0, highprecisionTolerance));
        expect(lightAroundEarth.inMilliseconds, closeTo(134.0, highprecisionTolerance));

        // Atomic vibrations ‚âà femtoseconds (10^-15 s)
        final atomicVibration = 1e-3.ps; // 1 femtosecond in picoseconds
        expect(atomicVibration.inSeconds, closeTo(1e-15, highprecisionTolerance));
      });

      test('biological time scales', () {
        // Human heartbeat ‚âà 1 Hz (1 beat per second)
        final heartbeat = 1.0.s;
        expect(heartbeat.inMilliseconds, closeTo(1000.0, highprecisionTolerance));

        // Nerve impulse ‚âà 1 ms
        final nerveImpulse = 1.0.ms;
        expect(nerveImpulse.inMicroseconds, closeTo(1000.0, highprecisionTolerance));

        // Muscle contraction ‚âà 100 ms
        final muscleContraction = 100.0.ms;
        expect(muscleContraction.inSeconds, closeTo(0.1, highprecisionTolerance));
      });

      test('human time scales', () {
        // Work schedules
        final workDay = 8.0.h;
        final workWeek = workDay * 5;
        expect(workWeek.inHours, closeTo(40.0, highprecisionTolerance));

        // Life spans
        final humanLifespan = 75.0.yr;
        final dogLifespan = 12.0.yr;
        expect(humanLifespan.inMonths, closeTo(900.0, lowprecisionTolerance));
        expect(dogLifespan.inDays, closeTo(4383.0, lowprecisionTolerance));
      });
    });

    group('Time arithmetic with mixed scales', () {
      test('adding very different time scales', () {
        final longTime = 1.0.yr;
        final shortTime = 1.0.ns;
        final combined = longTime + shortTime;

        // Nanosecond should be negligible compared to year
        expect(combined.inYears, closeTo(1.0, lowprecisionTolerance));
        expect(combined.unit, TimeUnit.year);
      });

      test('precise timing calculations', () {
        // GPS satellite clock corrections
        final gpsClockDrift = 38.0.us; // microseconds per day
        final oneDay = 1.0.d;

        expect(gpsClockDrift.inNanoseconds, closeTo(38000.0, tolerance));
        expect(oneDay.inMicroseconds, closeTo(86400e6, highprecisionTolerance));

        // Clock error rate
        final errorRate = gpsClockDrift.inSeconds / oneDay.inSeconds;
        expect(errorRate, closeTo(4.4e-10, 1e-12)); // Very small error rate
      });

      test('project timeline calculations', () {
        // Software development timeline

        final projectDuration = 6.0.mo;
        final sprintDuration = 2.0.wk;

        // Calculate expected value instead of hardcoding it
        const expectedWeeks = (6 * TimeFactors.secondsPerMonth) / TimeFactors.secondsPerWeek;
        expect(projectDuration.inWeeks, closeTo(expectedWeeks, lowprecisionTolerance));

        final numberOfSprints = projectDuration.inWeeks / sprintDuration.inWeeks;
        // The expectation for numberOfSprints should also be calculated
        const expectedSprints = expectedWeeks / 2.0;
        expect(numberOfSprints, closeTo(expectedSprints, 0.1));
      });
    });

    group('Round trip conversions for new units', () {
      const testValue = 789.123;

      test('sub-second round trips', () {
        final units = [
          TimeUnit.microsecond,
          TimeUnit.nanosecond,
          TimeUnit.picosecond,
        ];

        for (final unit in units) {
          final original = Time(testValue, unit);
          final converted = original.convertTo(TimeUnit.second).convertTo(unit);
          expect(
            converted.value,
            closeTo(testValue, tolerance),
            reason: 'Round trip failed for ${unit.symbol}',
          );
        }
      });

      test('calendar unit round trips', () {
        final units = [
          TimeUnit.week,
          TimeUnit.month,
          TimeUnit.year,
        ];

        for (final unit in units) {
          final original = Time(testValue, unit);
          final converted = original.convertTo(TimeUnit.second).convertTo(unit);
          expect(
            converted.value,
            closeTo(testValue, lowprecisionTolerance),
            reason: 'Round trip failed for ${unit.symbol}',
          );
        }
      });
    });

    group('Sorting different time scales', () {
      test('mixed scale sorting', () {
        final times = [
          1.0.yr, // 1 year
          100.0.d, // 100 days
          1000.0.h, // 1000 hours ‚âà 41.7 days
          1.0.mo, // 1 month ‚âà 30.4 days
          10.0.wk, // 10 weeks = 70 days
        ];

        times.sort();

        // Should be sorted: 1 mo < 1000 h < 10 wk < 100 d < 1 yr
        expect(times[0].unit, TimeUnit.month);
        expect(times[1].unit, TimeUnit.hour);
        expect(times[2].unit, TimeUnit.week);
        expect(times[3].unit, TimeUnit.day);
        expect(times[4].unit, TimeUnit.year);
      });
    });

    group('toString formatting for new units', () {
      test('should display correct symbols', () {
        expect(1.0.us.toString(), '1.0\u00A0Œºs');
        expect(1.0.ns.toString(), '1.0\u00A0ns');
        expect(1.0.ps.toString(), '1.0\u00A0ps');
        expect(1.0.wk.toString(), '1.0\u00A0wk');
        expect(1.0.mo.toString(), '1.0\u00A0mo');
        expect(1.0.yr.toString(), '1.0\u00A0yr');
      });

      test('alternative short form accessors', () {
        expect(1.0.min.toString(), '1.0\u00A0min');
        expect(1.0.h.toString(), '1.0\u00A0h');
        expect(1.0.d.toString(), '1.0\u00A0d');
        expect(1.0.s.toString(), '1.0\u00A0s');
        expect(1.0.ms.toString(), '1.0\u00A0ms');
      });
    });

    group('SI Prefix Units (deci, centi, deca, hecto, kilo, mega, giga)', () {
      const tolerance = 1e-12;

      test('deci- and centiseconds', () {
        final oneSecond = 1.0.s;
        expect(oneSecond.inDeciseconds, closeTo(10.0, tolerance));
        expect(oneSecond.inCentiseconds, closeTo(100.0, tolerance));

        final oneDecisecond = 1.0.ds;
        expect(oneDecisecond.inMilliseconds, closeTo(100.0, tolerance));

        final oneCentisecond = 1.0.cs;
        expect(oneCentisecond.inMilliseconds, closeTo(10.0, tolerance));
      });

      test('deca-, hecto-, and kiloseconds', () {
        final oneKilosecond = 1.0.kiloS;
        expect(oneKilosecond.inSeconds, closeTo(1000.0, tolerance));
        expect(oneKilosecond.inHectoseconds, closeTo(10.0, tolerance));
        expect(oneKilosecond.inDecaseconds, closeTo(100.0, tolerance));
      });

      test('mega- and gigaseconds', () {
        final oneMegasecond = 1.0.megaS; // 1 million seconds
        expect(oneMegasecond.inDays, closeTo(1e6 / 86400, 1e-9)); // ~11.57 days

        final oneGigasecond = 1.0.gigaS; // 1 billion seconds
        expect(oneGigasecond.inYears, closeTo(1e9 / 31557600.0, 1e-9)); // ~31.7 years
      });
    });

    group('Calendar Units (Fortnight, Decade, Century)', () {
      const tolerance = 1e-9;

      test('fortnight conversions', () {
        final oneFortnight = 1.0.fortnights;
        expect(oneFortnight.inDays, closeTo(14.0, tolerance));
        expect(oneFortnight.inWeeks, closeTo(2.0, tolerance));
      });

      test('decade conversions', () {
        final oneDecade = 1.0.decades;
        expect(oneDecade.inYears, closeTo(10.0, tolerance));
        // A decade has 120 average months
        expect(oneDecade.inMonths, closeTo(120.0, 1e-6));
      });

      test('century conversions', () {
        final oneCentury = 1.0.centuries;
        expect(oneCentury.inYears, closeTo(100.0, tolerance));
        expect(oneCentury.inDecades, closeTo(10.0, tolerance));
      });

      test('sorting calendar units', () {
        final times = [1.0.centuries, 1.0.years, 1.0.decades, 1.0.fortnights]..sort();

        expect(times[0].unit, TimeUnit.fortnight);
        expect(times[1].unit, TimeUnit.year);
        expect(times[2].unit, TimeUnit.decade);
        expect(times[3].unit, TimeUnit.century);
      });
    });
  });
}

<!-- END FILE: [v0.5.0] test/units/time_test.dart -->

---
Generated with llmifier v0.2.2
Created by Software Engineering Philipp Gerber
Repository: https://github.com/PhilippHGerber/llmifier
Package: https://pub.dev/packages/llmifier
