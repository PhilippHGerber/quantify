# Project Documentation: quantify v0.12.0

Generated by llmifier on: 2025-08-11T15:26:04
Extraction Mode: full
Project Type: dart

---

<!-- BEGIN FILE: [v0.12.0] README.md -->
# Quantify

[![pub version](https://img.shields.io/pub/v/quantify.svg)](https://pub.dev/packages/quantify)
[![license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/PhilippHGerber/quantify/blob/main/LICENSE)

Quantify is a Dart package for type-safe units, quantities, and measurements — offering compile-time safety, fluent arithmetic, and robust unit conversion for physical values like speed, mass, and temperature.

## Why `quantify`?

`quantify` makes working with physical units in Dart safer, more readable, and efficient:

*   **Type Safety:** Prevents unit mismatch errors at compile-time.
*   **Elegant API:** Intuitive syntax like `10.m` or `length.inKm`.
*   **Rich Constants Library:** Provides type-safe physical, astronomical, and engineering constants.
*   **Precise & Performant:** Uses `double` and direct conversion factors for speed and to minimize rounding errors.
*   **Immutable:** `Quantity` objects are immutable for safer code.
*   **Configurable Output:** Highly flexible `toString()` for customized formatting.
*   **Lightweight:** Minimal dependencies.

## Quick Start

```dart
import 'package:quantify/quantify.dart';
// For locale-specific number formatting, add 'intl' to your pubspec.yaml
// and import 'package:intl/intl.dart';

void main() {
  // Create quantities
  final pathA = 1500.m;
  final pathB = 2.5.km;

  // Convert to value / a new Quantity object
  double pathInKm = pathA.inKm;
  final pathAsKm = pathA.asKm;

  // Convert and print
  print(pathA.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 1));  // Output: "1.5 km"
  print(pathB.toString(targetUnit: LengthUnit.mile, fractionDigits: 2));  // Output: "1.55 mi" (approx.)

  // Arithmetic
  final distance = pathA + pathB; // pathB is converted to meters
  print(distance.toString(fractionDigits: 0));  // Output: "4000 m"
  print(distance.toString(
    targetUnit: LengthUnit.yard,
    fractionDigits: 0,
  ));  // Output: "4374 yd" (approx., with non-breaking space)

  // Locale-specific example (if 'intl' is used)
  // final distanceDE = 1234.567.m;
  print(distanceDE.toString(
    targetUnit: LengthUnit.kilometer,
    fractionDigits: 2,
    locale: 'de_DE',
  ));  // Output: "1,23 km"
}
```

## Installation

Add to your `pubspec.yaml`:

```yaml
dependencies:
  quantify: ^0.12.0 # Or the latest version
  # Optional, for locale-specific number formatting:
  # intl: ^0.19.0
```

Then run `dart pub get` or `flutter pub get`.

## Supported Units

The library supports a comprehensive range of physical quantities, including all 7 SI base units and many derived units:

| Quantity Type           | Status | Units Available                                                                                                                        | Notes / SI Base Unit Ref. |
| :---------------------- | :----: | :------------------------------------------------------------------------------------------------------------------------------------- | :------------------------ |
| **Length**              |   ✅    | **`m`** (meter), `km`, `hm`, `dam`, `dm`, `cm`, `mm`, `μm`, `nm`, `pm`, `fm`, `in`, `ft`, `yd`, `mi`, `nmi`, `AU`, `ly`, `pc`, `Å`     | SI Base: Meter (m)        |
| **Mass**                |   ✅    | **`kg`** (kilogram), `hg`, `dag`, `g`, `dg`, `cg`, `mg`, `μg`, `ng`, `t`, `lb`, `oz`, `st`, `slug`, `short ton`, `long ton`, `u`, `ct` | SI Base: Kilogram (kg)    |
| **Time**                |   ✅    | **`s`** (second), `μs`, `ns`, `ps`, `ms`, `min`, `h`, `d`, `wk`, `mo`, `yr`                                                            | SI Base: Second (s)       |
| **Electric Current**    |   ✅    | **`A`** (ampere), `mA`, `μA`, `nA`, `kA`                                                                                               | SI Base: Ampere (A)       |
| **Temperature**         |   ✅    | **`K`** (kelvin), `°C` (celsius), `°F` (fahrenheit), `°R` (rankine)                                                                    | SI Base: Kelvin (K)       |
| **Amount of Substance** |   ✅    | **`mol`** (mole), `mmol`, `μmol`, `nmol`, `pmol`, `kmol`                                                                               | SI Base: Mole (mol)       |
| **Luminous Intensity**  |   ✅    | **`cd`** (candela), `mcd`, `kcd`                                                                                                       | SI Base: Candela (cd)     |
| *Derived*               |        |                                                                                                                                        |                           |
| **Angle**               |   ✅    | **`rad`** (radian), `°` (degree), `grad`, `rev`, `arcmin` ('), `arcsec` ("), `mrad`                                                    | Derived SI: dimensionless |
| **Angular Velocity**    |   ✅    | **`rad/s`**, `°/s`, `rpm`, `rps`                                                                                                       | Derived SI: 1/s           |
| **Speed / Velocity**    |   ✅    | **`m/s`** (meter per second), `km/h`, `mph`, `kn` (knot), `ft/s`                                                                       | Derived SI                |
| **Acceleration**        |   ✅    | **`m/s²`**, `g` (standard gravity), `km/h/s`, `cm/s²` (Galileo)                                                                        | Derived SI                |
| **Force**               |   ✅    | **`N`** (Newton), `lbf`, `dyn`, `kgf`, `kN`, `gf`, `pdl`                                                                               | Derived SI: kg·m/s²       |
| **Pressure**            |   ✅    | **`Pa`** (Pascal), `atm`, `bar`, `psi`, `Torr`, `mmHg`, `inHg`, `kPa`, `hPa`, `mbar`, `cmH₂O`, `inH₂O`                                 | Derived SI: N/m²          |
| **Area**                |   ✅    | **`m²`**, `Mm²`, `km²`, `hm²`, `dam²`, `dm²`, `cm²`, `mm²`, `µm²`, `ha`, `mi²`, `acre`, `yd²`, `ft²`, `in²`                            | Derived SI                |
| **Volume**              |   ✅    | **`m³`**, **`L`**, `mL`, `gal`, `fl-oz`, `ft³`, `in³`, `qt`, `pt`, `tbsp`, `tsp`...                                                    | Derived SI: L (Liter)     |
| **Frequency**           |   ✅    | **`Hz`**, `kHz`, `MHz`, `GHz`, `THz`, `rpm`, `bpm`                                                                                     | Derived SI: 1/s           |
| **Electric Charge**     |   ✅    | **`C`**, `mC`, `µC`, `nC`, `Ah`, `e`, `mAh`, `statC`, `abC`                                                                            | Derived SI: A·s           |
| **Solid Angle**         |   ✅    | **`sr`**, `deg²` (Square Degree), `sp` (Spat)                                                                                          | Derived SI: dimensionless |
| **Energy / Work**       |   ✅    | **`J`** (Joule), `kJ`, `MJ`, `kWh`, `cal`, `kcal`, `eV`, `Btu`                                                                         | Derived SI: N·m           |
| **Power**               |   ✅    | **`W`** (Watt), `mW`, `kW`, `MW`, `GW`, `hp`, `PS` (metric hp), `Btu/h`, `erg/s`                                                       | Derived SI: J/s           |

## Detailed Usage

### Creating Quantities

Use extension methods on `num` for readability:

```dart
final myLength = 25.5.m;
final anotherLength = 10.ft; // feet
final verySmall = 500.nm; // nanometers
final astronomical = 4.2.ly; // light years
```

Or use the constructor of the specific `Quantity` class:

```dart
final specificLength = Length(5.0, LengthUnit.yard);
```

### Converting and Retrieving Values

1.  **Get Numerical Value:** Use `in[UnitName]` getters or `getValue(TargetUnit)`.

    ```dart
    final oneMile = 1.0.mi;
    double milesInKm = oneMile.inKm; // approx 1.609344
    double milesInMeters = oneMile.getValue(LengthUnit.meter); // approx 1609.344

    final smallDistance = 1.um; // micrometer
    double inNanometers = smallDistance.inNm; // 1000.0
    ```

2.  **Get New `Quantity` Object:** Use `convertTo(TargetUnit)` or `as[UnitName]` getters.

    ```dart
    final tenMeters = 10.m;
    final tenMetersInFeetObj = tenMeters.convertTo(LengthUnit.foot);
    // tenMetersInFeetObj is Length(approx 32.8084, LengthUnit.foot)
    final tenMetersInKmObj = tenMeters.asKm;
    // tenMetersInKmObj is Length(0.01, LengthUnit.kilometer)
    ```

### Using the Constants Library

`quantify` includes a comprehensive library of type-safe physical, astronomical, and engineering constants.

```dart
import 'package:quantify/quantify.dart';
import 'package:quantify/constants.dart'; // Import the constants library

void main() {
  // Constants are already Quantity objects, ready for use.
  final gravity = AstronomicalConstants.standardGravity; // An Acceleration object
  final electron = PhysicalConstants.electronMass; // A Mass object
  final speedOfLight = PhysicalConstants.speedOfLight; // A Speed object
  final steelStiffness = EngineeringConstants.steelYoungsModulus; // A Pressure object

  // Use them in calculations
  final weightOfElectron = Force.from(electron, gravity);
  print('Weight of an electron on Earth: ${weightOfElectron.inNewtons} N');

  // Use convenience methods for common formulas
  final photonEnergy = PhysicalConstants.photonEnergy(500.0.nm); // Returns an Energy object
  print('Energy of a 500nm photon: ${photonEnergy.inElectronvolts.toStringAsFixed(2)} eV');
}
```

### Formatting Output with `toString()`

The `toString()` method on `Quantity` objects is highly configurable:

```dart
final myDistance = 1578.345.m;

// Default
print(myDistance.toString()); // "1578.345 m"

// Convert to kilometers, 2 fraction digits
print(myDistance.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2));
// Output: "1.58 km"

// Scientific notation with micrometers
final smallLength = 0.000523.m;
print(smallLength.toString(targetUnit: LengthUnit.micrometer, fractionDigits: 0));
// Output: "523 μm"
```

### Arithmetic Operations

Standard arithmetic operators (`+`, `-`, `*`, `/` by a scalar) are overloaded. The result's unit is typically that of the left-hand operand. `Temperature` has specific arithmetic rules.

```dart
final segment1 = 500.m;
final segment2 = 0.25.km; // 250 meters
final total = segment1 + segment2; // Result is in meters
print(total.toString()); // "750.0 m"

final scaled = segment1 * 3;
print(scaled.toString()); // "1500.0 m"

// Work with different scales
final bigMass = 5.t; // tonnes
final smallMass = 250.g; // grams
final combined = bigMass + smallMass; // Result: 5.00025 t
```

### Comparisons & Sorting: Magnitude vs. Strict Equality

`quantify` provides a clear and intuitive way to compare quantities, distinguishing between checking for physical magnitude and strict equality.

#### Magnitude Comparison (using `>`, `<`, `>=`, `<=`)

All `Quantity` objects can be compared directly using standard relational operators. The library automatically handles unit conversions, so you can compare any two quantities of the same type (e.g., two `Length` objects) without worrying about their internal units.

```dart
final oneKm = 1.km;
final oneMile = 1.mi;
final thousandMeters = 1000.m;

print(oneMile > oneKm);          // true
print(oneKm < 999.m);            // false
print(oneKm >= thousandMeters);  // true
```

#### Equality Checks (`isEquivalentTo()` vs. `==`)

It's important to understand the two types of equality checks available:

1.  **Magnitude Equality (`isEquivalentTo`)**: Checks if two quantities represent the **same physical amount**.
2.  **Strict Equality (`==`)**: Checks if two quantities have the **exact same value AND unit**.

```dart
final oneMeter = 1.m;
final hundredCm = 100.cm;

// Magnitude check: Do they represent the same distance?
print(oneMeter.isEquivalentTo(hundredCm)); // true

// Strict check: Are they represented in the same way?
print(oneMeter == hundredCm);              // false (different units: m vs cm)
print(oneMeter == 1.m);                    // true (same value and unit)
```

This distinction is crucial when working with collections like `Set`s or `Map`s, where the strict equality of `==` is typically the desired behavior.

#### Sorting

```dart
final lengths = [1.mi, 2000.m, 1.km, 5000.ft]
..sort(); // Sorts by physical magnitude
print(lengths.map((l) => l.toString()).join(', '));
// Output: 1.0 km, 5000.0 ft, 1.0 mi, 2000.0 m
print(lengths.map((l) => l.asM).join(', '));
// Output: 1000.0 m, 1524.0 m, 1609.344 m, 2000.0 m
```

## **Managing Imports and Avoiding Conflicts**

`quantify` is designed to be both convenient and robust. By default, importing `package:quantify/quantify.dart` gives you access to all quantities and their handy extensions (like `10.m` or `5.s`).

However, in large projects or when combining `quantify` with other libraries, this might lead to name conflicts with extension methods. To give you full control over what is imported into your project's namespace, `quantify` provides separate entry points for each quantity type.

If you encounter a name conflict or simply want to be more explicit about your dependencies, you can import only the quantities you need.

### Example: Importing only Length and Time

Instead of the main package, you can import specific libraries:

```dart

// Import only the extensions you need
import 'package:quantify/length.dart';
import 'package:quantify/time.dart';

void main() {
  // Now, only extensions for Length and Time are available.
  final distance = 100.m; // Works
  final duration = 30.s;   // Works

  // This will cause a compile-time error because Mass extensions were not imported.
  // final weight = 70.kg; // ERROR: The getter 'kg' isn't defined for the type 'int'.

  // You can still create the Mass object using its constructor:
  final weight = Mass(70, MassUnit.kilogram); // This always works
}
```

This granular approach ensures that `quantify` can be used safely and effectively in any project, no matter how complex.

## Goals & Roadmap

*   **V1.0 (Current):** All 7 SI base units with comprehensive unit coverage and a rich constants library.
*   **V2.0 and Beyond:**
    *   **High Precision:** Support for `Decimal`.
    *   **Serialization support.**
    *   **Compound Units:** More advanced `Quantity` types (e.g., `Density`, `Resistivity`).

## Contributing

Contributions are welcome! Please open an [Issue](https://github.com/PhilippHGerber/quantify/issues) or a [Pull Request](https://github.com/PhilippHGerber/quantify/pulls).

## License

MIT License - see the `LICENSE` file.

<!-- END FILE: [v0.12.0] README.md -->

<!-- BEGIN FILE: [v0.12.0] CHANGELOG.md -->
# Changelog

All notable changes to the `quantify` package will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.12.0]

### Added

* Major Feature: Comprehensive Constants Library.
  * A library of over 100 type-safe constants, organized into three categories: PhysicalConstants, AstronomicalConstants, and EngineeringConstants.
  * Constants are represented as Quantity objects wherever possible (e.g., PhysicalConstants.speedOfLight is a Speed object, AstronomicalConstants.standardGravity is an Acceleration object).
  * Added convenience methods for common scientific and engineering formulas, such as PhysicalConstants.photonEnergy(), AstronomicalConstants.escapeVelocity(), and EngineeringConstants.mechanicalStress().
  * Constants are accessible via a new, separate import: package:quantify/constants.dart.

## [0.11.0]

2025-07-27

### Changed

- **Conceptual Refinement of `Frequency` and `AngularVelocity`**:
  - `Frequency` is now the comprehensive quantity for all periodic units (inverse time, T⁻¹), including rotational rates.
  - `AngularVelocity` remains a distinct, specialized type for rotational mechanics to ensure semantic type safety.

### Added

- **`Frequency` Unit Expansion**: Added `rad/s` (radian per second) and `deg/s` (degree per second) to `Frequency`.
- **Interoperability Between `Frequency` and `AngularVelocity`**:
  - Added a safe `.asFrequency` getter to `AngularVelocity` for direct conversion to a `Frequency` object.
  - Added a guarded `.asAngularVelocity` getter to `Frequency` that only converts compatible rotational units (`rpm`, `rad/s`, `Hz`, etc.) and throws an `UnsupportedError` for non-rotational units (like `bpm` or `MHz`), preventing logical errors in calculations.

## [0.10.0]

2025-07-26

- **New Quantities: `Energy` and `Power`**
  - Added the `Energy` quantity with common units (J, kJ, MJ, kWh, kcal, eV, Btu).
  - Added the `Power` quantity with a comprehensive set of SI, engineering, and CGS units (W, kW, MW, GW, hp, PS, Btu/h, erg/s).

- **Expanded Unit Coverage**
  - Added new units to `Acceleration` (cm/s²), `Force` (gf, pdl), and `ElectricCharge` (mAh, statC, abC)
  -

## [0.9.0]

2025-07-22

- **Added relational operators (`>`, `<`, `>=`, `<=`) for all quantities.** Comparisons are now more readable (e.g., `1.m > 99.cm`).
- **Added `isEquivalentTo()` method** for explicit magnitude equality checks (e.g., `1.m.isEquivalentTo(100.cm)`).

## [0.8.0]

2025-07-22

- **New Derived Quantities**
  - `Frequency` with units (`Hz`, `MHz`, `GHz`, `THz`, `rpm`, etc.).
  - `ElectricCharge` with units (`C`, `Ah`, `e`, `µC`, etc.).
  - `SolidAngle` with units (`sr`, `deg²`, `sp`).

## [0.7.0]

2025-07-16

- **New Derived Quantity**
  - `Area` with units (`m²`, `km²`, `ha`, `acre`, `yd²`, `ft²`, etc.).
  - `Volume` with comprehensive SI, US customary, and cooking units (`m³`, `L`, `gal`, `fl-oz`, `tsp`, etc.).

## [0.6.0]

2025-07-05

- **New Derived Quantities**
  - `Speed`: Added `m/s`, `km/h`, `mph`, `kn`, `ft/s`.
  - `Acceleration`: Added `m/s²`, `g` (standard gravity), `km/h/s`.
  - `Force`: Added `N` (Newton), `lbf`, `dyn`, `kgf`, `kN`.

## [0.5.0]

2025-06-29

### Added

- Expanded Unit Coverage:
  - Length: Added Mm (megametre) and Gm (gigametre).
  - Mass: Added Mg (megagram) and Gg (gigagram).
  - Time: Added full range of SI prefixes (Gs to cs) and calendar units (fortnight, decade, century).
  - ElectricCurrent: Added CGS units statA (statampere) and abA (abampere/biot).

- Granular Exports: Added separate library entry points (e.g., package:quantify/length.dart) to allow for explicit imports and prevent namespace conflicts.

## [0.4.0]

2025-06-23

### Added

- **New Quantity: `Angle`**
  - `Angle` quantity
  - `AngleUnit`:
    - **`radian` (rad):** The SI-derived unit, used as the base for conversions.
    - **`degree` (°):** The most common unit for angles.
    - **`gradian` (grad):** Unit used in surveying (400 grad in a circle).
    - **`revolution` (rev):** Represents a full circle or turn.
    - **`arcminute` ('):** High-precision unit (1/60 of a degree).
    - **`arcsecond` ("):** High-precision unit (1/60 of an arcminute).
    - **`milliradian` (mrad):** Common in optics and ballistics.
  - Standard arithmetic operators (`+`, `-`, `*`, `/`) for `Angle`.

- **New Quantity: `AngularVelocity`**
  - `AngularVelocity` quantity - represents rotational speed.
  - `AngularVelocityUnit`:
    - **`radianPerSecond` (rad/s):** The SI-derived unit.
    - **`degreePerSecond` (°/s).**
    - **`revolutionPerMinute` (rpm):** A widely used unit for rotational speed.
    - **`revolutionPerSecond` (rps).**
  - Standard arithmetic operators for `AngularVelocity`.

## [0.3.0]

2025-06-21

### Added

- **Expanded Unit Coverage:**
  - **Length:**
    - SI Prefixes: `hm` (hectometer), `dam` (decameter), `dm` (decimeter), `μm` (micrometer), `nm` (nanometer), `pm` (picometer), `fm` (femtometer).
    - Astronomical: `AU` (astronomical unit), `ly` (light year), `pc` (parsec).
    - Special: `Å` (ångström).
  - **Mass:**
    - SI Prefixes: `hg` (hectogram), `dag` (decagram), `dg` (decigram), `cg` (centigram), `μg` (microgram), `ng` (nanogram).
    - Imperial/US: `short ton`, `long ton`.
    - Special: `u` (atomic mass unit), `ct` (carat).
  - **Time:**
    - SI Prefixes: `μs` (microsecond), `ns` (nanosecond), `ps` (picosecond).
    - Calendar: `wk` (week), `mo` (month), `yr` (year).
  - **Temperature:**
    - Absolute Scale: `°R` (rankine).

## [0.2.0]

2025-06-16

### Added

- **New SI Base Quantity Types (completing all 7 SI base units):**
  - **Mass:**
    - `Mass` class and `MassUnit` enum (`kg`, `g`, `mg`, `t` (tonne), `lb`, `oz`, `st` (stone), `slug`).
  - **Amount of Substance (Molar Amount):**
    - `MolarAmount` class and `MolarUnit` enum (`mol`, `mmol`, `µmol`, `nmol`, `pmol`, `kmol`).
  - **Electric Current:**
    - `Current` class and `CurrentUnit` enum (`A`, `mA`, `µA`, `nA`, `kA`).
  - **Luminous Intensity:**
    - `LuminousIntensity` class and `LuminousIntensityUnit` enum (`cd`, `mcd`, `kcd`).

## [0.1.0]

2025-06-12

### Added

- **Initial Release of `quantify` v0.1.0**
- **Core Functionality:**
  - Type-safe `Quantity` base class for representing physical quantities with a value and a unit.
  - `Unit` interface for defining conversion factors and symbols.
  - Immutable `Quantity` objects.
  - `double` precision for quantity values.
  - Elegant API with extension methods on `num` for quantity creation (e.g., `10.m`, `20.celsius`).
  - Extension methods on `Quantity` for easy value retrieval in target units (e.g., `length.inKm`) and for obtaining new `Quantity` objects in target units (e.g., `length.asKm`).
  - Configurable `toString()` method on `Quantity` objects supporting:
    - Conversion to a `targetUnit` before formatting.
    - Fixed `fractionDigits`.
    - Option to `showUnitSymbol`.
    - Custom `unitSymbolSeparator`.
    - Locale-aware number formatting via `locale` parameter (using `intl` package).
    - Full control over number formatting via `numberFormat` parameter (using `intl` package).
  - Arithmetic operations (`+`, `-`, `*` by scalar, `/` by scalar) for most quantities.
  - Specialized arithmetic for `Temperature` (difference `T - T` returns `double`, ratio `T / T` returns `double`).
  - `Comparable` interface implementation for sorting quantities by magnitude.
  - `==` operator override for value and unit equality.
- **Supported Quantity Types (with units and extensions):**
  - **Length:** Meter (m), Kilometer (km), Centimeter (cm), Millimeter (mm), Inch (in), Foot (ft), Yard (yd), Mile (mi), Nautical Mile (nmi).
  - **Time:** Second (s), Millisecond (ms), Minute (min), Hour (h), Day (d).
  - **Temperature:** Kelvin (K), Celsius (°C), Fahrenheit (°F). Handles affine conversions correctly.
  - **Pressure:** Pascal (Pa), Atmosphere (atm), Bar (bar), PSI (psi), Torr, mmHg, inHg, kPa, hPa, mbar, cmH₂O, inH₂O.

<!-- END FILE: [v0.12.0] CHANGELOG.md -->

<!-- BEGIN FILE: [v0.12.0] LICENSE -->
Copyright 2025 Philipp H. Gerber

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the “Software”), to deal in the Software without
restriction, including without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

<!-- END FILE: [v0.12.0] LICENSE -->

<!-- BEGIN FILE: [v0.12.0] pubspec.yaml -->
name: quantify
description: A type-safe unit of measurement converter library for Dart with elegant syntax, high precision, and optimal performance.
version: 0.12.0

homepage: https://github.com/PhilippHGerber/quantify
repository: https://github.com/PhilippHGerber/quantify
issue_tracker: https://github.com/PhilippHGerber/quantify/issues

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  intl: ">=0.18.1 <0.21.0"
  meta: ^1.16.0

dev_dependencies:
  test: ^1.26.0
  very_good_analysis: ^9.0.0

topics:
  - units
  - unit-converter
  - measurement
  - conversion
  - physics

screenshots:
  - description: "Quantify - Convert SI Units"
    path: pub/quantify.webp

<!-- END FILE: [v0.12.0] pubspec.yaml -->

<!-- BEGIN FILE: [v0.12.0] analysis_options.yaml -->
include: package:very_good_analysis/analysis_options.yaml

formatter:
  page_width: 100
#  trailing_commas: preserve

analyzer:
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"
    - "test/.test_coverage.dart"
    - "bin/cache/**"
    - "lib/generated_plugin_registrant.dart"

  errors:
    unused_import: warning
    todo: ignore

linter:
  rules:
    # Allow relative imports for files within the same package
    always_use_package_imports: false
    # Prefer using relative imports within the same package
    prefer_relative_imports: true
    # Allow lines to exceed 80 characters
    lines_longer_than_80_chars: false
    # Prefer using const constructors where possible
    prefer_const_constructors: true
    # Prefer declaring local variables as final if they are not reassigned
    prefer_final_locals: true
    # Allow mutable literal lists/maps/sets even if they could be const
    prefer_const_literals_to_create_immutables: false
    # Allow explicitly typing closure parameters
    avoid_types_on_closure_parameters: false
    # Allow TODOs without the Flutter-style format (e.g., missing author tags)
    flutter_style_todos: false
    # Use trailing commas for all parameter lists and argument lists.
    require_trailing_commas: true
    # Use enums rather than classes that behave like enums.
    use_enums: true

    # Prototyping and Development:
    # Allow public classes and members without documentation comments
    public_member_api_docs: true

<!-- END FILE: [v0.12.0] analysis_options.yaml -->

<!-- BEGIN FILE: [v0.12.0] lib/acceleration.dart -->
/// Provides type-safe units for Acceleration.
///
/// Import this file to use Acceleration quantities and their extensions on `num`
/// (like `9.8.gravity`, `10.mps_squared`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/acceleration/acceleration.dart';
export 'src/units/acceleration/acceleration_extensions.dart';
export 'src/units/acceleration/acceleration_unit.dart';

<!-- END FILE: [v0.12.0] lib/acceleration.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/angle.dart -->
/// Provides type-safe units for Angle.
///
/// Import this file to use Angle quantities and their extensions on `num`
/// (like `90.degrees`, `1.5.radians`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/angle/angle.dart';
export 'src/units/angle/angle_extensions.dart';
export 'src/units/angle/angle_unit.dart';

<!-- END FILE: [v0.12.0] lib/angle.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/angular_velocity.dart -->
/// Provides type-safe units for Angular Velocity.
///
/// Import this file to use AngularVelocity quantities and their extensions on `num`
/// (like `3000.rpm`, `10.radiansPerSecond`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/angular_velocity/angular_velocity.dart';
export 'src/units/angular_velocity/angular_velocity_extensions.dart';
export 'src/units/angular_velocity/angular_velocity_unit.dart';

<!-- END FILE: [v0.12.0] lib/angular_velocity.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/area.dart -->
/// Provides type-safe units for Area.
///
/// Import this file to use Area quantities and their extensions on `num`
/// (like `100.m2`, `60.ft2`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/area/area.dart';
export 'src/units/area/area_extensions.dart';
export 'src/units/area/area_unit.dart';

<!-- END FILE: [v0.12.0] lib/area.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/constants.dart -->
/// Physical, astronomical, and engineering constants for the quantify package.
///
/// This library provides type-safe access to fundamental constants with
/// appropriate units from physics, astronomy, and engineering. By importing this
/// single file, you gain access to all three constant categories.
///
/// ## Usage
///
/// ```dart
/// import 'package:quantify/quantify.dart';
/// import 'package:quantify/constants.dart';
///
/// void main() {
///   // Physical constants are now type-safe Quantities where possible
///   final lightSpeed = PhysicalConstants.speedOfLight; // Returns a Speed object
///   final electronEnergy = PhysicalConstants.electronRestEnergy; // Returns an Energy object
///
///   // Astronomical constants
///   final earthGravity = AstronomicalConstants.standardGravity; // Returns an Acceleration object
///   final sunPower = AstronomicalConstants.solarLuminosity; // Returns a Power object
///
///   // Engineering constants
///   final steelStiffness = EngineeringConstants.steelYoungsModulus; // Returns a Pressure object
///
///   // Use in convenience methods for powerful, type-safe calculations
///   final photonEnergy = PhysicalConstants.photonEnergy(500.0.nm);
///   final escapeVelocity = AstronomicalConstants.escapeVelocity(
///     AstronomicalConstants.earthMass,
///     AstronomicalConstants.earthRadius,
///   );
///
///   print('Speed of light: ${lightSpeed.asKilometersPerHour}');
///   print('Earth standard gravity: ${earthGravity.asMetersPerSecondSquared}');
///   print('Energy of a 500nm photon: ${photonEnergy.inElectronvolts.toStringAsFixed(2)} eV');
/// }
/// ```
///
/// ## Constant Categories
///
/// ### PhysicalConstants
/// Fundamental constants from physics including the speed of light, Planck constant,
/// elementary charge, particle masses, quantum and electromagnetic constants, and
/// convenience methods for common physics calculations.
///
/// ### AstronomicalConstants
/// Constants from astronomy and astrophysics including solar system body properties
/// (masses, radii, distances), galactic and cosmological scales, stellar physics
/// constants, and convenience methods for orbital mechanics.
///
/// ### EngineeringConstants
/// Practical constants for engineering including standard conditions (STP, NTP),
/// material properties (density, strength), mechanical properties (Young's modulus),
/// and convenience methods for common engineering calculations.
library;

export 'src/constants/astronomical_constants.dart';
export 'src/constants/engineering_constants.dart';
export 'src/constants/physical_constants.dart';

<!-- END FILE: [v0.12.0] lib/constants.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/current.dart -->
/// Provides type-safe units for Electric Current.
///
/// Import this file to use Current quantities and their extensions on `num`
/// (like `1.5.A`, `20.mA`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/current/current.dart';
export 'src/units/current/current_extensions.dart';
export 'src/units/current/current_unit.dart';

<!-- END FILE: [v0.12.0] lib/current.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/electric_charge.dart -->
/// Provides type-safe units for Electric Charge.
///
/// Import this file to use ElectricCharge quantities and their extensions on `num`
/// (like `5000.ah`, `1.6e-19.coulombs`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/electric_charge/electric_charge.dart';
export 'src/units/electric_charge/electric_charge_extensions.dart';
export 'src/units/electric_charge/electric_charge_unit.dart';

<!-- END FILE: [v0.12.0] lib/electric_charge.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/energy.dart -->
// lib/energy.dart

/// Provides type-safe units for Energy.
///
/// Import this file to use Energy quantities and their extensions on `num`
/// (like `500.J`, `250.kcal`, `1.2.kWh`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/energy/energy.dart';
export 'src/units/energy/energy_extensions.dart';
export 'src/units/energy/energy_unit.dart';

<!-- END FILE: [v0.12.0] lib/energy.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/force.dart -->
/// Provides type-safe units for Force.
///
/// Import this file to use Force quantities and their extensions on `num`
/// (like `100.N`, `50.lbf`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/force/force.dart';
export 'src/units/force/force_extensions.dart';
export 'src/units/force/force_unit.dart';

<!-- END FILE: [v0.12.0] lib/force.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/frequency.dart -->
/// Provides type-safe units for Frequency.
///
/// Import this file to use Frequency quantities and their extensions on `num`
/// (like `4.2.ghz`, `120.bpm`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/frequency/frequency.dart';
export 'src/units/frequency/frequency_extensions.dart';
export 'src/units/frequency/frequency_unit.dart';

<!-- END FILE: [v0.12.0] lib/frequency.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/length.dart -->
/// Provides type-safe units for Length.
///
/// Import this file to use Length quantities and their extensions on `num`
/// (like `10.m`, `5.ft`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/length/length.dart';
export 'src/units/length/length_extensions.dart';
export 'src/units/length/length_unit.dart';

<!-- END FILE: [v0.12.0] lib/length.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/luminous_intensity.dart -->
/// Provides type-safe units for Luminous Intensity.
///
/// Import this file to use LuminousIntensity quantities and their extensions on `num`
/// (like `150.cd`, `500.mcd`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/luminous/luminous_intensity.dart';
export 'src/units/luminous/luminous_intensity_extensions.dart';
export 'src/units/luminous/luminous_intensity_unit.dart';

<!-- END FILE: [v0.12.0] lib/luminous_intensity.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/mass.dart -->
/// Provides type-safe units for Mass.
///
/// Import this file to use Mass quantities and their extensions on `num`
/// (like `70.kg`, `500.g`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/mass/mass.dart';
export 'src/units/mass/mass_extensions.dart';
export 'src/units/mass/mass_unit.dart';

<!-- END FILE: [v0.12.0] lib/mass.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/molar.dart -->
/// Provides type-safe units for Amount of Substance (Molar Amount).
///
/// Import this file to use MolarAmount quantities and their extensions on `num`
/// (like `0.5.mol`, `25.mmol`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/molar/molar_amount.dart';
export 'src/units/molar/molar_extensions.dart';
export 'src/units/molar/molar_unit.dart';

<!-- END FILE: [v0.12.0] lib/molar.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/power.dart -->
// lib/power.dart

/// Provides type-safe units for Power.
///
/// Import this file to use Power quantities and their extensions on `num`
/// (like `100.kW`, `250.hp`, `1.2.gigaW`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/power/power.dart';
export 'src/units/power/power_extensions.dart';
export 'src/units/power/power_unit.dart';

<!-- END FILE: [v0.12.0] lib/power.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/pressure.dart -->
/// Provides type-safe units for Pressure.
///
/// Import this file to use Pressure quantities and their extensions on `num`
/// (like `1.atm`, `32.psi`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/pressure/pressure.dart';
export 'src/units/pressure/pressure_extensions.dart';
export 'src/units/pressure/pressure_unit.dart';

<!-- END FILE: [v0.12.0] lib/pressure.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/quantify.dart -->
/// A type-safe library for units of measurement, providing elegant syntax for unit conversions.
library;

// Exporting core classes for quantities and units
export 'src/core/quantity.dart';
export 'src/core/unit.dart';
// Exporting units and their extensions for acceleration
export 'src/units/acceleration/acceleration.dart';
export 'src/units/acceleration/acceleration_extensions.dart';
export 'src/units/acceleration/acceleration_unit.dart';
// Exporting units and their extensions for angle
export 'src/units/angle/angle.dart';
export 'src/units/angle/angle_extensions.dart';
export 'src/units/angle/angle_unit.dart';
// Exporting units and their extensions for angular velocity
export 'src/units/angular_velocity/angular_velocity.dart';
export 'src/units/angular_velocity/angular_velocity_extensions.dart';
export 'src/units/angular_velocity/angular_velocity_unit.dart';
// Exporting units and their extensions for area
export 'src/units/area/area.dart';
export 'src/units/area/area_extensions.dart';
export 'src/units/area/area_unit.dart';
// Exporting units and their extensions for electric current
export 'src/units/current/current.dart';
export 'src/units/current/current_extensions.dart';
export 'src/units/current/current_unit.dart';
// Exporting units and their extensions for electric charge
export 'src/units/electric_charge/electric_charge.dart';
export 'src/units/electric_charge/electric_charge_extensions.dart';
export 'src/units/electric_charge/electric_charge_unit.dart';
// Exporting units and their extensions for energy
export 'src/units/energy/energy.dart';
export 'src/units/energy/energy_extensions.dart';
export 'src/units/energy/energy_unit.dart';
// Exporting units and their extensions for force
export 'src/units/force/force.dart';
export 'src/units/force/force_extensions.dart';
export 'src/units/force/force_unit.dart';
// Exporting units and their extensions for frequency
export 'src/units/frequency/frequency.dart';
export 'src/units/frequency/frequency_extensions.dart' hide FrequencyCreationRpm;
export 'src/units/frequency/frequency_interop.dart';
export 'src/units/frequency/frequency_unit.dart';
// Exporting units and their extensions for length
export 'src/units/length/length.dart';
export 'src/units/length/length_extensions.dart';
export 'src/units/length/length_unit.dart';
// Exporting units and their extensions for luminous intensity
export 'src/units/luminous/luminous_intensity.dart';
export 'src/units/luminous/luminous_intensity_extensions.dart';
export 'src/units/luminous/luminous_intensity_unit.dart';
// Exporting units and their extensions for mass
export 'src/units/mass/mass.dart';
export 'src/units/mass/mass_extensions.dart';
export 'src/units/mass/mass_unit.dart';
// Exporting units and their extensions for molar amount
export 'src/units/molar/molar_amount.dart';
export 'src/units/molar/molar_extensions.dart';
export 'src/units/molar/molar_unit.dart';
// Exporting units and their extensions for power
export 'src/units/power/power.dart';
export 'src/units/power/power_extensions.dart';
export 'src/units/power/power_unit.dart';
// Exporting units and their extensions for pressure
export 'src/units/pressure/pressure.dart';
export 'src/units/pressure/pressure_extensions.dart';
export 'src/units/pressure/pressure_unit.dart';
// Exporting units and their extensions for solid angle
export 'src/units/solid_angle/solid_angle.dart';
export 'src/units/solid_angle/solid_angle_extensions.dart';
export 'src/units/solid_angle/solid_angle_unit.dart';
// Exporting units and their extensions for speed
export 'src/units/speed/speed.dart';
export 'src/units/speed/speed_extensions.dart';
export 'src/units/speed/speed_unit.dart';
// Exporting units and their extensions for temperature
export 'src/units/temperature/temperature.dart';
export 'src/units/temperature/temperature_extensions.dart';
export 'src/units/temperature/temperature_unit.dart';
// Exporting units and their extensions for time
export 'src/units/time/time.dart';
export 'src/units/time/time_extensions.dart';
export 'src/units/time/time_unit.dart';
// Exporting units and their extensions for volume
export 'src/units/volume/volume.dart';
export 'src/units/volume/volume_extensions.dart';
export 'src/units/volume/volume_unit.dart';

<!-- END FILE: [v0.12.0] lib/quantify.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/solid_angle.dart -->
/// Provides type-safe units for Solid Angle.
///
/// Import this file to use SolidAngle quantities and their extensions on `num`
/// (like `1.5.sr`, `4000.deg2`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/solid_angle/solid_angle.dart';
export 'src/units/solid_angle/solid_angle_extensions.dart';
export 'src/units/solid_angle/solid_angle_unit.dart';

<!-- END FILE: [v0.12.0] lib/solid_angle.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/speed.dart -->
/// Provides type-safe units for Speed.
///
/// Import this file to use Speed quantities and their extensions on `num`
/// (like `100.kmh`, `60.mph`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/speed/speed.dart';
export 'src/units/speed/speed_extensions.dart';
export 'src/units/speed/speed_unit.dart';

<!-- END FILE: [v0.12.0] lib/speed.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/constants/astronomical_constants.dart -->
import 'dart:math' as math;

import '../../acceleration.dart';
import '../../frequency.dart';
import '../../length.dart';
import '../../mass.dart';
import '../../power.dart';
import '../../speed.dart';
import '../../temperature.dart';
import '../../time.dart';
import 'physical_constants.dart';

/// Astronomical and astrophysical constants with their respective units.
///
/// All constants are based on IAU (International Astronomical Union)
/// recommendations and recent astronomical measurements.
///
/// References:
/// - IAU 2015 Resolution B3: https://www.iau.org/static/resolutions/IAU2015_English.pdf
/// - NASA Planetary Fact Sheets: https://nssdc.gsfc.nasa.gov/planetary/factsheet/
/// - CODATA 2018 values for fundamental constants
class AstronomicalConstants {
  // Private constructor to prevent instantiation
  AstronomicalConstants._();

  // === FUNDAMENTAL ASTRONOMICAL UNITS ===

  /// Astronomical Unit (AU).
  /// Value: 149,597,870.7 km (exact by IAU definition).
  ///
  /// The average distance from the Earth to the Sun, used as a fundamental
  /// unit for distances within the Solar System.
  static const Length astronomicalUnit = Length(149597870700, LengthUnit.meter);

  /// Light Year (ly).
  /// Value: 9.4607304725808×10¹⁵ m.
  ///
  /// The distance light travels in one Julian year (365.25 days).
  static const Length lightYear = Length(9460730472580800, LengthUnit.lightYear);

  /// Parsec (pc).
  /// Value: 3.0856775814913673×10¹⁶ m.
  ///
  /// The distance at which one astronomical unit subtends an angle of one arcsecond.
  static const Length parsec = Length(30856775814913672, LengthUnit.parsec);

  // === SOLAR SYSTEM BODIES ===

  /// Solar mass (M☉).
  /// Value: 1.98847×10³⁰ kg.
  ///
  /// The total mass of the Sun, a fundamental unit for stellar masses.
  static const Mass solarMass = Mass(1.98847e30, MassUnit.kilogram);

  /// Solar radius (R☉).
  /// Value: 6.957×10⁸ m.
  ///
  /// The radius of the Sun from its center to the photosphere.
  static const Length solarRadius = Length(695700000, LengthUnit.meter);

  /// Solar luminosity (L☉).
  /// Value: 3.828×10²⁶ W.
  ///
  /// The total power output of the Sun.
  static const Power solarLuminosity = Power(3.828e26, PowerUnit.watt);

  /// Solar effective temperature.
  /// Value: 5778 K.
  ///
  /// The effective black-body temperature of the Sun's photosphere.
  static const Temperature solarEffectiveTemperature = Temperature(5778, TemperatureUnit.kelvin);

  /// Earth mass (M⊕).
  /// Value: 5.9722×10²⁴ kg.
  ///
  /// The total mass of Earth, a fundamental unit for terrestrial planet masses.
  static const Mass earthMass = Mass(5.9722e24, MassUnit.kilogram);

  /// Earth equatorial radius (R⊕).
  /// Value: 6.37814×10⁶ m.
  ///
  /// Earth's radius at the equator.
  static const Length earthRadius = Length(6378140, LengthUnit.meter);

  /// Earth polar radius.
  /// Value: 6.35675×10⁶ m.
  ///
  /// Earth's radius at the poles, reflecting its oblate shape.
  static const Length earthPolarRadius = Length(6356750, LengthUnit.meter);

  /// Moon mass.
  /// Value: 7.342×10²² kg.
  static const Mass moonMass = Mass(7.342e22, MassUnit.kilogram);

  /// Moon radius.
  /// Value: 1.737×10⁶ m.
  static const Length moonRadius = Length(1737000, LengthUnit.meter);

  /// Earth-Moon distance (semi-major axis).
  /// Value: 3.844×10⁸ m.
  static const Length earthMoonDistance = Length(384400000, LengthUnit.meter);

  // === PLANETARY MASSES ===

  /// Mercury mass.
  /// Value: 3.301×10²³ kg.
  static const Mass mercuryMass = Mass(3.301e23, MassUnit.kilogram);

  /// Mercury radius (mean).
  /// Value: 2.4397×10⁶ m.
  /// Source: NASA Planetary Fact Sheet.
  static const Length mercuryRadius = Length(2439700, LengthUnit.meter);

  /// Venus mass.
  /// Value: 4.867×10²⁴ kg.
  static const Mass venusMass = Mass(4.867e24, MassUnit.kilogram);

  /// Venus radius (mean).
  /// Value: 6.0518×10⁶ m.
  /// Source: NASA Planetary Fact Sheet.
  static const Length venusRadius = Length(6051800, LengthUnit.meter);

  /// Mars mass.
  /// Value: 6.39×10²³ kg.
  static const Mass marsMass = Mass(6.39e23, MassUnit.kilogram);

  /// Mars radius (mean).
  /// Value: 3.3895×10⁶ m.
  /// Source: NASA Planetary Fact Sheet.
  static const Length marsRadius = Length(3389500, LengthUnit.meter);

  /// Jupiter mass (MJ).
  /// Value: 1.898×10²⁷ kg.
  ///
  /// A fundamental unit for gas giant masses.
  static const Mass jupiterMass = Mass(1.898e27, MassUnit.kilogram);

  /// Jupiter radius (equatorial).
  /// Value: 7.1492×10⁷ m.
  /// Source: NASA Planetary Fact Sheet.
  static const Length jupiterRadius = Length(71492000, LengthUnit.meter);

  /// Saturn mass.
  /// Value: 5.683×10²⁶ kg.
  static const Mass saturnMass = Mass(5.683e26, MassUnit.kilogram);

  /// Saturn radius (equatorial).
  /// Value: 6.0268×10⁷ m.
  /// Source: NASA Planetary Fact Sheet.
  static const Length saturnRadius = Length(60268000, LengthUnit.meter);

  /// Uranus mass.
  /// Value: 8.681×10²⁵ kg.
  static const Mass uranusMass = Mass(8.681e25, MassUnit.kilogram);

  /// Uranus radius (equatorial).
  /// Value: 2.5559×10⁷ m.
  /// Source: NASA Planetary Fact Sheet.
  static const Length uranusRadius = Length(25559000, LengthUnit.meter);

  /// Neptune mass.
  /// Value: 1.024×10²⁶ kg.
  static const Mass neptuneMass = Mass(1.024e26, MassUnit.kilogram);

  /// Neptune radius (equatorial).
  /// Value: 2.4764×10⁷ m.
  /// Source: NASA Planetary Fact Sheet.
  static const Length neptuneRadius = Length(24764000, LengthUnit.meter);

  // === GALACTIC AND EXTRAGALACTIC ===

  /// Milky Way mass.
  /// Value: ~1.5×10¹² M☉ ≈ 2.98×10⁴² kg.
  ///
  /// The estimated total mass of the Milky Way galaxy, including dark matter.
  static const Mass milkyWayMass = Mass(2.98e42, MassUnit.kilogram);

  /// Galactic center distance.
  /// Value: 2.615×10²⁰ m ≈ 26,000 ly.
  ///
  /// The distance from the Solar System to Sagittarius A*, the galactic center.
  static const Length galacticCenterDistance = Length(2.615e20, LengthUnit.meter);

  /// Hubble constant (H₀).
  /// Value: 67.4 km/(s⋅Mpc) ≈ 2.18×10⁻¹⁸ s⁻¹.
  ///
  /// The current expansion rate of the universe. Represented as a [Frequency]
  /// in its base unit of inverse seconds (s⁻¹).
  static const Frequency hubbleConstant = Frequency(2.18e-18, FrequencyUnit.hertz);

  /// Critical density of the universe.
  /// Value: 9.47×10⁻²⁷ kg/m³.
  ///
  /// The mass-energy density required for a flat universe geometry.
  /// Note: This would ideally be a `Density` quantity.
  static const double criticalDensity = 9.47e-27; // kg/m³

  /// Observable universe radius.
  /// Value: 4.40×10²⁶ m ≈ 46.5 billion ly.
  ///
  /// The current proper distance to the edge of the observable universe.
  static const Length observableUniverseRadius = Length(4.40e26, LengthUnit.meter);

  // === STELLAR CONSTANTS ===

  /// Chandrasekhar limit.
  /// Value: 2.785×10³⁰ kg ≈ 1.4 M☉.
  ///
  /// The maximum mass of a stable white dwarf star.
  static const Mass chandrasekharLimit = Mass(2.785e30, MassUnit.kilogram);

  /// Schwarzschild radius of a solar mass black hole.
  /// Value: 2.954×10³ m ≈ 2.95 km.
  ///
  /// The event horizon radius for a non-rotating black hole with the mass of the Sun.
  static const Length solarMassSchwarzschildRadius = Length(2954, LengthUnit.meter);

  /// Planck mass.
  /// Value: 2.176434×10⁻⁸ kg.
  ///
  /// A fundamental mass scale in quantum gravity.
  static const Mass planckMass = Mass(2.176434e-8, MassUnit.kilogram);

  /// Planck length.
  /// Value: 1.616255×10⁻³⁵ m.
  ///
  /// A fundamental length scale in quantum gravity.
  static const Length planckLength = Length(1.616255e-35, LengthUnit.meter);

  /// Planck time.
  /// Value: 5.391247×10⁻⁴⁴ s.
  ///
  /// A fundamental time scale in quantum gravity.
  static const Time planckTime = Time(5.391247e-44, TimeUnit.second);

  // === EARTH PROPERTIES ===

  /// Standard gravity (g₀).
  /// Value: 9.80665 m/s² (exact by definition).
  ///
  /// The standard acceleration due to gravity at Earth's surface.
  static const Acceleration standardGravity = Acceleration(
    9.80665,
    AccelerationUnit.meterPerSecondSquared,
  );

  /// Earth's rotational period (sidereal day).
  /// Value: 86164.0905 s ≈ 23h 56m 4s.
  ///
  /// The time for one rotation of Earth relative to distant stars.
  static const Time siderealDay = Time(86164.0905, TimeUnit.second);

  /// Earth's orbital period (sidereal year).
  /// Value: 3.155815×10⁷ s ≈ 365.256 days.
  ///
  /// The time for one orbit of Earth around the Sun.
  static const Time siderealYear = Time(31558150, TimeUnit.second);

  /// Earth's mean orbital velocity.
  /// Value: 29.78 km/s.
  /// Source: NASA Planetary Fact Sheet.
  static const Speed earthOrbitalVelocity = Speed(29780, SpeedUnit.meterPerSecond);

  /// Geostationary orbit radius, measured from Earth's center.
  /// Value: 42,164 km.
  /// The altitude at which an object's orbital period matches Earth's rotational period.
  static const Length geostationaryOrbitRadius = Length(42164000, LengthUnit.meter);

  /// Solar constant.
  /// The mean solar electromagnetic radiation per unit area that would be incident
  /// on a plane perpendicular to the rays, at a distance of one astronomical unit (AU) from the Sun.
  /// Value: ~1361 W/m².
  /// Note: This would ideally be an `Irradiance` quantity (Power/Area).
  static const double solarConstant = 1361;

  /// Escape velocity from Earth's surface.
  /// Value: 1.119×10⁴ m/s ≈ 11.19 km/s.
  ///
  /// The minimum speed needed for an object to escape from Earth's gravitational
  /// influence without further propulsion.
  static const Speed earthEscapeVelocity = Speed(11190, SpeedUnit.meterPerSecond);

  // === COSMOLOGICAL TIMES ===

  /// Age of the universe.
  /// Value: 4.35×10¹⁷ s ≈ 13.8 billion years.
  ///
  /// The time elapsed since the Big Bang.
  static const Time ageOfUniverse = Time(435000000000000000, TimeUnit.second);

  /// Cosmic microwave background temperature.
  /// Value: 2.72548 K.
  ///
  /// The current temperature of the cosmic microwave background radiation.
  static const Temperature cmbTemperature = Temperature(2.72548, TemperatureUnit.kelvin);

  // === CONVENIENCE METHODS ===

  /// Calculates the gravitational acceleration at the surface of a celestial body.
  ///
  /// Returns the acceleration as an [Acceleration] quantity.
  /// Usage: `final g = AstronomicalConstants.surfaceGravity(earthMass, earthRadius);`
  static Acceleration surfaceGravity(Mass bodyMass, Length bodyRadius) {
    final mass = bodyMass.getValue(MassUnit.kilogram);
    final radius = bodyRadius.getValue(LengthUnit.meter);
    const gravConstant = PhysicalConstants.gravitationalConstant;
    final accelerationValue = gravConstant * mass / (radius * radius); // g = GM/r²
    return Acceleration(accelerationValue, AccelerationUnit.meterPerSecondSquared);
  }

  /// Calculates the escape velocity from the surface of a celestial body.
  ///
  /// Returns the velocity as a [Speed] quantity.
  /// Usage: `final v = AstronomicalConstants.escapeVelocity(earthMass, earthRadius);`
  static Speed escapeVelocity(Mass bodyMass, Length bodyRadius) {
    final mass = bodyMass.getValue(MassUnit.kilogram);
    final radius = bodyRadius.getValue(LengthUnit.meter);
    const gravConstant = PhysicalConstants.gravitationalConstant;
    final v2 = 2.0 * gravConstant * mass / radius; // v² = 2GM/r
    return Speed(math.sqrt(v2), SpeedUnit.meterPerSecond);
  }

  /// Calculates the velocity for a circular orbit at a given radius from a central mass.
  ///
  /// Returns the velocity as a [Speed] quantity.
  /// Usage: `final v = AstronomicalConstants.orbitalVelocity(earthMass, satelliteOrbitRadius);`
  static Speed orbitalVelocity(Mass centralMass, Length orbitalRadius) {
    final mass = centralMass.getValue(MassUnit.kilogram);
    final radius = orbitalRadius.getValue(LengthUnit.meter);
    const gravConstant = PhysicalConstants.gravitationalConstant;
    final v2 = gravConstant * mass / radius; // v² = GM/r
    return Speed(math.sqrt(v2), SpeedUnit.meterPerSecond);
  }

  /// Calculates the Schwarzschild radius (event horizon) for a given mass.
  ///
  /// Returns the radius as a [Length] quantity.
  /// Usage: `final rs = AstronomicalConstants.schwarzschildRadius(solarMass);`
  static Length schwarzschildRadius(Mass mass) {
    final massInKg = mass.getValue(MassUnit.kilogram);
    const gravConstant = PhysicalConstants.gravitationalConstant;
    final speedOfLightMs = PhysicalConstants.speedOfLight.inMetersPerSecond;
    final rs = 2.0 * gravConstant * massInKg / (speedOfLightMs * speedOfLightMs); // rs = 2GM/c²
    return Length(rs, LengthUnit.meter);
  }

  /// Calculates the orbital period of a body around a central mass using
  /// Kepler's third law.
  ///
  /// `T = 2π * sqrt(a³ / GM)`
  ///
  /// - [semiMajorAxis]: The semi-major axis of the orbit.
  /// - [centralMass]: The mass of the central body being orbited.
  ///
  /// Returns the orbital period as a [Time] quantity in seconds.
  /// Throws [ArgumentError] if the central mass or semi-major axis is zero.
  static Time orbitalPeriod(Length semiMajorAxis, Mass centralMass) {
    if (centralMass.value <= 0 || semiMajorAxis.value <= 0) {
      throw ArgumentError('Central mass and semi-major axis must be positive.');
    }
    final a3 = math.pow(semiMajorAxis.inM, 3);
    final gm = PhysicalConstants.gravitationalConstant * centralMass.inKilograms;
    final seconds = 2 * math.pi * math.sqrt(a3 / gm);
    return Time(seconds, TimeUnit.second);
  }
}

<!-- END FILE: [v0.12.0] lib/src/constants/astronomical_constants.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/constants/engineering_constants.dart -->
import '../../area.dart';
import '../../energy.dart';
import '../../force.dart';
import '../../length.dart';
import '../../mass.dart';
import '../../power.dart';
import '../../pressure.dart';
import '../../speed.dart';
import '../../temperature.dart';

/// Engineering and technical constants with their respective units.
///
/// These constants are commonly used in engineering calculations,
/// material science, and industrial applications.
///
/// References:
/// - NIST Reference Fluid Thermodynamic and Transport Properties
/// - Engineering Standards and Handbooks
/// - International Standards Organization (ISO)
class EngineeringConstants {
  // Private constructor to prevent instantiation
  EngineeringConstants._();

  // === STANDARD CONDITIONS ===

  /// Standard Temperature (STP).
  /// Value: 273.15 K (0°C).
  ///
  /// The IUPAC definition of standard temperature.
  static const Temperature standardTemperature = Temperature(273.15, TemperatureUnit.kelvin);

  /// Standard Pressure (STP).
  /// Value: 100,000 Pa (1 bar).
  ///
  /// The IUPAC definition of standard pressure (changed from 1 atm in 1982).
  static const Pressure standardPressure = Pressure(100000, PressureUnit.pascal);

  /// Standard Atmospheric Pressure.
  /// Value: 101,325 Pa (1 atm).
  ///
  /// The historical standard pressure, still widely used in many engineering fields.
  static const Pressure standardAtmosphere = Pressure(101325, PressureUnit.pascal);

  /// Normal Temperature (NTP).
  /// Value: 293.15 K (20°C).
  ///
  /// A common reference temperature for many engineering calculations.
  static const Temperature normalTemperature = Temperature(293.15, TemperatureUnit.kelvin);

  /// Typical Room Temperature.
  /// Value: 295.15 K (22°C).
  ///
  /// A typical comfortable indoor air temperature.
  static const Temperature roomTemperature = Temperature(295.15, TemperatureUnit.kelvin);

  // === MATERIAL PROPERTIES ===

  /// Density of water at 4°C (maximum density).
  /// Value: 999.97 kg/m³.
  /// Note: This would ideally be a `Density` quantity.
  static const double waterDensityMax = 999.97; // kg/m³

  /// Density of air at STP (standard atmospheric conditions).
  /// Value: 1.225 kg/m³.
  /// Note: This would ideally be a `Density` quantity.
  static const double airDensitySTP = 1.225; // kg/m³

  /// Speed of sound in dry air at 20°C.
  /// Value: 343.2 m/s.
  ///
  /// At sea level, 20°C (293.15 K).
  static const Speed soundSpeedAir20C = Speed(343.2, SpeedUnit.meterPerSecond);

  /// Speed of sound in fresh water at 25°C.
  /// Value: 1497 m/s.
  static const Speed soundSpeedWater25C = Speed(1497, SpeedUnit.meterPerSecond);

  /// Dynamic viscosity of water at 20°C.
  /// Value: 1.002×10⁻³ Pa⋅s.
  /// Note: This would ideally be a `DynamicViscosity` quantity.
  static const double waterViscosity20C = 1.002e-3; // Pa⋅s

  /// Dynamic viscosity of air at 20°C.
  /// Value: 1.81×10⁻⁵ Pa⋅s.
  static const double airViscosity20C = 1.81e-5; // Pa⋅s

  // === THERMAL PROPERTIES ===

  /// Thermal conductivity of copper.
  /// Value: 401 W/(m⋅K).
  ///
  /// High-purity copper at room temperature.
  /// Note: This would ideally be a `ThermalConductivity` quantity.
  static const double copperThermalConductivity = 401; // W/(m⋅K)

  /// Specific heat capacity of water at constant pressure (15°C).
  /// Value: 4184 J/(kg⋅K).
  /// Note: This would ideally be a `SpecificHeatCapacity` quantity.
  static const double waterSpecificHeat = 4184; // J/(kg⋅K)

  /// Latent heat of vaporization of water at 100°C.
  /// Value: 2.26×10⁶ J/kg.
  /// Note: This would ideally be a `SpecificEnergy` quantity.
  static const double waterLatentHeatVaporization = 2260000; // J/kg

  /// Latent heat of fusion of water at 0°C.
  /// Value: 3.34×10⁵ J/kg.
  /// Note: This would ideally be a `SpecificEnergy` quantity.
  static const double waterLatentHeatFusion = 334000; // J/kg

  // === ELECTRICAL PROPERTIES ===

  /// Electrical resistivity of copper at 20°C.
  /// Value: 1.68×10⁻⁸ Ω⋅m.
  /// Note: This would ideally be an `ElectricalResistivity` quantity.
  static const double copperResistivity = 1.68e-8; // Ω⋅m

  // === MECHANICAL PROPERTIES ===

  /// Young's modulus of steel.
  /// Value: 200 GPa (2.0×10¹¹ Pa).
  ///
  /// A measure of stiffness for typical carbon steel.
  static const Pressure steelYoungsModulus = Pressure(200000000000, PressureUnit.pascal);

  /// Young's modulus of aluminum.
  /// Value: 70 GPa (7.0×10¹⁰ Pa).
  static const Pressure aluminumYoungsModulus = Pressure(70000000000, PressureUnit.pascal);

  /// Young's modulus of concrete.
  /// Value: 30 GPa (3.0×10¹⁰ Pa).
  ///
  /// For typical Portland cement concrete.
  static const Pressure concreteYoungsModulus = Pressure(30000000000, PressureUnit.pascal);

  /// Ultimate tensile strength of steel.
  /// Value: 400 MPa (4.0×10⁸ Pa).
  ///
  /// For typical mild steel.
  static const Pressure steelTensileStrength = Pressure(400000000, PressureUnit.pascal);

  /// Yield strength of steel.
  /// Value: 250 MPa (2.5×10⁸ Pa).
  ///
  /// For typical mild steel.
  static const Pressure steelYieldStrength = Pressure(250000000, PressureUnit.pascal);

  /// Poisson's ratio for steel.
  /// Represents the ratio of transverse strain to axial strain.
  /// Value: 0.27-0.30 (using 0.29 as typical).
  static const double steelPoissonsRatio = 0.29;

  /// Poisson's ratio for aluminum.
  /// Value: ~0.33.
  static const double aluminumPoissonsRatio = 0.33;

  /// Poisson's ratio for concrete.
  /// Value: ~0.20.
  static const double concretePoissonsRatio = 0.20;

  /// Coefficient of linear thermal expansion for steel.
  /// Value: 1.2×10⁻⁵ K⁻¹.
  static const double steelThermalExpansion = 1.2e-5; // K⁻¹

  // === COMBUSTION AND ENERGY ===

  /// Lower heating value (LHV) of natural gas (methane).
  /// Value: 5.0×10⁷ J/kg.
  /// Note: This would ideally be a `SpecificEnergy` quantity.
  static const double methaneHeatingValue = 50000000; // J/kg

  /// Stoichiometric air-fuel mass ratio for gasoline.
  /// Value: 14.7.
  ///
  /// The mass ratio of air to fuel for complete combustion.
  static const double gasolineAirFuelRatio = 14.7;

  // === ATOMIC AND NUCLEAR ===

  /// Atomic mass unit in kg.
  /// Value: 1.66053906660×10⁻²⁷ kg.
  static const Mass atomicMassUnit = Mass(1.66053906660e-27, MassUnit.kilogram);

  /// Typical nuclear binding energy per nucleon.
  /// Value: 8 MeV ≈ 1.28×10⁻¹² J.
  ///
  /// The energy scale for nuclear reactions.
  static const Energy nuclearBindingEnergyPerNucleon = Energy(1.28e-12, EnergyUnit.joule);

  // === TYPICAL ENGINEERING VALUES ===

  /// Freezing point of water at 1 atm.
  /// Value: 273.15 K (0°C).
  static const Temperature waterFreezingPoint = Temperature(273.15, TemperatureUnit.kelvin);

  /// Boiling point of water at 1 atm.
  /// Value: 373.15 K (100°C).
  static const Temperature waterBoilingPoint = Temperature(373.15, TemperatureUnit.kelvin);

  /// Typical human body temperature.
  /// Value: 310.15 K (37°C).
  static const Temperature bodyTemperature = Temperature(310.15, TemperatureUnit.kelvin);

  // === CONVENIENCE METHODS ===

  /// Calculates the Reynolds number for internal pipe flow.
  ///
  /// Returns a dimensionless Reynolds number.
  /// Usage: `final Re = EngineeringConstants.reynoldsNumberPipe(velocity, diameter, kinematicViscosity);`
  static double reynoldsNumberPipe(Speed velocity, Length diameter, double kinematicViscosity) {
    final v = velocity.inMetersPerSecond;
    final d = diameter.inM;
    return v * d / kinematicViscosity; // Re = vD/ν
  }

  /// Calculates the pressure drop in a pipe using the Darcy-Weisbach equation.
  ///
  /// Returns the pressure drop as a [Pressure] quantity.
  /// Usage: `final dp = EngineeringConstants.pipePressureDrop(frictionFactor, length, diameter, velocity, density);`
  static Pressure pipePressureDrop(
    double frictionFactor,
    Length length,
    Length diameter,
    Speed velocity,
    double density,
  ) {
    final L = length.inM;
    final D = diameter.inM;
    final v = velocity.inMetersPerSecond;
    final pressureDropPa = frictionFactor * (L / D) * (density * v * v / 2.0); // Δp = f(L/D)(ρv²/2)
    return Pressure(pressureDropPa, PressureUnit.pascal);
  }

  /// Calculates the thermal expansion of a material.
  ///
  /// Returns the change in length as a [Length] quantity.
  /// Usage: `final deltaL = EngineeringConstants.thermalExpansion(originalLength, expansionCoeff, tempChange);`
  static Length thermalExpansion(
    Length originalLength,
    double expansionCoefficient,
    Temperature temperatureChange,
  ) {
    final l0 = originalLength.inM;
    // Temperature difference is valid regardless of the unit scale, but value must be absolute diff
    final deltaT = temperatureChange.getValue(TemperatureUnit.kelvin);
    final deltaL = l0 * expansionCoefficient * deltaT; // ΔL = L₀αΔT
    return Length(deltaL, LengthUnit.meter);
  }

  /// Calculates the heat transfer rate by conduction through a material.
  ///
  /// Returns the heat transfer rate as a [Power] quantity (in Watts).
  /// Usage: `final q = EngineeringConstants.conductiveHeatTransfer(k, area, thickness, tempDiff);`
  static Power conductiveHeatTransfer(
    double thermalConductivity, // W/(m⋅K)
    Area area,
    Length thickness,
    Temperature temperatureDifference,
  ) {
    final A = area.inSquareMeters;
    final dx = thickness.inM;
    final deltaT = temperatureDifference.getValue(TemperatureUnit.kelvin);
    final heatRateW = thermalConductivity * A * deltaT / dx; // q = kA(ΔT/Δx)
    return Power(heatRateW, PowerUnit.watt);
  }

  /// Calculates the electrical resistance of a conductor.
  ///
  /// Returns the resistance in Ohms (Ω) as a [double].
  /// Usage: `final R = EngineeringConstants.electricalResistance(resistivity, length, area);`
  static double electricalResistance(double resistivity, Length length, Area crossSectionArea) {
    final L = length.inM;
    final A = crossSectionArea.inSquareMeters;
    return resistivity * L / A; // R = ρL/A
  }

  /// Calculates the stress from a [Force] applied over an [Area].
  ///
  /// Returns the stress as a [Pressure] quantity (in Pascals).
  /// Usage: `final stress = EngineeringConstants.mechanicalStress(force, area);`
  static Pressure mechanicalStress(Force force, Area area) {
    final F = force.inNewtons;
    final A = area.inSquareMeters;
    return Pressure(F / A, PressureUnit.pascal); // σ = F/A
  }

  /// Calculates the strain from a given [Pressure] (stress) and Young's modulus.
  ///
  /// Both stress and Young's modulus are represented by [Pressure].
  /// Returns a dimensionless strain value.
  /// Usage: `final strain = EngineeringConstants.mechanicalStrain(stress, youngsModulus);`
  static double mechanicalStrain(Pressure stress, Pressure youngsModulus) {
    // Convert both to the same base unit (Pascals) for a dimensionless ratio.
    final s = stress.inPa;
    final e = youngsModulus.inPa;
    if (e == 0) {
      throw ArgumentError('Youngs modulus cannot be zero.');
    }
    return s / e; // ε = σ/E
  }
}

<!-- END FILE: [v0.12.0] lib/src/constants/engineering_constants.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/constants/physical_constants.dart -->
import '../../electric_charge.dart';
import '../../energy.dart';
import '../../force.dart';
import '../../length.dart';
import '../../mass.dart';
import '../../speed.dart';
import '../../temperature.dart';
import '../../time.dart';

/// Fundamental physical constants with their respective units.
///
/// All constants are based on the 2018 CODATA recommended values
/// and are defined as immutable static constants with appropriate
/// Quantity types for type safety.
///
/// References:
/// - CODATA 2018: https://physics.nist.gov/cuu/Constants/
/// - NIST Reference on Constants: https://www.nist.gov/pml/fundamental-physical-constants
class PhysicalConstants {
  // Private constructor to prevent instantiation
  PhysicalConstants._();

  // === FUNDAMENTAL CONSTANTS ===

  /// Speed of light in vacuum (c).
  /// Exact value: 299,792,458 m/s.
  ///
  /// This is an exact value by definition since the meter is defined
  /// in terms of the speed of light.
  static const Speed speedOfLight = Speed(299792458, SpeedUnit.meterPerSecond);

  /// Planck constant (h).
  /// Value: 6.62607015×10⁻³⁴ J⋅s.
  ///
  /// This is an exact value by definition since the 2019 SI redefinition.
  /// Note: This is represented as a [double] as a `JouleSecond` quantity type
  /// is not yet implemented.
  static const double planckConstant = 6.62607015e-34; // J⋅s

  /// Reduced Planck constant (ℏ = h/2π).
  /// Value: 1.054571817×10⁻³⁴ J⋅s.
  static const double reducedPlanckConstant = 1.054571817e-34; // J⋅s

  /// The elementary charge (e) as an [ElectricCharge] quantity.
  /// Value: 1.602176634×10⁻¹⁹ C.
  ///
  /// This is an exact value by definition since the 2019 SI redefinition.
  static const ElectricCharge elementaryCharge = ElectricCharge(
    1.602176634e-19,
    ElectricChargeUnit.coulomb,
  );

  /// Avogadro constant (Nₐ).
  /// Value: 6.02214076×10²³ mol⁻¹.
  ///
  /// This is an exact value by definition since the 2019 SI redefinition.
  /// Note: This is represented as a [double] because its unit is mol⁻¹, a
  /// compound unit not yet represented by a `Quantity` type.
  static const double avogadroConstant = 6.02214076e23; // mol⁻¹

  /// Boltzmann constant (k).
  /// Value: 1.380649×10⁻²³ J/K.
  ///
  /// This is an exact value by definition since the 2019 SI redefinition.
  /// Note: This would ideally be an `Energy` per `Temperature` quantity.
  static const double boltzmannConstant = 1.380649e-23; // J/K

  /// Gas constant (R = Nₐ × k).
  /// Value: 8.314462618 J/(mol⋅K).
  ///
  /// Derived from Avogadro and Boltzmann constants.
  static const double gasConstant = 8.314462618; // J/(mol⋅K)

  /// Faraday constant (F = Nₐ × e).
  /// Value: 96485.33212 C/mol.
  /// Represents the electric charge per mole of elementary charges.
  /// Source: CODATA 2018.
  /// Note: This is a [double] as a `ChargePerMole` quantity is not yet implemented.
  static const double faradayConstant = 96485.33212;

  /// Gravitational constant (G).
  /// Value: 6.67430×10⁻¹¹ m³/(kg⋅s²).
  ///
  /// This is the least precisely known fundamental constant.
  /// Note: This would ideally be a compound `Quantity` type.
  static const double gravitationalConstant = 6.67430e-11; // m³/(kg⋅s²)

  /// Fine-structure constant (α).
  /// Value: 7.2973525693×10⁻³.
  ///
  /// Dimensionless constant characterizing the strength of electromagnetic interaction.
  static const double fineStructureConstant = 7.2973525693e-3;

  /// Vacuum permeability (μ₀).
  /// Value: 4π×10⁻⁷ H/m.
  ///
  /// Exact value by definition.
  /// Note: This would ideally be a `MagneticPermeability` quantity.
  static const double vacuumPermeability = 4.0e-7 * 3.14159265358979323846; // H/m

  /// Vacuum permittivity (ε₀ = 1/(μ₀c²)).
  /// Value: 8.8541878128×10⁻¹² F/m.
  ///
  /// Derived from vacuum permeability and speed of light.
  /// Note: This would ideally be an `ElectricPermittivity` quantity.
  static const double vacuumPermittivity = 8.8541878128e-12; // F/m

  /// Bohr magneton (μB).
  /// Value: 9.2740100783×10⁻²⁴ J/T.
  /// The magnetic moment of an electron caused by its orbital or spin angular momentum.
  /// Source: CODATA 2018.
  /// Note: This is a [double] as a `EnergyPerMagneticFluxDensity` quantity is not yet implemented.
  static const double bohrMagneton = 9.2740100783e-24;

  /// Nuclear magneton (μN).
  /// Value: 5.0507837461×10⁻²⁷ J/T.
  /// A physical constant of magnetic moment for heavy particles like nucleons.
  /// Source: CODATA 2018.
  /// Note: This is a [double] as a `EnergyPerMagneticFluxDensity` quantity is not yet implemented.
  static const double nuclearMagneton = 5.0507837461e-27;

  // === PARTICLE MASSES ===

  /// Electron mass (mₑ).
  /// Value: 9.1093837015×10⁻³¹ kg.
  static const Mass electronMass = Mass(9.1093837015e-31, MassUnit.kilogram);

  /// Proton mass (mₚ).
  /// Value: 1.67262192369×10⁻²⁷ kg.
  static const Mass protonMass = Mass(1.67262192369e-27, MassUnit.kilogram);

  /// Neutron mass (mₙ).
  /// Value: 1.67492749804×10⁻²⁷ kg.
  static const Mass neutronMass = Mass(1.67492749804e-27, MassUnit.kilogram);

  /// Deuteron mass.
  /// The mass of the nucleus of a deuterium atom, consisting of one proton and one neutron.
  /// Value: 3.3435837724×10⁻²⁷ kg.
  /// Source: CODATA 2018.
  static const Mass deuteronMass = Mass(3.3435837724e-27, MassUnit.kilogram);

  /// Alpha particle mass.
  /// The mass of the nucleus of a helium-4 atom, consisting of two protons and two neutrons.
  /// Value: 6.6446573357×10⁻²⁷ kg.
  /// Source: CODATA 2018.
  static const Mass alphaParticleMass = Mass(6.6446573357e-27, MassUnit.kilogram);

  /// Atomic mass constant (mᵤ = 1 u).
  /// Value: 1.66053906660×10⁻²⁷ kg.
  ///
  /// This is exactly 1/12 of the mass of a carbon-12 atom.
  static const Mass atomicMassConstant = Mass(1.66053906660e-27, MassUnit.kilogram);

  // === DERIVED CONSTANTS ===

  /// Electron charge-to-mass ratio (e/mₑ).
  /// Value: 1.75882001076×10¹¹ C/kg.
  ///
  /// Important in electron optics and mass spectrometry.
  static const double electronChargeToMassRatio = 175882001076; // C/kg

  /// Proton charge-to-mass ratio (e/mₚ).
  /// Value: 9.5788331560×10⁷ C/kg.
  static const double protonChargeToMassRatio = 9.5788331560e7; // C/kg

  /// Classical electron radius (rₑ).
  /// Value: 2.8179403262×10⁻¹⁵ m.
  ///
  /// Derived from fundamental constants: rₑ = e²/(4πε₀mₑc²).
  static const Length classicalElectronRadius = Length(2.8179403262e-15, LengthUnit.meter);

  /// Bohr radius (a₀).
  /// Value: 5.29177210903×10⁻¹¹ m.
  ///
  /// The most probable distance between the nucleus and the electron in a hydrogen atom.
  static const Length bohrRadius = Length(5.29177210903e-11, LengthUnit.meter);

  /// Compton wavelength of electron (λC).
  /// Value: 2.42631023867×10⁻¹² m.
  ///
  /// Quantum mechanical property of particles with mass.
  static const Length electronComptonWavelength = Length(2.42631023867e-12, LengthUnit.meter);

  // === ENERGY CONVERSIONS ===

  /// Electron volt (eV) as an [Energy] quantity.
  /// Value: 1.602176634×10⁻¹⁹ J.
  ///
  /// Represents the kinetic energy gained by an electron when accelerated through
  /// a potential difference of one volt.
  static const Energy electronVolt = Energy(1.602176634e-19, EnergyUnit.joule);

  /// Rydberg energy as an [Energy] quantity.
  /// Value: 2.1798723611035×10⁻¹⁸ J.
  ///
  /// The binding energy of the electron in a hydrogen atom in its ground state.
  static const Energy rydbergEnergy = Energy(2.1798723611035e-18, EnergyUnit.joule);

  /// Rest energy of an electron (mₑc²) as an [Energy] quantity.
  /// Value: 8.1871057769×10⁻¹⁴ J.
  ///
  /// Einstein's mass-energy equivalence for an electron at rest.
  static const Energy electronRestEnergy = Energy(8.1871057769e-14, EnergyUnit.joule);

  /// Rest energy of a proton (mₚc²) as an [Energy] quantity.
  /// Value: 1.50327759787×10⁻¹⁰ J.
  ///
  /// Einstein's mass-energy equivalence for a proton at rest.
  static const Energy protonRestEnergy = Energy(1.50327759787e-10, EnergyUnit.joule);

  // === QUANTUM CONSTANTS ===

  /// Stefan-Boltzmann constant (σ).
  /// Value: 5.670374419×10⁻⁸ W/(m²⋅K⁴).
  ///
  /// Relates the total energy radiated from a black body to its temperature.
  /// Note: This would ideally be a compound `Quantity` type.
  static const double stefanBoltzmannConstant = 5.670374419e-8; // W/(m²⋅K⁴)

  /// Wien displacement law constant (b).
  /// Value: 2.897771955×10⁻³ m⋅K.
  ///
  /// Relates the peak wavelength of black-body radiation to its temperature.
  /// Note: This would ideally be a `Length` × `Temperature` quantity.
  static const double wienDisplacementConstant = 2.897771955e-3; // m⋅K

  /// First radiation constant (c₁).
  /// Value: 3.741771852×10⁻¹⁶ W⋅m².
  ///
  /// Used in Planck's law for black-body radiation.
  /// Note: This would ideally be a `Power` × `Area` quantity.
  static const double firstRadiationConstant = 3.741771852e-16; // W⋅m²

  /// Second radiation constant (c₂).
  /// Value: 1.438776877×10⁻² m⋅K.
  ///
  /// Used in Planck's law for black-body radiation.
  /// Note: This would ideally be a `Length` × `Temperature` quantity.
  static const double secondRadiationConstant = 1.438776877e-2; // m⋅K

  // === CONVENIENCE METHODS ===

  /// Calculates the distance light travels in a given [Time].
  ///
  /// Usage: `final distance = PhysicalConstants.lightSpeedDistance(1.0.seconds);`
  /// Returns a [Length] quantity.
  static Length lightSpeedDistance(Time time) {
    return speedOfLight.distanceOver(time);
  }

  /// Calculates the energy equivalent of a [Mass] using E = mc².
  ///
  /// Returns the energy as an [Energy] quantity.
  /// Usage: `final energy = PhysicalConstants.massEnergyEquivalence(1.0.kg);`
  static Energy massEnergyEquivalence(Mass mass) {
    final massInKg = mass.getValue(MassUnit.kilogram);
    final speedOfLightMs = speedOfLight.inMetersPerSecond;
    return Energy(massInKg * speedOfLightMs * speedOfLightMs, EnergyUnit.joule);
  }

  /// Calculates the thermal energy of a system at a given [Temperature] using E = kT.
  ///
  /// Returns the energy as an [Energy] quantity.
  /// Usage: `final energy = PhysicalConstants.thermalEnergy(300.0.kelvin);`
  static Energy thermalEnergy(Temperature temperature) {
    final tempInKelvin = temperature.getValue(TemperatureUnit.kelvin);
    return Energy(boltzmannConstant * tempInKelvin, EnergyUnit.joule);
  }

  /// Calculates the gravitational force between two masses at a given distance.
  ///
  /// Returns the force as a [Force] quantity.
  /// Usage: `final force = PhysicalConstants.gravitationalForce(mass1, mass2, distance);`
  static Force gravitationalForce(Mass mass1, Mass mass2, Length distance) {
    final m1 = mass1.getValue(MassUnit.kilogram);
    final m2 = mass2.getValue(MassUnit.kilogram);
    final r = distance.getValue(LengthUnit.meter);
    return Force(gravitationalConstant * m1 * m2 / (r * r), ForceUnit.newton);
  }

  /// Calculates the energy of a photon from its wavelength using E = hc/λ.
  ///
  /// Returns the energy as an [Energy] quantity.
  /// Usage: `final energy = PhysicalConstants.photonEnergy(500.0.nm);`
  static Energy photonEnergy(Length wavelength) {
    final lambdaInMeters = wavelength.getValue(LengthUnit.meter);
    final speedOfLightMs = speedOfLight.inMetersPerSecond;
    return Energy(planckConstant * speedOfLightMs / lambdaInMeters, EnergyUnit.joule);
  }

  /// Calculates the de Broglie wavelength of a particle with a given [Mass]
  /// and velocity.
  ///
  /// Returns the wavelength as a [Length] quantity.
  /// Usage: `final wavelength = PhysicalConstants.deBroglieWavelength(electronMass, 1.0e6);`
  static Length deBroglieWavelength(Mass mass, double velocityMeterPerSecond) {
    final massInKg = mass.getValue(MassUnit.kilogram);
    final momentum = massInKg * velocityMeterPerSecond; // p = mv
    if (momentum == 0) {
      throw ArgumentError(
        'Cannot calculate de Broglie wavelength for a particle with zero momentum.',
      );
    }
    final wavelengthInMeters = planckConstant / momentum; // λ = h/p
    return Length(wavelengthInMeters, LengthUnit.meter);
  }
}

<!-- END FILE: [v0.12.0] lib/src/constants/physical_constants.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/core/quantity.dart -->
import 'package:intl/intl.dart';
import 'package:meta/meta.dart';

import 'unit.dart';

/// An abstract representation of a physical quantity, encapsulating a numerical
/// [value] and a specific [unit] of measurement.
///
/// This class serves as the foundation for all specific quantity types (e.g., `Length`,
/// `Pressure`, `Temperature`). It enforces a common interface for unit conversions,
/// comparisons, and string formatting.
///
/// ## Immutability
/// `Quantity` objects are immutable. Operations that might seem to modify a quantity,
/// such as unit conversion (`convertTo`) or arithmetic, always return a new `Quantity`
/// instance with the updated value or unit, leaving the original instance unchanged.
/// This promotes safer and more predictable code.
///
/// ## Type Parameter `T`
/// The type parameter `T` represents the specific `Unit` enum associated with this
/// quantity type. For example, a `Pressure` quantity would use `PressureUnit` for `T`,
/// so it would be declared as `class Pressure extends Quantity<PressureUnit>`.
///
/// ## Comparison
/// `Quantity` implements `Comparable<Quantity<T>>`, allowing quantities of the
/// same type (e.g., two `Length` objects) to be compared based on their physical
/// magnitude, even if their internal units differ. The `compareTo` method handles
/// necessary conversions for accurate comparison.
@immutable
abstract class Quantity<T extends Unit<T>> implements Comparable<Quantity<T>> {
  /// Creates a new `Quantity` with a given numerical [value] and its corresponding [unit].
  ///
  /// Subclasses will typically call this constructor via `super(value, unit)`.
  ///
  /// - [_value]: The numerical magnitude of the quantity.
  /// - [_unit]: The unit of measurement for the `_value`.
  const Quantity(this._value, this._unit);

  /// The internal numerical value of this quantity, represented as a [double].
  /// This value is always in the context of the original [_unit] it was created with.
  final double _value;

  /// The internal unit of measurement for this quantity's [_value].
  /// This is an instance of the specific `Unit` enum `T`.
  final T _unit;

  /// Returns the numerical value of this quantity in its original [unit].
  ///
  /// Example:
  /// ```dart
  /// final length = Length(10.5, LengthUnit.meter);
  /// print(length.value); // Output: 10.5
  /// ```
  double get value => _value;

  /// Returns the unit of measurement associated with this quantity's original [value].
  ///
  /// Example:
  /// ```dart
  /// final length = Length(10.5, LengthUnit.meter);
  /// print(length.unit); // Output: LengthUnit.meter
  /// ```
  T get unit => _unit;

  /// Converts this quantity's [value] to the specified [targetUnit] and
  /// returns the numerical result of this conversion.
  ///
  /// This method must be implemented by concrete subclasses.
  ///
  /// For most quantities (e.g., `Length`, `Pressure`), this involves a direct
  /// multiplication by a conversion factor:
  /// `convertedValue = this.value * this.unit.factorTo(targetUnit)`.
  ///
  /// For quantities with affine conversions (like `Temperature` with Celsius or
  /// Fahrenheit), subclasses must implement specific conversion formulas that
  /// account for offsets (e.g., `(value * 9/5) + 32` for Celsius to Fahrenheit).
  ///
  /// - [targetUnit]: The desired unit to which the current quantity's value
  ///   should be converted.
  ///
  /// Returns the numerical value of this quantity expressed in the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final lengthInMeters = Length(1.0, LengthUnit.kilometer);
  /// double meters = lengthInMeters.getValue(LengthUnit.meter); // meters will be 1000.0
  ///
  /// final tempInCelsius = Temperature(0.0, TemperatureUnit.celsius);
  /// double fahrenheit = tempInCelsius.getValue(TemperatureUnit.fahrenheit); // fahrenheit will be 32.0
  /// ```
  double getValue(T targetUnit);

  /// Creates a new `Quantity` instance of the same type, with its value
  /// converted to the specified [targetUnit].
  ///
  /// This method must be implemented by concrete subclasses.
  /// It should utilize `getValue(targetUnit)` to get the numerical value in the
  /// target unit and then construct a new instance of the concrete quantity type.
  ///
  /// This is useful for obtaining a new `Quantity` object in a different unit
  /// while preserving the type information and immutability.
  ///
  /// - [targetUnit]: The desired unit for the new `Quantity` instance.
  ///
  /// Returns a new `Quantity` instance representing the same physical magnitude
  /// as this instance, but expressed in the [targetUnit]. If `targetUnit` is
  /// the same as `this.unit`, this method might return `this` instance directly
  /// as an optimization, since `Quantity` objects are immutable.
  ///
  /// Example:
  /// ```dart
  /// final lengthInKm = Length(1.5, LengthUnit.kilometer);
  /// final lengthInMeters = lengthInKm.convertTo(LengthUnit.meter);
  /// // lengthInMeters is now Length(1500.0, LengthUnit.meter)
  ///
  /// final tempInC = Temperature(20.0, TemperatureUnit.celsius);
  /// final tempInF = tempInC.convertTo(TemperatureUnit.fahrenheit);
  /// // tempInF is now Temperature(68.0, TemperatureUnit.fahrenheit)
  /// ```
  Quantity<T> convertTo(T targetUnit);

  /// Compares this quantity to another [Quantity] of the same type (`T`).
  ///
  /// This method must be implemented by concrete subclasses.
  /// The comparison is based on the physical magnitude of the quantities.
  /// To achieve this, one quantity (or both) might need to be converted to a
  /// common unit before their numerical values are compared. A common strategy
  /// is to convert `this.value` to `other.unit` using `getValue(other.unit)`
  /// and then compare the result with `other.value`.
  ///
  /// Returns:
  /// - A negative integer if this quantity is less than [other].
  /// - Zero if this quantity is equal in magnitude to [other].
  /// - A positive integer if this quantity is greater than [other].
  ///
  /// This method is essential for sorting collections of `Quantity` objects.
  @override
  int compareTo(Quantity<T> other);

  /// Returns a string representation of this quantity, with options for
  /// formatting and unit conversion.
  ///
  /// By default, it formats as `"[value] [unit_symbol]"` (e.g., "10.5 m"),
  /// using the quantity's current value and unit symbol, separated by a
  /// non-breaking space. Number formatting defaults to Dart's `double.toString()`.
  ///
  /// ## Parameters:
  ///
  /// - [targetUnit]: (Optional) If provided, the quantity's value will be
  ///   converted to this unit *before* formatting. The displayed unit symbol
  ///   will also be that of [targetUnit].
  ///   Example: `1.km.toString(targetUnit: LengthUnit.meter)` might produce "1000.0 m".
  ///
  /// - [fractionDigits]: (Optional) If provided and [numberFormat] is `null`,
  ///   the numerical value will be formatted to this fixed number of decimal places.
  ///   If [locale] is also provided, formatting attempts to respect it for decimal
  ///   and grouping separators (using `NumberFormat.decimalPatternDigits`).
  ///   Otherwise, `double.toStringAsFixed()` is used (locale-agnostic, uses '.' as decimal separator).
  ///   Example: `1.2345.m.toString(fractionDigits: 2)` might produce "1.23 m".
  ///
  /// - [showUnitSymbol]: (Optional) Defaults to `true`. If `false`, only the
  ///   numerical value (potentially converted and formatted) is returned, without
  ///   the unit symbol and separator.
  ///   Example: `10.m.toString(showUnitSymbol: false)` produces "10.0".
  ///
  /// - [unitSymbolSeparator]: (Optional) The string used to separate the formatted
  ///   numerical value and the unit symbol. Defaults to a non-breaking space (`'\u00A0'`).
  ///   Example: `10.m.toString(unitSymbolSeparator: "-")` produces "10.0-m".
  ///
  /// - [locale]: (Optional) A BCP 47 language tag (e.g., 'en_US', 'de_DE').
  ///   If provided and [numberFormat] is `null`, this locale is used for number
  ///   formatting (via `package:intl`). This affects decimal separators, grouping
  ///   separators, etc. Requires the `intl` package to be available.
  ///   Example: `1234.56.m.toString(locale: 'de_DE', fractionDigits: 1)` might produce "1234,6 m".
  ///
  /// - [numberFormat]: (Optional) An explicit `intl.NumberFormat` instance.
  ///   If provided, this takes precedence over [fractionDigits] and [locale] for
  ///   number formatting, offering maximum control. Requires the `intl` package.
  ///   Example:
  ///   ```dart
  ///   final customFormat = NumberFormat("#,##0.000", "en_US");
  ///   print(1234.5.m.toString(numberFormat: customFormat)); // "1,234.500 m"
  ///   ```
  ///
  /// Returns a string representation of the quantity according to the specified options.
  @override
  String toString({
    T? targetUnit,
    int? fractionDigits,
    bool showUnitSymbol = true,
    String unitSymbolSeparator = '\u00A0', // Default: Non-breaking space
    String? locale,
    NumberFormat? numberFormat,
  }) {
    var valueToFormat = _value;
    var unitToDisplay = _unit;

    // Step 1: Convert to target unit if specified.
    // If a target unit is provided and it's different from the current unit,
    // get the value in the target unit for formatting.
    if (targetUnit != null && targetUnit != _unit) {
      valueToFormat = getValue(targetUnit);
      unitToDisplay = targetUnit;
    }

    // Step 2: Format the numerical value.
    String formattedValue;

    if (numberFormat != null) {
      // If an explicit NumberFormat is provided, use it directly. This offers the most control.
      formattedValue = numberFormat.format(valueToFormat);
    } else {
      // Otherwise, use fractionDigits and/or locale if provided.
      if (locale != null) {
        // A locale is specified.
        if (fractionDigits != null) {
          // Both locale and fractionDigits: Use NumberFormat.decimalPatternDigits
          // for locale-aware fixed fraction digits.
          final nf = NumberFormat.decimalPatternDigits(
            locale: locale,
            decimalDigits: fractionDigits,
          );
          formattedValue = nf.format(valueToFormat);
        } else {
          // Locale provided, but no specific fractionDigits: Use a default decimal pattern for the locale.
          final nf = NumberFormat.decimalPattern(locale);
          formattedValue = nf.format(valueToFormat);
        }
      } else {
        // No locale and no explicit NumberFormat. Use Dart's built-in formatting.
        if (fractionDigits != null) {
          // Only fractionDigits provided: Use Dart's toStringAsFixed.
          // This is NOT locale-aware (always uses '.' as decimal separator).
          formattedValue = valueToFormat.toStringAsFixed(fractionDigits);
        } else {
          // No formatting options: Default double to string conversion.
          formattedValue = valueToFormat.toString();
        }
      }
    }

    // Step 3: Construct the final string.
    if (showUnitSymbol) {
      // Append the unit symbol (from unitToDisplay, which is targetUnit if conversion occurred)
      // and the specified separator.
      return '$formattedValue$unitSymbolSeparator${unitToDisplay.symbol}';
    } else {
      // Return only the formatted numerical value.
      return formattedValue;
    }
  }

  /// Determines whether this [Quantity] is equal to another [Object].
  ///
  /// Two `Quantity` instances are considered equal if they are:
  /// 1. The same instance (identical).
  /// 2. Of the exact same runtime type (e.g., both `Length`, not one `Length` and one `Pressure`).
  /// 3. Have the same numerical [value].
  /// 4. Have the same [unit].
  ///
  /// This means `1.m` is NOT equal to `100.cm` according to `==`, because their
  /// units differ, even though their physical magnitudes are the same.
  /// For magnitude comparison, use `compareTo()` or convert to a common unit first.
  ///
  /// - [other]: The object to compare against.
  ///
  /// Returns `true` if the objects are equal based on the criteria above, `false` otherwise.
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Quantity<T> &&
        runtimeType ==
            other.runtimeType && // Ensures strict type equality (e.g., Length != Pressure)
        _value == other._value &&
        _unit == other._unit;
  }

  /// Checks if this quantity has the same physical magnitude as another.
  ///
  /// This method performs a unit-agnostic comparison. For example,
  /// `1.m.isEquivalentTo(100.cm)` will return `true`.
  ///
  /// Internally, this is equivalent to `this.compareTo(other) == 0` and relies on
  /// standard `double` equality. This means it can be sensitive to minute
  /// floating-point inaccuracies that may arise from arithmetic operations.
  ///
  /// For example, `(0.1.m + 0.2.m).isEquivalentTo(0.3.m)` might return `false`
  /// due to the nature of floating-point representation.
  ///
  /// Returns `true` if the physical magnitudes are exactly equal, `false` otherwise.
  bool isEquivalentTo(Quantity<T> other) => compareTo(other) == 0;

  /// Checks if this quantity's magnitude is greater than another's.
  bool operator >(Quantity<T> other) => compareTo(other) > 0;

  /// Checks if this quantity's magnitude is less than another's.
  bool operator <(Quantity<T> other) => compareTo(other) < 0;

  /// Checks if this quantity's magnitude is greater than or equal to another's.
  bool operator >=(Quantity<T> other) => compareTo(other) >= 0;

  /// Checks if this quantity's magnitude is less than or equal to another's.
  bool operator <=(Quantity<T> other) => compareTo(other) <= 0;

  /// Returns a hash code for this `Quantity` instance.
  ///
  /// The hash code is generated based on the [runtimeType], the numerical [_value],
  /// and the [_unit]. This is consistent with the `operator ==` implementation:
  /// if two `Quantity` objects are equal according to `==`, they will have the
  /// same hash code.
  @override
  int get hashCode => Object.hash(runtimeType, _value, _unit);
}

<!-- END FILE: [v0.12.0] lib/src/core/quantity.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/core/unit.dart -->
import 'package:meta/meta.dart';

/// A contract for all unit enums.
///
/// Each unit enum (e.g., `PressureUnit`, `LengthUnit`) must implement this
/// interface to provide a way to get a conversion factor to another unit
/// of the same type.
///
/// [T] is the specific unit enum type itself (e.g., `PressureUnit`).
abstract class Unit<T extends Unit<T>> {
  /// Returns the direct conversion factor to convert a value from this unit
  /// to the [targetUnit].
  ///
  /// The conversion is performed by multiplying the original value by this factor:
  /// `convertedValue = originalValue * this.factorTo(targetUnit);`
  @internal
  double factorTo(T targetUnit);

  /// A human-readable symbol or abbreviation for the unit.
  ///
  /// This should be a concise representation suitable for display.
  /// For example: "m" for Meter, "psi" for Pound per Square Inch, "°C" for Celsius.
  String get symbol;
}

<!-- END FILE: [v0.12.0] lib/src/core/unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/acceleration/acceleration.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import '../speed/speed.dart';
import '../speed/speed_extensions.dart';
import '../speed/speed_unit.dart';
import '../time/time.dart';
import '../time/time_extensions.dart';
import 'acceleration_unit.dart';

/// Represents a quantity of acceleration.
///
/// Acceleration is a derived quantity representing the rate of change of
/// velocity over time. The SI derived unit is Meter per Second Squared (m/s²).
@immutable
class Acceleration extends Quantity<AccelerationUnit> {
  /// Creates a new `Acceleration` with a given [value] and [unit].
  const Acceleration(super.value, super.unit);

  /// Creates an `Acceleration` instance from a change in `Speed` over a `Time` duration.
  ///
  /// This factory performs the dimensional calculation `Acceleration = ΔSpeed / Time`.
  /// It converts the inputs to their base SI units for correctness.
  /// Throws an [ArgumentError] if the `time` is zero.
  ///
  /// Example:
  /// ```dart
  /// final speedChange = 27.8.mps; // approx 100 km/h
  /// final duration = 5.s;
  /// final carAcceleration = Acceleration.from(speedChange, duration);
  /// print(carAcceleration.inMetersPerSecondSquared); // Output: 5.56
  /// ```
  factory Acceleration.from(Speed speed, Time time) {
    final mps = speed.inMps;
    final seconds = time.inSeconds;
    if (seconds == 0) {
      throw ArgumentError('Time cannot be zero when calculating acceleration.');
    }
    return Acceleration(mps / seconds, AccelerationUnit.meterPerSecondSquared);
  }

  /// Converts this acceleration's value to the specified [targetUnit].
  @override
  double getValue(AccelerationUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Acceleration] instance with the value converted to the [targetUnit].
  @override
  Acceleration convertTo(AccelerationUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Acceleration(newValue, targetUnit);
  }

  @override
  int compareTo(Quantity<AccelerationUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this acceleration to another.
  Acceleration operator +(Acceleration other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Acceleration(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another acceleration from this one.
  Acceleration operator -(Acceleration other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Acceleration(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this acceleration by a scalar.
  Acceleration operator *(double scalar) {
    return Acceleration(value * scalar, unit);
  }

  /// Divides this acceleration by a scalar.
  Acceleration operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Acceleration(value / scalar, unit);
  }

  // --- Dimensional Analysis ---

  /// Calculates the change in [Speed] over a given [Time] duration.
  ///
  /// This method performs the dimensional calculation `ΔSpeed = Acceleration × Time`.
  /// The calculation is performed in the base units (m/s² and s) to ensure
  /// correctness, and the result is returned as a `Speed` in m/s.
  ///
  /// Example:
  /// ```dart
  /// final gravity = 1.gravity; // 9.80665 m/s²
  /// final fallTime = 3.s;
  /// final finalSpeed = gravity.speedGainedOver(fallTime);
  /// print(finalSpeed.inMps); // Output: ~29.42
  /// ```
  Speed speedGainedOver(Time duration) {
    final valueInMpss = getValue(AccelerationUnit.meterPerSecondSquared);
    final timeInSeconds = duration.inSeconds;
    final resultingSpeedInMps = valueInMpss * timeInSeconds;
    return Speed(resultingSpeedInMps, SpeedUnit.meterPerSecond);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/acceleration/acceleration.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/acceleration/acceleration_extensions.dart -->
import 'acceleration.dart';
import 'acceleration_unit.dart';

/// Provides convenient access to [Acceleration] values in specific units.
extension AccelerationValueGetters on Acceleration {
  /// Returns the acceleration value in Meters per second squared (m/s²).
  double get inMetersPerSecondSquared => getValue(AccelerationUnit.meterPerSecondSquared);

  /// Returns the acceleration value in Standard Gravity (g).
  double get inStandardGravity => getValue(AccelerationUnit.standardGravity);

  /// Returns the acceleration value in Kilometers per hour per second.
  double get inKilometersPerHourPerSecond => getValue(AccelerationUnit.kilometerPerHourPerSecond);

  /// Returns the acceleration value in Miles per hour per second.
  double get inMilesPerHourPerSecond => getValue(AccelerationUnit.milePerHourPerSecond);

  /// Returns the acceleration value in Knots per second.
  double get inKnotsPerSecond => getValue(AccelerationUnit.knotPerSecond);

  /// Returns the acceleration value in Feet per second squared.
  double get inFeetPerSecondSquared => getValue(AccelerationUnit.footPerSecondSquared);

  /// Returns the acceleration value in Centimeters per second squared (cm/s²).
  double get inCentimetersPerSecondSquared => getValue(AccelerationUnit.centimeterPerSecondSquared);

  /// Returns an [Acceleration] object in Meters per second squared (m/s²).
  Acceleration get asMetersPerSecondSquared => convertTo(AccelerationUnit.meterPerSecondSquared);

  /// Returns an [Acceleration] object in Standard Gravity (g).
  Acceleration get asStandardGravity => convertTo(AccelerationUnit.standardGravity);

  /// Returns an [Acceleration] object in Kilometers per hour per second.
  Acceleration get asKilometersPerHourPerSecond =>
      convertTo(AccelerationUnit.kilometerPerHourPerSecond);

  /// Returns an [Acceleration] object in Miles per hour per second.
  Acceleration get asMilesPerHourPerSecond => convertTo(AccelerationUnit.milePerHourPerSecond);

  /// Returns an [Acceleration] object in Knots per second.
  Acceleration get asKnotsPerSecond => convertTo(AccelerationUnit.knotPerSecond);

  /// Returns an [Acceleration] object in Feet per second squared.
  Acceleration get asFeetPerSecondSquared => convertTo(AccelerationUnit.footPerSecondSquared);

  /// Returns an [Acceleration] object in Centimeters per second squared (cm/s²).
  Acceleration get asCentimetersPerSecondSquared =>
      convertTo(AccelerationUnit.centimeterPerSecondSquared);
}

/// Provides convenient factory methods for creating [Acceleration] instances from [num].
extension AccelerationCreation on num {
  /// Creates an [Acceleration] instance from this value in Meters per second squared (m/s²).
  Acceleration get mpsSquared => Acceleration(toDouble(), AccelerationUnit.meterPerSecondSquared);

  /// Creates an [Acceleration] instance from this value in Standard Gravity (g).
  /// Note: A trailing underscore is used to avoid conflict with the getter 'g' for grams in Mass.
  Acceleration get gravity => Acceleration(toDouble(), AccelerationUnit.standardGravity);

  /// Creates an [Acceleration] instance from this value in Kilometers per hour per second.
  Acceleration get kmhPerS => Acceleration(toDouble(), AccelerationUnit.kilometerPerHourPerSecond);

  /// Creates an [Acceleration] instance from this value in Miles per hour per second.
  Acceleration get mphPerS => Acceleration(toDouble(), AccelerationUnit.milePerHourPerSecond);

  /// Creates an [Acceleration] instance from this value in Knots per second.
  Acceleration get knotsPerS => Acceleration(toDouble(), AccelerationUnit.knotPerSecond);

  /// Creates an [Acceleration] instance from this value in Feet per second squared (ft/s²).
  Acceleration get fpsSquared => Acceleration(toDouble(), AccelerationUnit.footPerSecondSquared);

  /// Creates an [Acceleration] instance from this value in Centimeters per second squared (cm/s²).
  /// Also known as the Galileo (Gal).
  Acceleration get cmpss => Acceleration(toDouble(), AccelerationUnit.centimeterPerSecondSquared);

  /// Creates an [Acceleration] instance from this value in Galileos (Gal).
  /// Alias for `cmpss`.
  Acceleration get gal => Acceleration(toDouble(), AccelerationUnit.centimeterPerSecondSquared);
}

<!-- END FILE: [v0.12.0] lib/src/units/acceleration/acceleration_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/acceleration/acceleration_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various acceleration units relative to the
/// Meter per Second Squared (m/s²), which is the SI derived unit for acceleration.
///
/// These constants represent: `1 [Unit] = Z [Meters Per Second Squared]`.
class AccelerationFactors {
  /// Meters per second squared per Standard Gravity (g): 1 g = 9.80665 m/s² (exact by convention).
  /// This is the acceleration due to gravity at sea level at about 45° latitude.
  static const double mpssPerStandardGravity = 9.80665;

  /// Meters per second squared per Kilometer per hour per second:
  /// 1 (km/h)/s = (1000m / 3600s) / s = 1000/3600 m/s².
  static const double mpssPerKmhPerSec = 1000.0 / 3600.0;

  /// Meters per second squared per Mile per hour per second:
  /// 1 (mph)/s = (1609.344m / 3600s) / s.
  static const double mpssPerMphPerSec = 1609.344 / 3600.0;

  /// Meters per second squared per Knot per second:
  /// 1 (kn)/s = (1852m / 3600s) / s.
  static const double mpssPerKnotPerSec = 1852.0 / 3600.0;

  /// Meters per second squared per Foot per second squared:
  /// 1 ft/s² = 0.3048 m/s².
  static const double mpssPerFpsSquared = 0.3048;

  /// Meters per second squared per Centimeter per second squared (Galileo):
  /// 1 cm/s² = 0.01 m/s².
  static const double mpssPerCmpss = 0.01;
}

<!-- END FILE: [v0.12.0] lib/src/units/acceleration/acceleration_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/acceleration/acceleration_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'acceleration_factors.dart';

/// Represents units of acceleration.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each acceleration unit.
/// All conversion factors are pre-calculated in the constructor relative to
/// Meter per Second Squared (m/s²).
enum AccelerationUnit implements Unit<AccelerationUnit> {
  /// Meter per second squared (m/s²), the SI derived unit of acceleration.
  meterPerSecondSquared(1, 'm/s²'),

  /// Standard Gravity (g), a unit of acceleration equal to the conventional standard
  /// acceleration of an object in a vacuum near the surface of the Earth.
  standardGravity(AccelerationFactors.mpssPerStandardGravity, 'g'),

  /// Kilometer per hour per second ((km/h)/s), a unit often used to describe
  /// automotive performance (e.g., 0 to 100 km/h in x seconds).
  kilometerPerHourPerSecond(AccelerationFactors.mpssPerKmhPerSec, 'km/h/s'),

  /// Mile per hour per second ((mph)/s), another unit for automotive performance.
  milePerHourPerSecond(AccelerationFactors.mpssPerMphPerSec, 'mph/s'),

  /// Knot per second ((kn)/s), used in maritime and aviation contexts.
  knotPerSecond(AccelerationFactors.mpssPerKnotPerSec, 'kn/s'),

  /// Foot per second squared (ft/s²), an imperial/US customary unit.
  footPerSecondSquared(AccelerationFactors.mpssPerFpsSquared, 'ft/s²'),

  /// Centimeter per second squared (cm/s²), also known as the Galileo (Gal).
  /// The CGS unit of acceleration.
  centimeterPerSecondSquared(AccelerationFactors.mpssPerCmpss, 'cm/s²');

  /// Constant constructor for enum members.
  const AccelerationUnit(double toMpssFactor, this.symbol)
      : _toMpssFactor = toMpssFactor,
        _factorToMeterPerSecondSquared = toMpssFactor / 1.0,
        _factorToStandardGravity = toMpssFactor / AccelerationFactors.mpssPerStandardGravity,
        _factorToKilometerPerHourPerSecond = toMpssFactor / AccelerationFactors.mpssPerKmhPerSec,
        _factorToMilePerHourPerSecond = toMpssFactor / AccelerationFactors.mpssPerMphPerSec,
        _factorToKnotPerSecond = toMpssFactor / AccelerationFactors.mpssPerKnotPerSec,
        _factorToFootPerSecondSquared = toMpssFactor / AccelerationFactors.mpssPerFpsSquared,
        _factorToCentimeterPerSecondSquared = toMpssFactor / AccelerationFactors.mpssPerCmpss;

  // ignore: unused_field // Used to store the conversion factor to Meter per Second Squared (m/s²).
  final double _toMpssFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToMeterPerSecondSquared;
  final double _factorToStandardGravity;
  final double _factorToKilometerPerHourPerSecond;
  final double _factorToMilePerHourPerSecond;
  final double _factorToKnotPerSecond;
  final double _factorToFootPerSecondSquared;
  final double _factorToCentimeterPerSecondSquared;

  @override
  @internal
  double factorTo(AccelerationUnit targetUnit) {
    switch (targetUnit) {
      case AccelerationUnit.meterPerSecondSquared:
        return _factorToMeterPerSecondSquared;
      case AccelerationUnit.standardGravity:
        return _factorToStandardGravity;
      case AccelerationUnit.kilometerPerHourPerSecond:
        return _factorToKilometerPerHourPerSecond;
      case AccelerationUnit.milePerHourPerSecond:
        return _factorToMilePerHourPerSecond;
      case AccelerationUnit.knotPerSecond:
        return _factorToKnotPerSecond;
      case AccelerationUnit.footPerSecondSquared:
        return _factorToFootPerSecondSquared;
      case AccelerationUnit.centimeterPerSecondSquared:
        return _factorToCentimeterPerSecondSquared;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/acceleration/acceleration_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/angle/angle.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'angle_unit.dart';

/// Represents a quantity of a plane angle.
///
/// Although angle is a dimensionless quantity in the SI system, it is treated
/// as a distinct quantity type for type safety and clarity. This class provides a
/// way to handle angle values and conversions between different units like
/// degrees, radians, and revolutions.
@immutable
class Angle extends Quantity<AngleUnit> {
  /// Creates a new `Angle` quantity with the given numerical [value] and [unit].
  const Angle(super.value, super.unit);

  /// Converts this angle's value to the specified [targetUnit].
  @override
  double getValue(AngleUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Angle] instance with the value converted to the [targetUnit].
  @override
  Angle convertTo(AngleUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Angle(newValue, targetUnit);
  }

  /// Compares this [Angle] object to another [Quantity<AngleUnit>].
  @override
  int compareTo(Quantity<AngleUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this angle to another angle.
  Angle operator +(Angle other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Angle(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another angle from this angle.
  Angle operator -(Angle other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Angle(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this angle by a scalar value.
  Angle operator *(double scalar) {
    return Angle(value * scalar, unit);
  }

  /// Divides this angle by a scalar value.
  Angle operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Angle(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/angle/angle.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/angle/angle_extensions.dart -->
import 'angle.dart';
import 'angle_unit.dart';

/// Provides convenient access to [Angle] values in specific units.
extension AngleValueGetters on Angle {
  /// Returns the angle value in Radians (rad).
  double get inRadians => getValue(AngleUnit.radian);

  /// Returns the angle value in Degrees (°).
  double get inDegrees => getValue(AngleUnit.degree);

  /// Returns the angle value in Gradians (grad).
  double get inGradians => getValue(AngleUnit.gradian);

  /// Returns the angle value in Revolutions (rev).
  double get inRevolutions => getValue(AngleUnit.revolution);

  /// Returns the angle value in Arcminutes (').
  double get inArcminutes => getValue(AngleUnit.arcminute);

  /// Returns the angle value in Arcseconds (").
  double get inArcseconds => getValue(AngleUnit.arcsecond);

  /// Returns the angle value in Milliradians (mrad).
  double get inMilliradians => getValue(AngleUnit.milliradian);

  /// Returns an [Angle] object representing this angle in Radians (rad).
  Angle get asRadians => convertTo(AngleUnit.radian);

  /// Returns an [Angle] object representing this angle in Degrees (°).
  Angle get asDegrees => convertTo(AngleUnit.degree);

  /// Returns an [Angle] object representing this angle in Gradians (grad).
  Angle get asGradians => convertTo(AngleUnit.gradian);

  /// Returns an [Angle] object representing this angle in Revolutions (rev).
  Angle get asRevolutions => convertTo(AngleUnit.revolution);

  /// Returns an [Angle] object representing this angle in Arcminutes (').
  Angle get asArcminutes => convertTo(AngleUnit.arcminute);

  /// Returns an [Angle] object representing this angle in Arcseconds (").
  Angle get asArcseconds => convertTo(AngleUnit.arcsecond);

  /// Returns an [Angle] object representing this angle in Milliradians (mrad).
  Angle get asMilliradians => convertTo(AngleUnit.milliradian);
}

/// Provides convenient factory methods for creating [Angle] instances from [num].
extension AngleCreation on num {
  /// Creates an [Angle] instance from this numerical value in Radians (rad).
  Angle get radians => Angle(toDouble(), AngleUnit.radian);

  /// Creates an [Angle] instance from this numerical value in Degrees (°).
  Angle get degrees => Angle(toDouble(), AngleUnit.degree);

  /// Creates an [Angle] instance from this numerical value in Gradians (grad).
  Angle get gradians => Angle(toDouble(), AngleUnit.gradian);

  /// Creates an [Angle] instance from this numerical value in Gradians (grad).
  /// Alias for `gradians`.
  Angle get grad => Angle(toDouble(), AngleUnit.gradian);

  /// Creates an [Angle] instance from this numerical value in Revolutions (rev).
  Angle get revolutions => Angle(toDouble(), AngleUnit.revolution);

  /// Creates an [Angle] instance from this numerical value in Revolutions (rev).
  /// Alias for `revolutions`.
  Angle get rev => Angle(toDouble(), AngleUnit.revolution);

  /// Creates an [Angle] instance from this numerical value in Arcminutes (').
  Angle get arcminutes => Angle(toDouble(), AngleUnit.arcminute);

  /// Creates an [Angle] instance from this numerical value in Arcseconds (").
  Angle get arcseconds => Angle(toDouble(), AngleUnit.arcsecond);

  /// Creates an [Angle] instance from this numerical value in Milliradians (mrad).
  Angle get milliradians => Angle(toDouble(), AngleUnit.milliradian);

  /// Creates an [Angle] instance from this numerical value in Milliradians (mrad).
  /// Alias for `milliradians`.
  Angle get mrad => Angle(toDouble(), AngleUnit.milliradian);
}

<!-- END FILE: [v0.12.0] lib/src/units/angle/angle_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/angle/angle_factors.dart -->
import 'dart:math' as math;

/// Defines base conversion factors for various angle units relative to the
/// Radian (rad), which is the SI-derived unit for plane angle and the
/// standard for `dart:math`.
class AngleFactors {
  // --- Factors to convert FROM a unit TO Radians (the base unit) ---
  // Formula: 1 [Unit] = Z [Radians]

  /// Radians per Revolution. Base for other cyclic units.
  static const double radiansPerRevolution = 2 * math.pi;

  /// Radians per Degree.
  static const double radiansPerDegree = radiansPerRevolution / 360.0;

  /// Radians per Gradian.
  static const double radiansPerGradian = radiansPerRevolution / 400.0;

  /// Radians per Arcminute.
  static const double radiansPerArcminute = radiansPerDegree / 60.0;

  /// Radians per Arcsecond.
  static const double radiansPerArcsecond = radiansPerArcminute / 60.0;

  /// Radians per Milliradian.
  static const double radiansPerMilliradian = 0.001;

  // --- Factors to convert FROM Radians TO a unit ---
  // This avoids division of imprecise doubles in the const constructor.
  // Formula: 1 Radian = Z [Unit]

  /// Degrees per Radian.
  static const double degreesPerRadian = 180.0 / math.pi;

  /// Gradians per Radian.
  static const double gradiansPerRadian = 200.0 / math.pi;

  /// Revolutions per Radian.
  static const double revolutionsPerRadian = 1.0 / (2 * math.pi);

  /// Arcminutes per Radian.
  static const double arcminutesPerRadian = degreesPerRadian * 60.0;

  /// Arcseconds per Radian.
  static const double arcsecondsPerRadian = arcminutesPerRadian * 60.0;

  /// Milliradians per Radian.
  static const double milliradiansPerRadian = 1000;
}

<!-- END FILE: [v0.12.0] lib/src/units/angle/angle_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/angle/angle_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'angle_factors.dart';

/// Represents units for a plane angle.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each angle unit. All conversion factors are
/// pre-calculated in the constructor relative to Radian (rad).
enum AngleUnit implements Unit<AngleUnit> {
  /// Radian (rad), the SI-derived unit of angle. Used by `dart:math`.
  radian(1, 'rad'),

  /// Degree (°), the most common unit of angle. 360° in a full circle.
  degree(AngleFactors.radiansPerDegree, '°'),

  /// Gradian (grad/gon), a unit of angle where a right angle is 100 gradians.
  /// 400 grad in a full circle. Commonly used in surveying.
  gradian(AngleFactors.radiansPerGradian, 'grad'),

  /// Revolution (rev/turn), where 1 revolution is a full circle.
  revolution(AngleFactors.radiansPerRevolution, 'rev'),

  /// Arcminute ('), a unit of angle equal to 1/60 of a degree.
  /// Used in astronomy and navigation.
  arcminute(AngleFactors.radiansPerArcminute, "'"),

  /// Arcsecond ("), a unit of angle equal to 1/60 of an arcminute.
  /// Used for very precise angular measurements.
  arcsecond(AngleFactors.radiansPerArcsecond, '"'),

  /// Milliradian (mrad), equal to 0.001 radians.
  /// Used in optics and ballistics.
  milliradian(AngleFactors.radiansPerMilliradian, 'mrad');

  /// Constant constructor for enum members.
  ///
  /// [_toRadianFactor] is the factor to convert from this unit to the base unit (Radian).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `AngleUnit`.
  const AngleUnit(double toRadianFactor, this.symbol)
      : _toRadianFactor = toRadianFactor,
        _factorToRadian = toRadianFactor,
        _factorToDegree = toRadianFactor * AngleFactors.degreesPerRadian,
        _factorToGradian = toRadianFactor * AngleFactors.gradiansPerRadian,
        _factorToRevolution = toRadianFactor * AngleFactors.revolutionsPerRadian,
        _factorToArcminute = toRadianFactor * AngleFactors.arcminutesPerRadian,
        _factorToArcsecond = toRadianFactor * AngleFactors.arcsecondsPerRadian,
        _factorToMilliradian = toRadianFactor * AngleFactors.milliradiansPerRadian;

  // ignore: unused_field // The factor to convert from this unit to Radian.
  final double _toRadianFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToRadian;
  final double _factorToDegree;
  final double _factorToGradian;
  final double _factorToRevolution;
  final double _factorToArcminute;
  final double _factorToArcsecond;
  final double _factorToMilliradian;

  /// Returns the direct conversion factor to convert a value from this [AngleUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(AngleUnit targetUnit) {
    switch (targetUnit) {
      case AngleUnit.radian:
        return _factorToRadian;
      case AngleUnit.degree:
        return _factorToDegree;
      case AngleUnit.gradian:
        return _factorToGradian;
      case AngleUnit.revolution:
        return _factorToRevolution;
      case AngleUnit.arcminute:
        return _factorToArcminute;
      case AngleUnit.arcsecond:
        return _factorToArcsecond;
      case AngleUnit.milliradian:
        return _factorToMilliradian;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/angle/angle_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/angular_velocity/angular_velocity.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import '../angle/angle.dart';
import '../angle/angle_unit.dart';
import '../time/time.dart';
import '../time/time_extensions.dart';
import 'angular_velocity_unit.dart';

/// Represents a quantity of angular velocity (or rotational speed).
///
/// Angular velocity is a derived quantity representing the rate of change of
/// an angle over time. The SI unit is radians per second (rad/s).
@immutable
class AngularVelocity extends Quantity<AngularVelocityUnit> {
  /// Creates a new `AngularVelocity` with a given [value] and [unit].
  const AngularVelocity(super.value, super.unit);

  /// Converts this angular velocity's value to the specified [targetUnit].
  @override
  double getValue(AngularVelocityUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [AngularVelocity] instance with the value converted to the [targetUnit].
  @override
  AngularVelocity convertTo(AngularVelocityUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return AngularVelocity(newValue, targetUnit);
  }

  @override
  int compareTo(Quantity<AngularVelocityUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this angular velocity to another.
  AngularVelocity operator +(AngularVelocity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return AngularVelocity(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another angular velocity from this one.
  AngularVelocity operator -(AngularVelocity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return AngularVelocity(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this angular velocity by a scalar.
  AngularVelocity operator *(double scalar) {
    return AngularVelocity(value * scalar, unit);
  }

  /// Divides this angular velocity by a scalar.
  AngularVelocity operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return AngularVelocity(value / scalar, unit);
  }

  // --- Dimensional Analysis: Methode statt überladenem Operator ---

  /// Calculates the total [Angle] of rotation over a given [Time] duration.
  ///
  /// `Angle = Angular Velocity × Time`
  ///
  /// The calculation is performed in the base units (rad/s and s) to ensure
  /// correctness, and the result is returned as an [Angle] in radians.
  ///
  /// Example:
  /// ```dart
  /// final speed = 3000.rpm;
  /// final duration = 2.0.seconds;
  /// final totalAngle = speed.totalAngleOver(duration);
  /// print(totalAngle.inRevolutions); // Output: 100.0
  /// ```
  Angle totalAngleOver(Time time) {
    final valueInRadPerSec = getValue(AngularVelocityUnit.radianPerSecond);
    final timeInSeconds = time.inSeconds;
    final resultingAngleInRadians = valueInRadPerSec * timeInSeconds;
    return Angle(resultingAngleInRadians, AngleUnit.radian);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/angular_velocity/angular_velocity.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/angular_velocity/angular_velocity_extensions.dart -->
import 'angular_velocity.dart';
import 'angular_velocity_unit.dart';

/// Provides convenient access to [AngularVelocity] values in specific units.
extension AngularVelocityValueGetters on AngularVelocity {
  /// Returns the value in Radians per second (rad/s).
  double get inRadiansPerSecond => getValue(AngularVelocityUnit.radianPerSecond);

  /// Returns the value in Degrees per second (°/s).
  double get inDegreesPerSecond => getValue(AngularVelocityUnit.degreePerSecond);

  /// Returns the value in Revolutions per minute (rpm).
  double get inRpm => getValue(AngularVelocityUnit.revolutionPerMinute);

  /// Returns the value in Revolutions per second (rps).
  double get inRps => getValue(AngularVelocityUnit.revolutionPerSecond);

  /// Returns an [AngularVelocity] object in Radians per second (rad/s).
  AngularVelocity get asRadiansPerSecond => convertTo(AngularVelocityUnit.radianPerSecond);

  /// Returns an [AngularVelocity] object in Degrees per second (°/s).
  AngularVelocity get asDegreesPerSecond => convertTo(AngularVelocityUnit.degreePerSecond);

  /// Returns an [AngularVelocity] object in Revolutions per minute (rpm).
  AngularVelocity get asRpm => convertTo(AngularVelocityUnit.revolutionPerMinute);

  /// Returns an [AngularVelocity] object in Revolutions per second (rps).
  AngularVelocity get asRps => convertTo(AngularVelocityUnit.revolutionPerSecond);
}

/// Provides convenient factory methods for creating [AngularVelocity] instances from [num].
extension AngularVelocityCreation on num {
  /// Creates an [AngularVelocity] from this value in Radians per second (rad/s).
  AngularVelocity get radiansPerSecond =>
      AngularVelocity(toDouble(), AngularVelocityUnit.radianPerSecond);

  /// Creates an [AngularVelocity] from this value in Degrees per second (°/s).
  AngularVelocity get degreesPerSecond =>
      AngularVelocity(toDouble(), AngularVelocityUnit.degreePerSecond);

  /// Creates an [AngularVelocity] from this value in Revolutions per minute (rpm).
  AngularVelocity get rpm => AngularVelocity(toDouble(), AngularVelocityUnit.revolutionPerMinute);

  /// Creates an [AngularVelocity] from this value in Revolutions per second (rps).
  AngularVelocity get rps => AngularVelocity(toDouble(), AngularVelocityUnit.revolutionPerSecond);

  /// Alias for `rps`.
  AngularVelocity get revolutionsPerSecond =>
      AngularVelocity(toDouble(), AngularVelocityUnit.revolutionPerSecond);
}

<!-- END FILE: [v0.12.0] lib/src/units/angular_velocity/angular_velocity_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/angular_velocity/angular_velocity_factors.dart -->
import '../angle/angle_factors.dart';

/// Defines base conversion factors for various angular velocity units relative
/// to the Radian per Second (rad/s), which is the SI-derived unit.
///
/// These constants represent: `1 [Unit] = Z [Radians Per Second]`.
class AngularVelocityFactors {
  /// Radians per second per Degree per second: 1 °/s = (π/180) rad/s.
  static const double radPSecPerDegPSec = AngleFactors.radiansPerDegree;

  /// Radians per second per Revolution per minute (RPM): 1 rev/min = (2π/60) rad/s.
  static const double radPSecPerRevPMin = AngleFactors.radiansPerRevolution / 60.0;

  /// Radians per second per Revolution per second (RPS): 1 rev/s = 2π rad/s.
  static const double radPSecPerRevPSec = AngleFactors.radiansPerRevolution;
}

<!-- END FILE: [v0.12.0] lib/src/units/angular_velocity/angular_velocity_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/angular_velocity/angular_velocity_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'angular_velocity_factors.dart';

/// Represents units for angular velocity.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each angular velocity unit. All conversion factors
/// are pre-calculated in the constructor relative to Radian per Second (rad/s).
enum AngularVelocityUnit implements Unit<AngularVelocityUnit> {
  /// Radian per second (rad/s), the SI-derived unit of angular velocity.
  radianPerSecond(1, 'rad/s'),

  /// Degree per second (°/s).
  degreePerSecond(AngularVelocityFactors.radPSecPerDegPSec, '°/s'),

  /// Revolution per minute (rpm), a common unit for rotational speed.
  revolutionPerMinute(AngularVelocityFactors.radPSecPerRevPMin, 'rpm'),

  /// Revolution per second (rps).
  revolutionPerSecond(AngularVelocityFactors.radPSecPerRevPSec, 'rps');

  /// Constant constructor for enum members.
  const AngularVelocityUnit(double toBaseFactor, this.symbol)
      : _toRadPerSecFactor = toBaseFactor,
        _factorToRadianPerSecond = toBaseFactor / 1.0,
        _factorToDegreePerSecond = toBaseFactor / AngularVelocityFactors.radPSecPerDegPSec,
        _factorToRevolutionPerMinute = toBaseFactor / AngularVelocityFactors.radPSecPerRevPMin,
        _factorToRevolutionPerSecond = toBaseFactor / AngularVelocityFactors.radPSecPerRevPSec;

  // ignore: unused_field // The factor to convert from this unit to Radian per Second.
  final double _toRadPerSecFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToRadianPerSecond;
  final double _factorToDegreePerSecond;
  final double _factorToRevolutionPerMinute;
  final double _factorToRevolutionPerSecond;

  @override
  @internal
  double factorTo(AngularVelocityUnit targetUnit) {
    switch (targetUnit) {
      case AngularVelocityUnit.radianPerSecond:
        return _factorToRadianPerSecond;
      case AngularVelocityUnit.degreePerSecond:
        return _factorToDegreePerSecond;
      case AngularVelocityUnit.revolutionPerMinute:
        return _factorToRevolutionPerMinute;
      case AngularVelocityUnit.revolutionPerSecond:
        return _factorToRevolutionPerSecond;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/angular_velocity/angular_velocity_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/area/area.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'area_unit.dart';

/// Represents a quantity of area.
///
/// Area is a derived quantity representing the extent of a two-dimensional
/// surface or shape. The SI derived unit is the Square Meter (m²).
@immutable
class Area extends Quantity<AreaUnit> {
  /// Creates a new `Area` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final roomArea = Area(20.0, AreaUnit.squareMeter);
  /// final landArea = Area(2.5, AreaUnit.hectare);
  /// ```
  const Area(super.value, super.unit);

  /// Converts this area's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `AreaUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final areaInM2 = Area(1.0, AreaUnit.squareMeter);
  /// final valueInCm2 = areaInM2.getValue(AreaUnit.squareCentimeter); // 10000.0
  /// ```
  @override
  double getValue(AreaUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Area] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Area` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final areaInCm2 = Area(50000.0, AreaUnit.squareCentimeter);
  /// final areaInM2Obj = areaInCm2.convertTo(AreaUnit.squareMeter);
  /// // areaInM2Obj is Area(5.0, AreaUnit.squareMeter)
  /// print(areaInM2Obj); // Output: "5.0 m²" (depending on toString formatting)
  /// ```
  @override
  Area convertTo(AreaUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Area(newValue, targetUnit);
  }

  /// Compares this [Area] object to another [Quantity<AreaUnit>].
  ///
  /// Comparison is based on the physical magnitude of the areas.
  /// For an accurate comparison, this area's value is converted to the unit
  /// of the [other] area before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this area is less than [other].
  /// - Zero if this area is equal in magnitude to [other].
  /// - A positive integer if this area is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final a1 = Area(1.0, AreaUnit.squareMeter);      // 10000 cm²
  /// final a2 = Area(10000.0, AreaUnit.squareCentimeter); // 10000 cm²
  /// final a3 = Area(0.5, AreaUnit.squareMeter);     // 5000 cm²
  ///
  /// print(a1.compareTo(a2)); // 0 (equal magnitude)
  /// print(a1.compareTo(a3)); // 1 (a1 > a3)
  /// print(a3.compareTo(a1)); // -1 (a3 < a1)
  /// ```
  @override
  int compareTo(Quantity<AreaUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this area to another area.
  ///
  /// The [other] area is converted to the unit of this area before addition.
  /// The result is a new [Area] instance with the sum, expressed in the unit of this area.
  ///
  /// Example:
  /// ```dart
  /// final room1 = Area(10.0, AreaUnit.squareMeter);
  /// final room2 = Area(50000.0, AreaUnit.squareCentimeter); // 5 m²
  /// final totalArea = room1 + room2; // Result: Area(15.0, AreaUnit.squareMeter)
  /// ```
  Area operator +(Area other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Area(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another area from this area.
  ///
  /// The [other] area is converted to the unit of this area before subtraction.
  /// The result is a new [Area] instance with the difference, expressed in the unit of this area.
  ///
  /// Example:
  /// ```dart
  /// final totalPlot = Area(1.0, AreaUnit.acre);
  /// final builtArea = Area(500.0, AreaUnit.squareMeter);
  /// final remainingArea = totalPlot - builtArea; // Result: Area(~3546.86, AreaUnit.squareMeter)
  /// ```
  Area operator -(Area other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Area(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this area by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Area] instance with the scaled value, in the original unit of this area.
  ///
  /// Example:
  /// ```dart
  /// final singleTileArea = Area(0.25, AreaUnit.squareMeter);
  /// final areaOf100Tiles = singleTileArea * 100.0; // Result: Area(25.0, AreaUnit.squareMeter)
  /// ```
  Area operator *(double scalar) {
    return Area(value * scalar, unit);
  }

  /// Divides this area by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Area] instance with the scaled value, in the original unit of this area.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalFabric = Area(10.0, AreaUnit.squareMeter);
  /// final fabricPerGarment = totalFabric / 5.0; // Result: Area(2.0, AreaUnit.squareMeter)
  /// ```
  Area operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Area(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/area/area.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/area/area_extensions.dart -->
import 'area.dart';
import 'area_unit.dart';

/// Provides convenient access to [Area] values in specific units
/// using getter properties.
extension AreaValueGetters on Area {
  /// Returns the area value in Square Meters (m²).
  double get inSquareMeters => getValue(AreaUnit.squareMeter);

  /// Returns the area value in Square Decimeters (dm²).
  double get inSquareDecimeters => getValue(AreaUnit.squareDecimeter);

  /// Returns the area value in Square Centimeters (cm²).
  double get inSquareCentimeters => getValue(AreaUnit.squareCentimeter);

  /// Returns the area value in Square Millimeters (mm²).
  double get inSquareMillimeters => getValue(AreaUnit.squareMillimeter);

  /// Returns the area value in Square Micrometers (µm²).
  double get inSquareMicrometers => getValue(AreaUnit.squareMicrometer);

  /// Returns the area value in Square Decameters (dam²).
  double get inSquareDecameters => getValue(AreaUnit.squareDecameter);

  /// Returns the area value in Square Hectometers (hm²).
  double get inSquareHectometers => getValue(AreaUnit.squareHectometer);

  /// Returns the area value in Hectares (ha).
  double get inHectares => getValue(AreaUnit.hectare);

  /// Returns the area value in Square Kilometers (km²).
  double get inSquareKilometers => getValue(AreaUnit.squareKilometer);

  /// Returns the area value in Square Megameters (Mm²).
  double get inSquareMegameters => getValue(AreaUnit.squareMegameter);

  /// Returns the area value in Square Inches (in²).
  double get inSquareInches => getValue(AreaUnit.squareInch);

  /// Returns the area value in Square Feet (ft²).
  double get inSquareFeet => getValue(AreaUnit.squareFoot);

  /// Returns the area value in Square Yards (yd²).
  double get inSquareYards => getValue(AreaUnit.squareYard);

  /// Returns the area value in Square Miles (mi²).
  double get inSquareMiles => getValue(AreaUnit.squareMile);

  /// Returns the area value in Acres (ac).
  double get inAcres => getValue(AreaUnit.acre);

  /// Returns a new [Area] object representing this area in Square Meters (m²).
  Area get asSquareMeter => convertTo(AreaUnit.squareMeter);

  /// Returns a new [Area] object representing this area in Square Decimeters (dm²).
  Area get asSquareDecimeter => convertTo(AreaUnit.squareDecimeter);

  /// Returns a new [Area] object representing this area in Square Centimeters (cm²).
  Area get asSquareCentimeter => convertTo(AreaUnit.squareCentimeter);

  /// Returns a new [Area] object representing this area in Square Millimeters (mm²).
  Area get asSquareMillimeter => convertTo(AreaUnit.squareMillimeter);

  /// Returns a new [Area] object representing this area in Square Micrometers (µm²).
  Area get asSquareMicrometer => convertTo(AreaUnit.squareMicrometer);

  /// Returns a new [Area] object representing this area in Square Decameters (dam²).
  Area get asSquareDecameter => convertTo(AreaUnit.squareDecameter);

  /// Returns a new [Area] object representing this area in Square Hectometers (hm²).
  Area get asSquareHectometer => convertTo(AreaUnit.squareHectometer);

  /// Returns a new [Area] object representing this area in Hectares (ha).
  Area get asHectare => convertTo(AreaUnit.hectare);

  /// Returns a new [Area] object representing this area in Square Kilometers (km²).
  Area get asSquareKilometer => convertTo(AreaUnit.squareKilometer);

  /// Returns a new [Area] object representing this area in Square Megameters (Mm²).
  Area get asSquareMegameter => convertTo(AreaUnit.squareMegameter);

  /// Returns a new [Area] object representing this area in Square Inches (in²).
  Area get asSquareInch => convertTo(AreaUnit.squareInch);

  /// Returns a new [Area] object representing this area in Square Feet (ft²).
  Area get asSquareFoot => convertTo(AreaUnit.squareFoot);

  /// Returns a new [Area] object representing this area in Square Yards (yd²).
  Area get asSquareYard => convertTo(AreaUnit.squareYard);

  /// Returns a new [Area] object representing this area in Square Miles (mi²).
  Area get asSquareMile => convertTo(AreaUnit.squareMile);

  /// Returns a new [Area] object representing this area in Acres (ac).
  Area get asAcre => convertTo(AreaUnit.acre);
}

/// Provides convenient factory methods for creating [Area] instances from [num]
/// using getter properties named after common unit symbols or names.
///
/// This allows for an intuitive and concise way to create area quantities,
/// for example: `10.m2` or `5.ha`.
extension AreaCreation on num {
  /// Creates an [Area] instance representing this numerical value in Square Meters (m²).
  Area get m2 => Area(toDouble(), AreaUnit.squareMeter);

  /// Creates an [Area] instance representing this numerical value in Square Decimeters (dm²).
  Area get dm2 => Area(toDouble(), AreaUnit.squareDecimeter);

  /// Creates an [Area] instance representing this numerical value in Square Centimeters (cm²).
  Area get cm2 => Area(toDouble(), AreaUnit.squareCentimeter);

  /// Creates an [Area] instance representing this numerical value in Square Millimeters (mm²).
  Area get mm2 => Area(toDouble(), AreaUnit.squareMillimeter);

  /// Creates an [Area] instance representing this numerical value in Square Micrometers (µm²).
  Area get um2 => Area(toDouble(), AreaUnit.squareMicrometer);

  /// Creates an [Area] instance representing this numerical value in Square Decameters (dam²).
  Area get dam2 => Area(toDouble(), AreaUnit.squareDecameter);

  /// Creates an [Area] instance representing this numerical value in Square Hectometers (hm²).
  Area get hm2 => Area(toDouble(), AreaUnit.squareHectometer);

  /// Creates an [Area] instance representing this numerical value in Hectares (ha).
  Area get ha => Area(toDouble(), AreaUnit.hectare);

  /// Creates an [Area] instance representing this numerical value in Square Kilometers (km²).
  Area get km2 => Area(toDouble(), AreaUnit.squareKilometer);

  /// Creates an [Area] instance representing this numerical value in Square Megameters (Mm²).
  /// Alias for `squareMegameter`.
  Area get squareMegameter => Area(toDouble(), AreaUnit.squareMegameter);

  /// Creates an [Area] instance representing this numerical value in Square Inches (in²).
  Area get in2 => Area(toDouble(), AreaUnit.squareInch);

  /// Creates an [Area] instance representing this numerical value in Square Feet (ft²).
  Area get ft2 => Area(toDouble(), AreaUnit.squareFoot);

  /// Creates an [Area] instance representing this numerical value in Square Yards (yd²).
  Area get yd2 => Area(toDouble(), AreaUnit.squareYard);

  /// Creates an [Area] instance representing this numerical value in Square Miles (mi²).
  Area get mi2 => Area(toDouble(), AreaUnit.squareMile);

  /// Creates an [Area] instance representing this numerical value in Acres (ac).
  Area get ac => Area(toDouble(), AreaUnit.acre);
}

<!-- END FILE: [v0.12.0] lib/src/units/area/area_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/area/area_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various area units relative to the
/// Square Meter (m²), which is the SI derived unit for area.
///
/// These constants represent: `1 [Unit] = Z [Square Meters]`.
class AreaFactors {
  /// Square Meters per Square Meter: 1 m² = 1.0 m².
  static const double m2 = 1.0;

  /// Square Meters per Square Decimetre: 1 dm² = 0.01 m².
  static const double dm2 = 0.01;

  /// Square Meters per Square Centimetre: 1 cm² = 0.0001 m².
  static const double cm2 = 0.0001;

  /// Square Meters per Square Millimetre: 1 mm² = 0.000001 m².
  static const double mm2 = 0.000001;

  /// Square Meters per Square Micrometre: 1 µm² = 1e-12 m².
  static const double um2 = 0.000000000001;

  /// Square Meters per Square Decametre: 1 dam² = 100.0 m².
  static const double dam2 = 100.0;

  /// Square Meters per Square Hectometre: 1 hm² = 10000.0 m².
  static const double hm2 = 10000.0;

  /// Square Meters per Square Kilometre: 1 km² = 1000000.0 m².
  static const double km2 = 1000000.0;

  /// Square Meters per Square Megameter: 1 Mm² = 1e12 m².
  static const double squareMegameter = 1000000000000.0;

  /// Square Meters per Square Inch: 1 in² = 0.00064516 m².
  static const double in2 = 0.00064516;

  /// Square Meters per Square Foot: 1 ft² = 0.09290304 m².
  static const double ft2 = 0.09290304;

  /// Square Meters per Square Yard: 1 yd² = 0.83612736 m² (from 0.9144²).
  static const double yd2 = 0.83612736;

  /// Square Meters per Square Mile: 1 mi² = 2589988.110336 m².
  static const double mi2 = 2589988.110336;

  /// Square Meters per Acre: 1 ac = 4046.8564224 m².
  static const double ac = 4046.8564224;
}

<!-- END FILE: [v0.12.0] lib/src/units/area/area_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/area/area_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'area_factors.dart';

/// Represents units of area.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each area unit.
/// All conversion factors are pre-calculated in the constructor relative to
/// Square Meter (m²).
enum AreaUnit implements Unit<AreaUnit> {
  /// Square Meter (m²), the SI derived unit of area.
  squareMeter(1, 'm²'),

  /// Square Decimeter (dm²).
  squareDecimeter(AreaFactors.dm2, 'dm²'),

  /// Square Centimeter (cm²).
  squareCentimeter(AreaFactors.cm2, 'cm²'),

  /// Square Millimeter (mm²).
  squareMillimeter(AreaFactors.mm2, 'mm²'),

  /// Square Micrometer (µm²).
  squareMicrometer(AreaFactors.um2, 'µm²'),

  /// Square Decameter (dam²).
  squareDecameter(AreaFactors.dam2, 'dam²'),

  /// Square Hectometer (hm²).
  squareHectometer(AreaFactors.hm2, 'hm²'),

  /// Hectare (ha), a common unit for land area, equal to 10,000 m².
  hectare(AreaFactors.hm2, 'ha'),

  /// Square Kilometer (km²).
  squareKilometer(AreaFactors.km2, 'km²'),

  /// Square Megameter (Mm²).
  squareMegameter(AreaFactors.squareMegameter, 'Mm²'),

  /// Square Inch (in²).
  squareInch(AreaFactors.in2, 'in²'),

  /// Square Foot (ft²).
  squareFoot(AreaFactors.ft2, 'ft²'),

  /// Square Yard (yd²).
  squareYard(AreaFactors.yd2, 'yd²'),

  /// Square Mile (mi²).
  squareMile(AreaFactors.mi2, 'mi²'),

  /// Acre (ac).
  acre(AreaFactors.ac, 'ac');

  /// Constant constructor for enum members.
  const AreaUnit(double toSquareMeterFactor, this.symbol)
      : _toSquareMeterFactor = toSquareMeterFactor,
        _factorToSquareMeter = toSquareMeterFactor / 1.0,
        _factorToSquareDecimeter = toSquareMeterFactor / AreaFactors.dm2,
        _factorToSquareCentimeter = toSquareMeterFactor / AreaFactors.cm2,
        _factorToSquareMillimeter = toSquareMeterFactor / AreaFactors.mm2,
        _factorToSquareMicrometer = toSquareMeterFactor / AreaFactors.um2,
        _factorToSquareDecameter = toSquareMeterFactor / AreaFactors.dam2,
        _factorToSquareHectometer = toSquareMeterFactor / AreaFactors.hm2,
        _factorToHectare = toSquareMeterFactor / AreaFactors.hm2,
        _factorToSquareKilometer = toSquareMeterFactor / AreaFactors.km2,
        _factorToSquareMegameter = toSquareMeterFactor / AreaFactors.squareMegameter,
        _factorToSquareInch = toSquareMeterFactor / AreaFactors.in2,
        _factorToSquareFoot = toSquareMeterFactor / AreaFactors.ft2,
        _factorToSquareYard = toSquareMeterFactor / AreaFactors.yd2,
        _factorToSquareMile = toSquareMeterFactor / AreaFactors.mi2,
        _factorToAcre = toSquareMeterFactor / AreaFactors.ac;

  // ignore: unused_field // The factor to convert this unit to Square Meter (m²).
  final double _toSquareMeterFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToSquareMeter;
  final double _factorToSquareDecimeter;
  final double _factorToSquareCentimeter;
  final double _factorToSquareMillimeter;
  final double _factorToSquareMicrometer;
  final double _factorToSquareDecameter;
  final double _factorToSquareHectometer;
  final double _factorToHectare;
  final double _factorToSquareKilometer;
  final double _factorToSquareMegameter;
  final double _factorToSquareInch;
  final double _factorToSquareFoot;
  final double _factorToSquareYard;
  final double _factorToSquareMile;
  final double _factorToAcre;

  @override
  @internal
  double factorTo(AreaUnit targetUnit) {
    switch (targetUnit) {
      case AreaUnit.squareMeter:
        return _factorToSquareMeter;
      case AreaUnit.squareDecimeter:
        return _factorToSquareDecimeter;
      case AreaUnit.squareCentimeter:
        return _factorToSquareCentimeter;
      case AreaUnit.squareMillimeter:
        return _factorToSquareMillimeter;
      case AreaUnit.squareMicrometer:
        return _factorToSquareMicrometer;
      case AreaUnit.squareDecameter:
        return _factorToSquareDecameter;
      case AreaUnit.squareHectometer:
        return _factorToSquareHectometer;
      case AreaUnit.hectare:
        return _factorToHectare;
      case AreaUnit.squareKilometer:
        return _factorToSquareKilometer;
      case AreaUnit.squareMegameter:
        return _factorToSquareMegameter;
      case AreaUnit.squareInch:
        return _factorToSquareInch;
      case AreaUnit.squareFoot:
        return _factorToSquareFoot;
      case AreaUnit.squareYard:
        return _factorToSquareYard;
      case AreaUnit.squareMile:
        return _factorToSquareMile;
      case AreaUnit.acre:
        return _factorToAcre;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/area/area_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/current/current.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'current_unit.dart';

/// Represents a quantity of electric current.
///
/// Electric current is the rate of flow of electric charge. The SI base unit
/// for electric current is the Ampere (A). It is a fundamental quantity in
/// electrical engineering and physics.
///
/// This class provides a type-safe way to handle electric current values and
/// conversions between different units (e.g., amperes, milliamperes, kiloamperes).
@immutable
class Current extends Quantity<CurrentUnit> {
  /// Creates a new `Current` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final circuitCurrent = Current(1.5, CurrentUnit.ampere);
  /// final sensorOutput = Current(20.0, CurrentUnit.milliampere);
  /// ```
  const Current(super.value, super.unit);

  /// Converts this electric current's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `CurrentUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final currentInAmperes = Current(0.05, CurrentUnit.ampere);
  /// final valueInMilliamperes = currentInAmperes.getValue(CurrentUnit.milliampere); // 50.0
  /// ```
  @override
  double getValue(CurrentUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Current] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Current` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final currentInMilliamperes = Current(2500.0, CurrentUnit.milliampere);
  /// final currentInAmperesObj = currentInMilliamperes.convertTo(CurrentUnit.ampere);
  /// // currentInAmperesObj is Current(2.5, CurrentUnit.ampere)
  /// print(currentInAmperesObj); // Output: "2.5 A" (depending on toString formatting)
  /// ```
  @override
  Current convertTo(CurrentUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Current(newValue, targetUnit);
  }

  /// Compares this [Current] object to another [Quantity<CurrentUnit>].
  ///
  /// Comparison is based on the physical magnitude of the electric currents.
  /// For an accurate comparison, this current's value is converted to the unit
  /// of the [other] current before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this current is less than [other].
  /// - Zero if this current is equal in magnitude to [other].
  /// - A positive integer if this current is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final c1 = Current(1.0, CurrentUnit.ampere);        // 1000 mA
  /// final c2 = Current(1000.0, CurrentUnit.milliampere); // 1000 mA
  /// final c3 = Current(0.5, CurrentUnit.ampere);       // 500 mA
  ///
  /// print(c1.compareTo(c2)); // 0 (equal magnitude)
  /// print(c1.compareTo(c3)); // 1 (c1 > c3)
  /// print(c3.compareTo(c1)); // -1 (c3 < c1)
  /// ```
  @override
  int compareTo(Quantity<CurrentUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this electric current to another electric current.
  ///
  /// The [other] current is converted to the unit of this current before addition.
  /// The result is a new [Current] instance with the sum, expressed in the unit of this current.
  /// This is physically meaningful in contexts like Kirchhoff's Current Law (junction rule).
  ///
  /// Example:
  /// ```dart
  /// final currentBranchA = Current(0.75, CurrentUnit.ampere);
  /// final currentBranchB = Current(250.0, CurrentUnit.milliampere); // 0.25 A
  /// final totalCurrent = currentBranchA + currentBranchB; // Result: Current(1.0, CurrentUnit.ampere)
  /// ```
  Current operator +(Current other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Current(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another electric current from this electric current.
  ///
  /// The [other] current is converted to the unit of this current before subtraction.
  /// The result is a new [Current] instance with the difference, expressed in the unit of this current.
  ///
  /// Example:
  /// ```dart
  /// final mainCurrent = Current(2.0, CurrentUnit.ampere);
  /// final currentToDevice = Current(800.0, CurrentUnit.milliampere); // 0.8 A
  /// final remainingCurrent = mainCurrent - currentToDevice; // Result: Current(1.2, CurrentUnit.ampere)
  /// ```
  Current operator -(Current other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Current(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this electric current by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Current] instance with the scaled value, in the original unit of this current.
  /// This might be used, for example, if a current is distributed equally among several paths.
  ///
  /// Example:
  /// ```dart
  /// final currentPerWire = Current(0.1, CurrentUnit.ampere);
  /// final totalCurrentFor5Wires = currentPerWire * 5.0; // Result: Current(0.5, CurrentUnit.ampere)
  /// ```
  Current operator *(double scalar) {
    return Current(value * scalar, unit);
  }

  /// Divides this electric current by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Current] instance with the scaled value, in the original unit of this current.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalCurrent = Current(1.0, CurrentUnit.ampere);
  /// final currentPerBranch = totalCurrent / 4.0; // Result: Current(0.25, CurrentUnit.ampere)
  /// ```
  Current operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Current(value / scalar, unit);
  }

  // Potential future enhancements for Current:
  // - Current * Time = ElectricCharge (would require ElectricCharge type)
  // - ElectricPotential / Current = Resistance (would require ElectricPotential and Resistance types)
  // - Power / Current = ElectricPotential (would require Power and ElectricPotential types)
}

<!-- END FILE: [v0.12.0] lib/src/units/current/current.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/current/current_extensions.dart -->
import 'current.dart';
import 'current_unit.dart';

/// Provides convenient access to [Current] values in specific units
/// using getter properties.
extension CurrentValueGetters on Current {
  /// Returns the electric current value in Amperes (A).
  double get inAmperes => getValue(CurrentUnit.ampere);

  /// Returns the electric current value in Milliamperes (mA).
  double get inMilliamperes => getValue(CurrentUnit.milliampere);

  /// Returns the electric current value in Microamperes (µA).
  double get inMicroamperes => getValue(CurrentUnit.microampere);

  /// Returns the electric current value in Nanoamperes (nA).
  double get inNanoamperes => getValue(CurrentUnit.nanoampere);

  /// Returns the electric current value in Kiloamperes (kA).
  double get inKiloamperes => getValue(CurrentUnit.kiloampere);

  /// Returns the electric current value in Statamperes (statA).
  double get inStatamperes => getValue(CurrentUnit.statampere);

  /// Returns the electric current value in Abamperes (abA) or Biot (Bi).
  double get inAbamperes => getValue(CurrentUnit.abampere);

  // --- "As" Getters for new Current objects ---

  /// Returns a new [Current] object representing this current in Amperes (A).
  Current get asAmperes => convertTo(CurrentUnit.ampere);

  /// Returns a new [Current] object representing this current in Milliamperes (mA).
  Current get asMilliamperes => convertTo(CurrentUnit.milliampere);

  /// Returns a new [Current] object representing this current in Microamperes (µA).
  Current get asMicroamperes => convertTo(CurrentUnit.microampere);

  /// Returns a new [Current] object representing this current in Nanoamperes (nA).
  Current get asNanoamperes => convertTo(CurrentUnit.nanoampere);

  /// Returns a new [Current] object representing this current in Kiloamperes (kA).
  Current get asKiloamperes => convertTo(CurrentUnit.kiloampere);

  /// Returns a new [Current] object representing this current in Statamperes (statA).
  Current get asStatamperes => convertTo(CurrentUnit.statampere);

  /// Returns a new [Current] object representing this current in Abamperes (abA) or Biot (Bi).
  Current get asAbamperes => convertTo(CurrentUnit.abampere);
}

/// Provides convenient factory methods for creating [Current] instances from [num]
/// using getter properties named after common unit symbols or names.
extension CurrentCreation on num {
  /// Creates a [Current] instance representing this numerical value in Amperes (A).
  Current get A => Current(toDouble(), CurrentUnit.ampere); // Using symbol 'A'

  /// Creates a [Current] instance representing this numerical value in Amperes (A).
  /// Alias for `A`.
  Current get amperes => Current(toDouble(), CurrentUnit.ampere);

  /// Creates a [Current] instance representing this numerical value in Milliamperes (mA).
  Current get mA => Current(toDouble(), CurrentUnit.milliampere);

  /// Creates a [Current] instance representing this numerical value in Milliamperes (mA).
  /// Alias for `mA`.
  Current get milliamperes => Current(toDouble(), CurrentUnit.milliampere);

  /// Creates a [Current] instance representing this numerical value in Microamperes (µA).
  Current get uA => Current(toDouble(), CurrentUnit.microampere); // Using 'uA' for micro

  /// Creates a [Current] instance representing this numerical value in Microamperes (µA).
  /// Alias for `uA`.
  Current get microamperes => Current(toDouble(), CurrentUnit.microampere);

  /// Creates a [Current] instance representing this numerical value in Nanoamperes (nA).
  Current get nA => Current(toDouble(), CurrentUnit.nanoampere);

  /// Creates a [Current] instance representing this numerical value in Nanoamperes (nA).
  /// Alias for `nA`.
  Current get nanoamperes => Current(toDouble(), CurrentUnit.nanoampere);

  /// Creates a [Current] instance representing this numerical value in Kiloamperes (kA).
  Current get kA => Current(toDouble(), CurrentUnit.kiloampere);

  /// Creates a [Current] instance representing this numerical value in Kiloamperes (kA).
  /// Alias for `kA`.
  Current get kiloamperes => Current(toDouble(), CurrentUnit.kiloampere);

  /// Creates a [Current] instance from this numerical value in Statamperes (statA).
  Current get statA => Current(toDouble(), CurrentUnit.statampere);

  /// Creates a [Current] instance from this numerical value in Statamperes (statA).
  /// Alias for `statA`.
  Current get statamperes => Current(toDouble(), CurrentUnit.statampere);

  /// Creates a [Current] instance from this numerical value in Abamperes (abA).
  Current get abA => Current(toDouble(), CurrentUnit.abampere);

  /// Creates a [Current] instance from this numerical value in Abamperes (abA).
  /// Alias for `abA`, also known as Biot (Bi).
  Current get abamperes => Current(toDouble(), CurrentUnit.abampere);

  /// Creates a [Current] instance from this numerical value in Biot (Bi).
  /// This is an alias for Abampere (`abA`).
  Current get bi => Current(toDouble(), CurrentUnit.abampere);
}

<!-- END FILE: [v0.12.0] lib/src/units/current/current_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/current/current_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

/// Defines base conversion factors for various electric current units relative
/// to the Ampere (A), which is the SI base unit for electric current.
///
/// These constants represent: `1 [Unit] = Z [Amperes]`.
/// So, `amperesPerMilliampere` means `1 milliampere = amperesPerMilliampere amperes`.
class CurrentFactors {
  // --- SI Prefixed Units (relative to Ampere) ---

  /// Amperes per Milliampere: 1 milliampere (mA) = 0.001 amperes (A).
  static const double amperesPerMilliampere = 0.001;

  /// Amperes per Microampere: 1 microampere (µA) = 0.000001 amperes (A).
  static const double amperesPerMicroampere = 0.000001; // 1e-6

  /// Amperes per Nanoampere: 1 nanoampere (nA) = 1e-9 amperes (A).
  static const double amperesPerNanoampere = 1.0e-9;

  /// Amperes per Kiloampere: 1 kiloampere (kA) = 1000 amperes (A).
  static const double amperesPerKiloampere = 1000.0;

  /// Amperes per Statampere: 1 statampere (statA) ≈ 3.33564 × 10⁻¹⁰ Amperes.
  /// The statampere is the unit of current in the CGS electrostatic system.
  /// It is defined as 1 statcoulomb per second.
  static const double amperesPerStatampere = 3.3356409519815204e-10;

  /// Amperes per Abampere (or Biot): 1 abampere (abA) = 10 Amperes.
  /// The abampere is the unit of current in the CGS electromagnetic system.
  /// It is also known as the biot (Bi).
  static const double amperesPerAbampere = 10.0;
}

<!-- END FILE: [v0.12.0] lib/src/units/current/current_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/current/current_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'current_factors.dart';

/// Represents units for electric current.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each electric current unit.
/// All conversion factors are pre-calculated in the constructor relative to Ampere (A),
/// which is the SI base unit for electric current.
enum CurrentUnit implements Unit<CurrentUnit> {
  /// Ampere (A), the SI base unit of electric current.
  /// Defined by taking the fixed numerical value of the elementary charge *e* to be
  /// 1.602176634 × 10⁻¹⁹ when expressed in the unit C, which is equal to A s.
  ampere(1, 'A'),

  /// Milliampere (mA), equal to 0.001 amperes.
  milliampere(CurrentFactors.amperesPerMilliampere, 'mA'),

  /// Microampere (µA), equal to 1e-6 amperes.
  microampere(CurrentFactors.amperesPerMicroampere, 'µA'),

  /// Nanoampere (nA), equal to 1e-9 amperes.
  nanoampere(CurrentFactors.amperesPerNanoampere, 'nA'),

  /// Kiloampere (kA), equal to 1000 amperes.
  kiloampere(CurrentFactors.amperesPerKiloampere, 'kA'),

  /// Statampere (statA), the CGS electrostatic unit of current.
  statampere(CurrentFactors.amperesPerStatampere, 'statA'),

  /// Abampere (abA) or Biot (Bi), the CGS electromagnetic unit of current.
  abampere(CurrentFactors.amperesPerAbampere, 'abA');

  /// Constant constructor for enum members.
  ///
  /// [_toAmpereFactor] is the factor to convert from this unit to the base unit (Ampere).
  /// For Ampere itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `CurrentUnit`.
  const CurrentUnit(double toAmpereFactor, this.symbol)
      : _toAmpereFactor = toAmpereFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToAmpere = toAmpereFactor / 1.0, // Base unit factor for ampere is 1.0
        _factorToMilliampere = toAmpereFactor / CurrentFactors.amperesPerMilliampere,
        _factorToMicroampere = toAmpereFactor / CurrentFactors.amperesPerMicroampere,
        _factorToNanoampere = toAmpereFactor / CurrentFactors.amperesPerNanoampere,
        _factorToKiloampere = toAmpereFactor / CurrentFactors.amperesPerKiloampere,
        _factorToStatampere = toAmpereFactor / CurrentFactors.amperesPerStatampere,
        _factorToAbampere = toAmpereFactor / CurrentFactors.amperesPerAbampere;
  // If biot were added:
  // _factorToBiot = toAmpereFactor / CurrentFactors.amperesPerBiot;

  /// The factor to convert a value from this unit to the base unit (Ampere).
  /// Example: For Milliampere, this is 0.001 (meaning 1 mA = 0.001 A).
  /// This field is primarily used internally by the constructor.
  // ignore: unused_field
  final double _toAmpereFactor;

  /// The human-readable symbol for this electric current unit (e.g., "A", "mA").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToAmpere;
  final double _factorToMilliampere;
  final double _factorToMicroampere;
  final double _factorToNanoampere;
  final double _factorToKiloampere;
  final double _factorToStatampere;
  final double _factorToAbampere;

  /// Returns the direct conversion factor to convert a value from this [CurrentUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `Current`
  /// class for conversions.
  @override
  @internal
  double factorTo(CurrentUnit targetUnit) {
    switch (targetUnit) {
      case CurrentUnit.ampere:
        return _factorToAmpere;
      case CurrentUnit.milliampere:
        return _factorToMilliampere;
      case CurrentUnit.microampere:
        return _factorToMicroampere;
      case CurrentUnit.nanoampere:
        return _factorToNanoampere;
      case CurrentUnit.kiloampere:
        return _factorToKiloampere;
      case CurrentUnit.statampere:
        return _factorToStatampere;
      case CurrentUnit.abampere:
        return _factorToAbampere;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/current/current_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/electric_charge/electric_charge.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import '../current/current.dart';
import '../current/current_extensions.dart';
import '../current/current_unit.dart';
import '../time/time.dart';
import '../time/time_extensions.dart';
import '../time/time_unit.dart';
import 'electric_charge_unit.dart';

/// Represents a quantity of electric charge.
///
/// Electric charge is a fundamental property of matter that causes it to experience
/// a force in an electromagnetic field. The SI derived unit is the Coulomb (C),
/// defined as the charge transported by a constant current of one ampere in one second.
@immutable
class ElectricCharge extends Quantity<ElectricChargeUnit> {
  /// Creates a new `ElectricCharge` with a given [value] and [unit].
  const ElectricCharge(super.value, super.unit);

  // --- Dimensional Analysis ---

  /// Creates an `ElectricCharge` from a `Current` flowing over a `Time` duration (Q = I * t).
  ///
  /// Example:
  /// ```dart
  /// final current = 2.A;
  /// final time = 1.h;
  /// final charge = ElectricCharge.from(current, time);
  /// print(charge.inAmpereHours); // Output: 2.0
  /// print(charge.inCoulombs); // Output: 7200.0
  /// ```
  factory ElectricCharge.from(Current current, Time time) {
    final amperes = current.inAmperes;
    final seconds = time.inSeconds;
    return ElectricCharge(amperes * seconds, ElectricChargeUnit.coulomb);
  }

  /// Calculates the `Current` if this charge flows over a given `Time` (I = Q / t).
  ///
  /// Throws an [ArgumentError] if the `time` is zero.
  Current currentOver(Time time) {
    final coulombs = getValue(ElectricChargeUnit.coulomb);
    final seconds = time.inSeconds;
    if (seconds == 0) {
      throw ArgumentError('Time cannot be zero when calculating current from charge.');
    }
    return Current(coulombs / seconds, CurrentUnit.ampere);
  }

  /// Calculates the `Time` it takes for this charge to flow at a given `Current` (t = Q / I).
  ///
  /// Throws an [ArgumentError] if the `current` is zero.
  Time timeFor(Current current) {
    final coulombs = getValue(ElectricChargeUnit.coulomb);
    final amperes = current.inAmperes;
    if (amperes == 0) {
      throw ArgumentError('Current cannot be zero when calculating time from charge.');
    }
    return Time(coulombs / amperes, TimeUnit.second);
  }

  // --- Boilerplate ---

  /// Converts this electric charge's value to the specified [targetUnit].
  @override
  double getValue(ElectricChargeUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [ElectricCharge] instance with the value converted to the [targetUnit].
  @override
  ElectricCharge convertTo(ElectricChargeUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return ElectricCharge(newValue, targetUnit);
  }

  @override
  int compareTo(Quantity<ElectricChargeUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this electric charge to another.
  ElectricCharge operator +(ElectricCharge other) {
    final otherValueInThisUnit = other.getValue(unit);
    return ElectricCharge(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another electric charge from this one.
  ElectricCharge operator -(ElectricCharge other) {
    final otherValueInThisUnit = other.getValue(unit);
    return ElectricCharge(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this electric charge by a scalar.
  ElectricCharge operator *(double scalar) {
    return ElectricCharge(value * scalar, unit);
  }

  /// Divides this electric charge by a scalar.
  ElectricCharge operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return ElectricCharge(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/electric_charge/electric_charge.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/electric_charge/electric_charge_extensions.dart -->
import 'electric_charge.dart';
import 'electric_charge_unit.dart';

/// Provides convenient access to [ElectricCharge] values in specific units.
extension ElectricChargeValueGetters on ElectricCharge {
  /// Returns the electric charge value in Coulombs (C).
  double get inCoulombs => getValue(ElectricChargeUnit.coulomb);

  /// Returns the electric charge value in Millicoulombs (mC).
  double get inMillicoulombs => getValue(ElectricChargeUnit.millicoulomb);

  /// Returns the electric charge value in Microcoulombs (µC).
  double get inMicrocoulombs => getValue(ElectricChargeUnit.microcoulomb);

  /// Returns the electric charge value in Nanocoulombs (nC).
  double get inNanocoulombs => getValue(ElectricChargeUnit.nanocoulomb);

  /// Returns the electric charge value in Elementary Charges (e).
  double get inElementaryCharges => getValue(ElectricChargeUnit.elementaryCharge);

  /// Returns the electric charge value in Ampere-hours (Ah).
  double get inAmpereHours => getValue(ElectricChargeUnit.ampereHour);

  /// Returns the electric charge value in Milliampere-hours (mAh).
  double get inMilliampereHours => getValue(ElectricChargeUnit.milliampereHour);

  /// Returns the electric charge value in Statcoulombs (statC).
  double get inStatcoulombs => getValue(ElectricChargeUnit.statcoulomb);

  /// Returns the electric charge value in Abcoulombs (abC).
  double get inAbcoulombs => getValue(ElectricChargeUnit.abcoulomb);

  /// Returns a new [ElectricCharge] object representing this charge in Coulombs (C).
  ElectricCharge get asCoulombs => convertTo(ElectricChargeUnit.coulomb);

  /// Returns a new [ElectricCharge] object representing this charge in Millicoulombs (mC).
  ElectricCharge get asMillicoulombs => convertTo(ElectricChargeUnit.millicoulomb);

  /// Returns a new [ElectricCharge] object representing this charge in Microcoulombs (µC).
  ElectricCharge get asMicrocoulombs => convertTo(ElectricChargeUnit.microcoulomb);

  /// Returns a new [ElectricCharge] object representing this charge in Nanocoulombs (nC).
  ElectricCharge get asNanocoulombs => convertTo(ElectricChargeUnit.nanocoulomb);

  /// Returns a new [ElectricCharge] object representing this charge in Elementary Charges (e).
  ElectricCharge get asElementaryCharges => convertTo(ElectricChargeUnit.elementaryCharge);

  /// Returns a new [ElectricCharge] object representing this charge in Ampere-hours (Ah).
  ElectricCharge get asAmpereHours => convertTo(ElectricChargeUnit.ampereHour);

  /// Returns a new [ElectricCharge] object representing this charge in Milliampere-hours (mAh).
  ElectricCharge get asMilliampereHours => convertTo(ElectricChargeUnit.milliampereHour);

  /// Returns a new [ElectricCharge] object representing this charge in Statcoulombs (statC).
  ElectricCharge get asStatcoulombs => convertTo(ElectricChargeUnit.statcoulomb);

  /// Returns a new [ElectricCharge] object representing this charge in Abcoulombs (abC).
  ElectricCharge get asAbcoulombs => convertTo(ElectricChargeUnit.abcoulomb);
}

/// Provides convenient factory methods for creating [ElectricCharge] instances from [num].
extension ElectricChargeCreation on num {
  /// Creates an [ElectricCharge] instance from this value in Coulombs (C).
  ElectricCharge get C => ElectricCharge(toDouble(), ElectricChargeUnit.coulomb);

  /// Creates an [ElectricCharge] instance from this value in Coulombs (C).
  /// Alias for `C`.
  ElectricCharge get coulombs => ElectricCharge(toDouble(), ElectricChargeUnit.coulomb);

  /// Creates an [ElectricCharge] instance from this value in Millicoulombs (mC).
  ElectricCharge get mC => ElectricCharge(toDouble(), ElectricChargeUnit.millicoulomb);

  /// Creates an [ElectricCharge] instance from this value in Microcoulombs (µC).
  ElectricCharge get uC => ElectricCharge(toDouble(), ElectricChargeUnit.microcoulomb);

  /// Creates an [ElectricCharge] instance from this value in Nanocoulombs (nC).
  ElectricCharge get nC => ElectricCharge(toDouble(), ElectricChargeUnit.nanocoulomb);

  /// Creates an [ElectricCharge] instance from this value in Elementary Charges (e).
  /// Represents the number of elementary charges (e.g., protons or electrons).
  ElectricCharge get e => ElectricCharge(toDouble(), ElectricChargeUnit.elementaryCharge);

  /// Creates an [ElectricCharge] instance from this value in Ampere-hours (Ah).
  ElectricCharge get ah => ElectricCharge(toDouble(), ElectricChargeUnit.ampereHour);

  /// Creates an [ElectricCharge] instance from this value in Milliampere-hours (mAh).
  ElectricCharge get mAh => ElectricCharge(toDouble(), ElectricChargeUnit.milliampereHour);

  /// Creates an [ElectricCharge] instance from this value in Statcoulombs (statC).
  ElectricCharge get statC => ElectricCharge(toDouble(), ElectricChargeUnit.statcoulomb);

  /// Creates an [ElectricCharge] instance from this value in Franklin (Fr).
  /// Alias for `statC`.
  ElectricCharge get franklin => ElectricCharge(toDouble(), ElectricChargeUnit.statcoulomb);

  /// Creates an [ElectricCharge] instance from this value in Abcoulombs (abC).
  ElectricCharge get abC => ElectricCharge(toDouble(), ElectricChargeUnit.abcoulomb);
}

<!-- END FILE: [v0.12.0] lib/src/units/electric_charge/electric_charge_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/electric_charge/electric_charge_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various electric charge units relative to the
/// Coulomb (C), which is the SI derived unit for electric charge (A·s).
///
/// These constants represent: `1 [Unit] = Z [Coulombs]`.
class ElectricChargeFactors {
  // --- SI Prefixed Units (relative to Coulomb) ---

  /// Coulombs per Millicoulomb: 1 mC = 1e-3 C.
  static const double coulombsPerMillicoulomb = 1e-3;

  /// Coulombs per Microcoulomb: 1 µC = 1e-6 C.
  static const double coulombsPerMicrocoulomb = 1e-6;

  /// Coulombs per Nanocoulomb: 1 nC = 1e-9 C.
  static const double coulombsPerNanocoulomb = 1e-9;

  // --- Other Common Units ---

  /// Coulombs per Elementary Charge (e): The charge of a single proton.
  /// This is an exact value by the 2019 redefinition of the SI base units.
  static const double coulombsPerElementaryCharge = 1.602176634e-19;

  /// Coulombs per Ampere-Hour (Ah): Commonly used for battery capacity.
  /// 1 Ah = 1 A * 3600 s = 3600 C.
  static const double coulombsPerAmpereHour = 3600.0;

  /// Coulombs per Milliampere-Hour (mAh): 1 mAh = 0.001 Ah = 3.6 C.
  static const double coulombsPerMilliampereHour = 3.6;

  /// Coulombs per Statcoulomb (statC) or Franklin (Fr): The CGS-ESU unit of charge.
  /// 1 statC ≈ 3.33564 × 10⁻¹⁰ C.
  static const double coulombsPerStatcoulomb = 3.3356409519815204e-10;

  /// Coulombs per Abcoulomb (abC): The CGS-EMU unit of charge.
  /// 1 abC = 10 C.
  static const double coulombsPerAbcoulomb = 10.0;
}

<!-- END FILE: [v0.12.0] lib/src/units/electric_charge/electric_charge_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/electric_charge/electric_charge_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'electric_charge_factors.dart';

/// Represents units of electric charge.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each electric charge unit.
/// All conversion factors are pre-calculated in the constructor relative to
/// Coulomb (C).
enum ElectricChargeUnit implements Unit<ElectricChargeUnit> {
  /// Coulomb (C), the SI derived unit of electric charge.
  coulomb(1, 'C'),

  /// Millicoulomb (mC), a sub-multiple of the Coulomb.
  millicoulomb(ElectricChargeFactors.coulombsPerMillicoulomb, 'mC'),

  /// Microcoulomb (µC), a sub-multiple of the Coulomb.
  microcoulomb(ElectricChargeFactors.coulombsPerMicrocoulomb, 'µC'),

  /// Nanocoulomb (nC), a sub-multiple of the Coulomb.
  nanocoulomb(ElectricChargeFactors.coulombsPerNanocoulomb, 'nC'),

  /// Elementary Charge (e), the charge of a single proton.
  elementaryCharge(ElectricChargeFactors.coulombsPerElementaryCharge, 'e'),

  /// Ampere-hour (Ah), a unit commonly used for battery capacity.
  ampereHour(ElectricChargeFactors.coulombsPerAmpereHour, 'Ah'),

  /// Milliampere-hour (mAh), a smaller unit for battery capacity.
  milliampereHour(ElectricChargeFactors.coulombsPerMilliampereHour, 'mAh'),

  /// Statcoulomb (statC) or Franklin (Fr), the CGS-ESU unit of charge.
  statcoulomb(ElectricChargeFactors.coulombsPerStatcoulomb, 'statC'),

  /// Abcoulomb (abC), the CGS-EMU unit of charge.
  abcoulomb(ElectricChargeFactors.coulombsPerAbcoulomb, 'abC');

  /// Constant constructor for enum members.
  const ElectricChargeUnit(double toCoulombFactor, this.symbol)
      : _toCoulombFactor = toCoulombFactor,
        _factorToCoulomb = toCoulombFactor / 1.0,
        _factorToMillicoulomb = toCoulombFactor / ElectricChargeFactors.coulombsPerMillicoulomb,
        _factorToMicrocoulomb = toCoulombFactor / ElectricChargeFactors.coulombsPerMicrocoulomb,
        _factorToNanocoulomb = toCoulombFactor / ElectricChargeFactors.coulombsPerNanocoulomb,
        _factorToElementaryCharge =
            toCoulombFactor / ElectricChargeFactors.coulombsPerElementaryCharge,
        _factorToAmpereHour = toCoulombFactor / ElectricChargeFactors.coulombsPerAmpereHour,
        _factorToMilliampereHour =
            toCoulombFactor / ElectricChargeFactors.coulombsPerMilliampereHour,
        _factorToStatcoulomb = toCoulombFactor / ElectricChargeFactors.coulombsPerStatcoulomb,
        _factorToAbcoulomb = toCoulombFactor / ElectricChargeFactors.coulombsPerAbcoulomb;

  // ignore: unused_field // The factor to convert this unit to Coulomb (C).
  final double _toCoulombFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToCoulomb;
  final double _factorToMillicoulomb;
  final double _factorToMicrocoulomb;
  final double _factorToNanocoulomb;
  final double _factorToElementaryCharge;
  final double _factorToAmpereHour;
  final double _factorToMilliampereHour;
  final double _factorToStatcoulomb;
  final double _factorToAbcoulomb;

  @override
  @internal
  double factorTo(ElectricChargeUnit targetUnit) {
    switch (targetUnit) {
      case ElectricChargeUnit.coulomb:
        return _factorToCoulomb;
      case ElectricChargeUnit.millicoulomb:
        return _factorToMillicoulomb;
      case ElectricChargeUnit.microcoulomb:
        return _factorToMicrocoulomb;
      case ElectricChargeUnit.nanocoulomb:
        return _factorToNanocoulomb;
      case ElectricChargeUnit.elementaryCharge:
        return _factorToElementaryCharge;
      case ElectricChargeUnit.ampereHour:
        return _factorToAmpereHour;
      case ElectricChargeUnit.milliampereHour:
        return _factorToMilliampereHour;
      case ElectricChargeUnit.statcoulomb:
        return _factorToStatcoulomb;
      case ElectricChargeUnit.abcoulomb:
        return _factorToAbcoulomb;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/electric_charge/electric_charge_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/energy/energy.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'energy_unit.dart';

/// Represents a quantity of energy.
///
/// Energy is a fundamental physical quantity representing the capacity to do work.
/// The SI derived unit for energy is the Joule (J). This class provides a
/// type-safe way to handle energy values and conversions between different units
/// (e.g., joules, calories, kilowatt-hours).
@immutable
class Energy extends Quantity<EnergyUnit> {
  /// Creates a new `Energy` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final workDone = Energy(500.0, EnergyUnit.joule);
  /// final foodEnergy = Energy(250.0, EnergyUnit.kilocalorie);
  /// final electricityUsed = Energy(1.2, EnergyUnit.kilowattHour);
  /// ```
  const Energy(super.value, super.unit);

  /// Converts this energy's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `EnergyUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final energyInKcal = Energy(1.0, EnergyUnit.kilocalorie);
  /// final valueInJoules = energyInKcal.getValue(EnergyUnit.joule); // 4184.0
  /// ```
  @override
  double getValue(EnergyUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Energy] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Energy` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final energyInJoules = Energy(10000.0, EnergyUnit.joule);
  /// final energyInKcalObj = energyInJoules.convertTo(EnergyUnit.kilocalorie);
  /// // energyInKcalObj is Energy(approx. 2.39, EnergyUnit.kilocalorie)
  /// print(energyInKcalObj);
  /// ```
  @override
  Energy convertTo(EnergyUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Energy(newValue, targetUnit);
  }

  /// Compares this [Energy] object to another [Quantity<EnergyUnit>].
  ///
  /// Comparison is based on the physical magnitude of the energies. For an
  /// accurate comparison, this energy's value is converted to the unit of the
  /// [other] energy before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this energy is less than [other].
  /// - Zero if this energy is equal in magnitude to [other].
  /// - A positive integer if this energy is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final e1 = Energy(1.0, EnergyUnit.kilocalorie);    // 4184 J
  /// final e2 = Energy(4184.0, EnergyUnit.joule);      // 4184 J
  /// final e3 = Energy(1.0, EnergyUnit.btu);           // ~1055 J
  ///
  /// print(e1.compareTo(e2)); // 0 (equal magnitude)
  /// print(e1.compareTo(e3)); // 1 (e1 > e3)
  /// ```
  @override
  int compareTo(Quantity<EnergyUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this energy to another energy.
  ///
  /// The [other] energy is converted to the unit of this energy before addition.
  /// The result is a new [Energy] instance with the sum, expressed in the unit
  /// of this energy (the left-hand operand).
  ///
  /// Example:
  /// ```dart
  /// final work = Energy(100.0, EnergyUnit.joule);
  /// final heat = Energy(0.5, EnergyUnit.kilocalorie); // 2092 J
  /// final totalEnergy = work + heat; // Result: Energy(2192.0, EnergyUnit.joule)
  /// ```
  Energy operator +(Energy other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Energy(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another energy from this energy.
  ///
  /// The [other] energy is converted to the unit of this energy before subtraction.
  /// The result is a new [Energy] instance with the difference, expressed in the
  /// unit of this energy (the left-hand operand).
  ///
  /// Example:
  /// ```dart
  /// final totalOutput = Energy(5.0, EnergyUnit.kilowattHour);
  /// final energyConsumed = Energy(1.2, EnergyUnit.kilowattHour);
  /// final netEnergy = totalOutput - energyConsumed; // Result: Energy(3.8, EnergyUnit.kilowattHour)
  /// ```
  Energy operator -(Energy other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Energy(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this energy by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Energy] instance with the scaled value, in the original
  /// unit of this energy.
  ///
  /// Example:
  /// ```dart
  /// final singleEventEnergy = Energy(150.0, EnergyUnit.joule);
  /// final energyOfTenEvents = singleEventEnergy * 10.0; // Result: Energy(1500.0, EnergyUnit.joule)
  /// ```
  Energy operator *(double scalar) {
    return Energy(value * scalar, unit);
  }

  /// Divides this energy by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Energy] instance with the scaled value, in the original
  /// unit of this energy. Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalEnergy = Energy(1000.0, EnergyUnit.kilocalorie);
  /// final energyPerServing = totalEnergy / 4.0; // Result: Energy(250.0, EnergyUnit.kilocalorie)
  /// ```
  Energy operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Energy(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/energy/energy.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/energy/energy_extensions.dart -->
import 'energy.dart';
import 'energy_unit.dart';

/// Provides convenient access to [Energy] values in specific units
/// using getter properties.
///
/// These getters simplify retrieving the numerical value of an energy
/// in a desired unit without explicitly calling `getValue()`.
extension EnergyValueGetters on Energy {
  /// Returns the energy value in Joules (J).
  double get inJoules => getValue(EnergyUnit.joule);

  /// Returns the energy value in Megajoules (MJ).
  double get inMegajoules => getValue(EnergyUnit.megajoule);

  /// Returns the energy value in Kilojoules (kJ).
  double get inKilojoules => getValue(EnergyUnit.kilojoule);

  /// Returns the energy value in Calories (cal).
  double get inCalories => getValue(EnergyUnit.calorie);

  /// Returns the energy value in Kilocalories (kcal).
  double get inKilocalories => getValue(EnergyUnit.kilocalorie);

  /// Returns the energy value in Kilowatt-hours (kWh).
  double get inKilowattHours => getValue(EnergyUnit.kilowattHour);

  /// Returns the energy value in Electronvolts (eV).
  double get inElectronvolts => getValue(EnergyUnit.electronvolt);

  /// Returns the energy value in British Thermal Units (Btu).
  double get inBtu => getValue(EnergyUnit.btu);

  // --- "As" Getters for new Energy objects ---

  /// Returns a new [Energy] object representing this energy in Joules (J).
  Energy get asJoules => convertTo(EnergyUnit.joule);

  /// Returns a new [Energy] object representing this energy in Megajoules (MJ).
  Energy get asMegajoules => convertTo(EnergyUnit.megajoule);

  /// Returns a new [Energy] object representing this energy in Kilojoules (kJ).
  Energy get asKilojoules => convertTo(EnergyUnit.kilojoule);

  /// Returns a new [Energy] object representing this energy in Calories (cal).
  Energy get asCalories => convertTo(EnergyUnit.calorie);

  /// Returns a new [Energy] object representing this energy in Kilocalories (kcal).
  Energy get asKilocalories => convertTo(EnergyUnit.kilocalorie);

  /// Returns a new [Energy] object representing this energy in Kilowatt-hours (kWh).
  Energy get asKilowattHours => convertTo(EnergyUnit.kilowattHour);

  /// Returns a new [Energy] object representing this energy in Electronvolts (eV).
  Energy get asElectronvolts => convertTo(EnergyUnit.electronvolt);

  /// Returns a new [Energy] object representing this energy in British Thermal Units (Btu).
  Energy get asBtu => convertTo(EnergyUnit.btu);
}

/// Provides convenient factory methods for creating [Energy] instances from [num]
/// using getter properties named after common unit symbols or names.
///
/// This allows for an intuitive and concise way to create energy quantities,
/// for example: `250.kcal` or `1.2.kWh`.
extension EnergyCreation on num {
  /// Creates an [Energy] instance from this value in Joules (J).
  Energy get J => Energy(toDouble(), EnergyUnit.joule);

  /// Creates an [Energy] instance from this value in Joules (J).
  Energy get joules => Energy(toDouble(), EnergyUnit.joule);

  /// Creates an [Energy] instance from this value in Megajoules (MJ).
  Energy get megaJ => Energy(toDouble(), EnergyUnit.megajoule);

  /// Creates an [Energy] instance from this value in Megajoules (MJ).
  Energy get megajoules => Energy(toDouble(), EnergyUnit.megajoule);

  /// Creates an [Energy] instance from this value in Kilojoules (kJ).
  Energy get kJ => Energy(toDouble(), EnergyUnit.kilojoule);

  /// Creates an [Energy] instance from this value in Kilojoules (kJ).
  Energy get kilojoules => Energy(toDouble(), EnergyUnit.kilojoule);

  /// Creates an [Energy] instance from this value in Calories (cal).
  Energy get cal => Energy(toDouble(), EnergyUnit.calorie);

  /// Creates an [Energy] instance from this value in Calories (cal).
  Energy get calories => Energy(toDouble(), EnergyUnit.calorie);

  /// Creates an [Energy] instance from this value in Kilocalories (kcal).
  Energy get kcal => Energy(toDouble(), EnergyUnit.kilocalorie);

  /// Creates an [Energy] instance from this value in Kilocalories (kcal).
  Energy get kilocalories => Energy(toDouble(), EnergyUnit.kilocalorie);

  /// Creates an [Energy] instance from this value in Kilowatt-hours (kWh).
  Energy get kWh => Energy(toDouble(), EnergyUnit.kilowattHour);

  /// Creates an [Energy] instance from this value in Kilowatt-hours (kWh).
  Energy get kilowattHours => Energy(toDouble(), EnergyUnit.kilowattHour);

  /// Creates an [Energy] instance from this value in Electronvolts (eV).
  Energy get eV => Energy(toDouble(), EnergyUnit.electronvolt);

  /// Creates an [Energy] instance from this value in Electronvolts (eV).
  Energy get electronvolts => Energy(toDouble(), EnergyUnit.electronvolt);

  /// Creates an [Energy] instance from this value in British Thermal Units (Btu).
  Energy get btu => Energy(toDouble(), EnergyUnit.btu);
}

<!-- END FILE: [v0.12.0] lib/src/units/energy/energy_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/energy/energy_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various energy units relative to the
/// Joule (J), which is the SI derived unit for energy (kg·m²/s²).
///
/// These constants represent the value of `1 [Unit]` in Joules.
/// For example, `joulesPerKilowattHour` is the number of Joules in one kilowatt-hour.
/// All values are based on internationally recognized standard definitions.
class EnergyFactors {
  // --- SI Prefixed Units (relative to Joule) ---

  /// Joules per Megajoule: 1 MJ = 1,000,000 J.
  static const double joulesPerMegajoule = 1000000.0;

  /// Joules per Kilojoule: 1 kJ = 1,000 J.
  static const double joulesPerKilojoule = 1000.0;

  // --- Other Common and Scientific Units ---

  /// Joules per Calorie (cal): 1 thermochemical calorie = 4.184 J.
  /// This is the "small calorie" or "gram calorie". The thermochemical calorie
  /// is a widely accepted standard in scientific contexts.
  static const double joulesPerCalorie = 4.184;

  /// Joules per Kilocalorie (kcal): 1 kcal = 4184 J.
  /// This is the "large calorie", commonly used in nutrition (food energy).
  /// It is equivalent to 1000 thermochemical calories.
  static const double joulesPerKilocalorie = 4184.0;

  /// Joules per Kilowatt-hour (kWh): 1 kWh = 3.6 × 10⁶ J.
  /// A common unit for electrical energy billing. Derived from Power × Time:
  /// 1 kW × 1 h = 1000 J/s × 3600 s = 3,600,000 J.
  static const double joulesPerKilowattHour = 3600000.0;

  /// Joules per Electronvolt (eV): 1 eV ≈ 1.602176634 × 10⁻¹⁹ J.
  /// This value is exact by the 2019 redefinition of SI base units, as it is
  /// derived from the elementary charge 'e'. It represents the kinetic energy
  /// gained by an electron when accelerated through a potential difference of one volt.
  static const double joulesPerElectronvolt = 1.602176634e-19;

  /// Joules per British Thermal Unit (Btu): 1 Btu (International Table) ≈ 1055.056 J.
  /// The International Table definition is commonly used in engineering and is
  /// based on the properties of steam. There are several slightly different
  /// definitions of the Btu; this is a widely accepted standard.
  static const double joulesPerBtu = 1055.056;
}

<!-- END FILE: [v0.12.0] lib/src/units/energy/energy_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/energy/energy_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'energy_factors.dart';

/// Represents units of energy.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each energy unit. All conversion factors are
/// pre-calculated in the constructor relative to the Joule (J).
enum EnergyUnit implements Unit<EnergyUnit> {
  /// Joule (J), the SI derived unit of energy.
  joule(1, 'J'),

  /// Megajoule (MJ), a common multiple of the Joule.
  megajoule(EnergyFactors.joulesPerMegajoule, 'MJ'),

  /// Kilojoule (kJ), a common multiple of the Joule.
  kilojoule(EnergyFactors.joulesPerKilojoule, 'kJ'),

  /// Calorie (cal), the thermochemical calorie, commonly used in science.
  calorie(EnergyFactors.joulesPerCalorie, 'cal'),

  /// Kilocalorie (kcal), the "food calorie", equal to 1000 small calories.
  kilocalorie(EnergyFactors.joulesPerKilocalorie, 'kcal'),

  /// Kilowatt-hour (kWh), a common unit for electrical energy.
  kilowattHour(EnergyFactors.joulesPerKilowattHour, 'kWh'),

  /// Electronvolt (eV), a unit of energy used in particle physics.
  electronvolt(EnergyFactors.joulesPerElectronvolt, 'eV'),

  /// British Thermal Unit (Btu), as defined by the International Table standard.
  btu(EnergyFactors.joulesPerBtu, 'Btu');

  /// Constant constructor for enum members.
  ///
  /// [_toJouleFactor] is the factor to convert from this unit to the base unit (Joule).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `EnergyUnit`.
  const EnergyUnit(double toJouleFactor, this.symbol)
      : _toJouleFactor = toJouleFactor,
        _factorToJoule = toJouleFactor / 1.0,
        _factorToMegajoule = toJouleFactor / EnergyFactors.joulesPerMegajoule,
        _factorToKilojoule = toJouleFactor / EnergyFactors.joulesPerKilojoule,
        _factorToCalorie = toJouleFactor / EnergyFactors.joulesPerCalorie,
        _factorToKilocalorie = toJouleFactor / EnergyFactors.joulesPerKilocalorie,
        _factorToKilowattHour = toJouleFactor / EnergyFactors.joulesPerKilowattHour,
        _factorToElectronvolt = toJouleFactor / EnergyFactors.joulesPerElectronvolt,
        _factorToBtu = toJouleFactor / EnergyFactors.joulesPerBtu;

  /// The factor to convert a value from this unit to the base unit (Joule).
  // ignore: unused_field
  final double _toJouleFactor;

  /// The human-readable symbol for this energy unit (e.g., "J", "kWh").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToJoule;
  final double _factorToMegajoule;
  final double _factorToKilojoule;
  final double _factorToCalorie;
  final double _factorToKilocalorie;
  final double _factorToKilowattHour;
  final double _factorToElectronvolt;
  final double _factorToBtu;

  /// Returns the direct conversion factor to convert a value from this [EnergyUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is used by the `Energy` class
  /// for efficient conversions.
  @override
  @internal
  double factorTo(EnergyUnit targetUnit) {
    switch (targetUnit) {
      case EnergyUnit.joule:
        return _factorToJoule;
      case EnergyUnit.megajoule:
        return _factorToMegajoule;
      case EnergyUnit.kilojoule:
        return _factorToKilojoule;
      case EnergyUnit.calorie:
        return _factorToCalorie;
      case EnergyUnit.kilocalorie:
        return _factorToKilocalorie;
      case EnergyUnit.kilowattHour:
        return _factorToKilowattHour;
      case EnergyUnit.electronvolt:
        return _factorToElectronvolt;
      case EnergyUnit.btu:
        return _factorToBtu;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/energy/energy_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/force/force.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import '../acceleration/acceleration.dart';
import '../acceleration/acceleration_extensions.dart';
import '../acceleration/acceleration_unit.dart';
import '../mass/mass.dart';
import '../mass/mass_extensions.dart';
import '../mass/mass_unit.dart';
import 'force_unit.dart';

/// Represents a quantity of force.
///
/// Force is a derived quantity representing an influence that can change the
/// motion of an object. The SI derived unit is the Newton (N), which is
/// defined as `kg·m/s²`.
@immutable
class Force extends Quantity<ForceUnit> {
  /// Creates a new `Force` with a given [value] and [unit].
  const Force(super.value, super.unit);

  /// Creates a `Force` instance from `Mass` and `Acceleration` (F = m * a).
  ///
  /// This factory performs the dimensional calculation `Force = Mass × Acceleration`.
  /// It converts the inputs to their base SI units (kg and m/s²) for correctness.
  ///
  /// Example:
  /// ```dart
  /// final objectMass = 10.kg;
  /// final objectAcceleration = 2.mpsSquared;
  /// final requiredForce = Force.from(objectMass, objectAcceleration);
  /// print(requiredForce.inNewtons); // Output: 20.0
  /// ```
  factory Force.from(Mass mass, Acceleration acceleration) {
    final kg = mass.inKilograms;
    final mpss = acceleration.inMetersPerSecondSquared;
    return Force(kg * mpss, ForceUnit.newton);
  }

  /// Converts this force's value to the specified [targetUnit].
  @override
  double getValue(ForceUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Force] instance with the value converted to the [targetUnit].
  @override
  Force convertTo(ForceUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Force(newValue, targetUnit);
  }

  @override
  int compareTo(Quantity<ForceUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this force to another.
  Force operator +(Force other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Force(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another force from this one.
  Force operator -(Force other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Force(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this force by a scalar.
  Force operator *(double scalar) {
    return Force(value * scalar, unit);
  }

  /// Divides this force by a scalar.
  Force operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Force(value / scalar, unit);
  }

  // --- Dimensional Analysis ---

  /// Calculates the [Acceleration] of a given [Mass] when this force is applied (a = F / m).
  ///
  /// Throws an [ArgumentError] if the `mass` is zero.
  /// The result is returned as an `Acceleration` quantity in m/s².
  ///
  /// Example:
  /// ```dart
  /// final force = 100.N;
  /// final mass = 10.kg;
  /// final resultingAcceleration = force.accelerationOf(mass);
  /// print(resultingAcceleration.inMetersPerSecondSquared); // Output: 10.0
  /// ```
  Acceleration accelerationOf(Mass mass) {
    final newtons = getValue(ForceUnit.newton);
    final kg = mass.inKilograms;
    if (kg == 0) {
      throw ArgumentError('Mass cannot be zero when calculating acceleration.');
    }
    return Acceleration(newtons / kg, AccelerationUnit.meterPerSecondSquared);
  }

  /// Calculates the [Mass] that would be accelerated at a given [Acceleration] by this force (m = F / a).
  ///
  /// Throws an [ArgumentError] if the `acceleration` is zero.
  /// The result is returned as a `Mass` quantity in kilograms.
  ///
  /// Example:
  /// ```dart
  /// final force = 20.N;
  /// final acceleration = 1.gravity; // ~9.8 m/s²
  /// final requiredMass = force.massFrom(acceleration);
  /// print(requiredMass.inKilograms); // Output: ~2.04
  /// ```
  Mass massFrom(Acceleration acceleration) {
    final newtons = getValue(ForceUnit.newton);
    final mpss = acceleration.inMetersPerSecondSquared;
    if (mpss == 0) {
      throw ArgumentError('Acceleration cannot be zero when calculating mass.');
    }
    return Mass(newtons / mpss, MassUnit.kilogram);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/force/force.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/force/force_extensions.dart -->
import 'force.dart';
import 'force_unit.dart';

/// Provides convenient access to [Force] values in specific units.
extension ForceValueGetters on Force {
  /// Returns the force value in Newtons (N).
  double get inNewtons => getValue(ForceUnit.newton);

  /// Returns the force value in Kilonewtons (kN).
  double get inKilonewtons => getValue(ForceUnit.kilonewton);

  /// Returns the force value in Meganewtons (MN).
  double get inMeganewtons => getValue(ForceUnit.meganewton);

  /// Returns the force value in Millinewtons (mN).
  double get inMillinewtons => getValue(ForceUnit.millinewton);

  /// Returns the force value in Pounds-force (lbf).
  double get inPoundsForce => getValue(ForceUnit.poundForce);

  /// Returns the force value in Dyne (dyn).
  double get inDynes => getValue(ForceUnit.dyne);

  /// Returns the force value in Kilogram-force (kgf).
  double get inKilogramsForce => getValue(ForceUnit.kilogramForce);

  /// Returns the force value in Gram-force (gf).
  double get inGramsForce => getValue(ForceUnit.gramForce);

  /// Returns the force value in Poundals (pdl).
  double get inPoundals => getValue(ForceUnit.poundal);

  /// Returns a [Force] object representing this force in Newtons (N).
  Force get asNewtons => convertTo(ForceUnit.newton);

  /// Returns a [Force] object representing this force in Kilonewtons (kN).
  Force get asKilonewtons => convertTo(ForceUnit.kilonewton);

  /// Returns a [Force] object representing this force in Meganewtons (MN).
  Force get asMeganewtons => convertTo(ForceUnit.meganewton);

  /// Returns a [Force] object representing this force in Millinewtons (mN).
  Force get asMillinewtons => convertTo(ForceUnit.millinewton);

  /// Returns a [Force] object representing this force in Pounds-force (lbf).
  Force get asPoundsForce => convertTo(ForceUnit.poundForce);

  /// Returns a [Force] object representing this force in Dyne (dyn).
  Force get asDynes => convertTo(ForceUnit.dyne);

  /// Returns a [Force] object representing this force in Kilogram-force (kgf).
  Force get asKilogramsForce => convertTo(ForceUnit.kilogramForce);

  /// Returns a [Force] object representing this force in Gram-force (gf).
  Force get asGramsForce => convertTo(ForceUnit.gramForce);

  /// Returns a [Force] object representing this force in Poundals (pdl).
  Force get asPoundals => convertTo(ForceUnit.poundal);
}

/// Provides convenient factory methods for creating [Force] instances from [num].
extension ForceCreation on num {
  /// Creates a [Force] instance from this value in Newtons (N).
  Force get N => Force(toDouble(), ForceUnit.newton);

  /// Creates a [Force] instance from this value in Newtons (N).
  Force get newtons => Force(toDouble(), ForceUnit.newton);

  /// Creates a [Force] instance from this value in Kilonewtons (kN).
  Force get kN => Force(toDouble(), ForceUnit.kilonewton);

  /// Creates a [Force] instance from this value in Kilonewtons (kN).
  Force get kilonewtons => Force(toDouble(), ForceUnit.kilonewton);

  /// Creates a [Force] instance from this value in Meganewtons (MN).
  Force get megaN => Force(toDouble(), ForceUnit.meganewton);

  /// Creates a [Force] instance from this value in Meganewtons (MN).
  Force get meganewtons => Force(toDouble(), ForceUnit.meganewton);

  /// Creates a [Force] instance from this value in Millinewtons (mN).
  Force get mN => Force(toDouble(), ForceUnit.millinewton);

  /// Creates a [Force] instance from this value in Millinewtons (mN).
  Force get millinewtons => Force(toDouble(), ForceUnit.millinewton);

  /// Creates a [Force] instance from this value in Pounds-force (lbf).
  Force get lbf => Force(toDouble(), ForceUnit.poundForce);

  /// Creates a [Force] instance from this value in Dyne (dyn).
  Force get dyn => Force(toDouble(), ForceUnit.dyne);

  /// Creates a [Force] instance from this value in Dyne (dyn).
  Force get dynes => Force(toDouble(), ForceUnit.dyne);

  /// Creates a [Force] instance from this value in Kilogram-force (kgf).
  Force get kgf => Force(toDouble(), ForceUnit.kilogramForce);

  /// Creates a [Force] instance from this value in Gram-force (gf).
  Force get gf => Force(toDouble(), ForceUnit.gramForce);

  /// Creates a [Force] instance from this value in Poundals (pdl).
  Force get pdl => Force(toDouble(), ForceUnit.poundal);
}

<!-- END FILE: [v0.12.0] lib/src/units/force/force_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/force/force_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various force units relative to the
/// Newton (N), which is the SI derived unit for force (kg·m/s²).
///
/// These constants represent: `1 [Unit] = Z [Newtons]`.
class ForceFactors {
  /// Newtons per Kilonewton (kN): 1 kN = 1000 N.
  static const double newtonsPerKilonewton = 1000.0;

  /// Newtons per Meganewton (MN): 1 MN = 1,000,000 N.
  static const double newtonsPerMeganewton = 1e6;

  /// Newtons per Millinewton (mN): 1 mN = 0.001 N.
  static const double newtonsPerMillinewton = 0.001;

  /// Newtons per Pound-force (lbf): 1 lbf = 0.45359237 kg * 9.80665 m/s².
  /// This is based on the standard weight of one pound of mass.
  static const double newtonsPerPoundForce = 4.4482216152605;

  /// Newtons per Dyne (dyn): 1 dyn = 1 g·cm/s² = 10⁻³ kg · 10⁻² m/s² = 10⁻⁵ N.
  /// This is the CGS unit of force.
  static const double newtonsPerDyne = 1e-5;

  /// Newtons per Kilogram-force (kgf) or Kilopond (kp): 1 kgf = 9.80665 N.
  /// This is the force exerted by one kilogram of mass in standard gravity.
  static const double newtonsPerKilogramForce = 9.80665;

  /// Newtons per Gram-force (gf): 1 gf = 0.00980665 N.
  /// The force exerted by one gram of mass in standard gravity.
  static const double newtonsPerGramForce = 0.00980665;

  /// Newtons per Poundal (pdl): 1 pdl ≈ 0.138255 N.
  /// The force required to accelerate 1 pound-mass by 1 ft/s².
  /// Defined as `0.45359237 kg * 0.3048 m/s²`.
  static const double newtonsPerPoundal = 0.138254954376;
}

<!-- END FILE: [v0.12.0] lib/src/units/force/force_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/force/force_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'force_factors.dart';

/// Represents units of force.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each force unit.
/// All conversion factors are pre-calculated in the constructor relative to
/// Newton (N).
enum ForceUnit implements Unit<ForceUnit> {
  /// Newton (N), the SI derived unit of force.
  newton(1, 'N'),

  /// Kilonewton (kN), a common multiple of the Newton.
  kilonewton(ForceFactors.newtonsPerKilonewton, 'kN'),

  /// Meganewton (MN), used for very large forces (e.g., rocket thrust).
  meganewton(ForceFactors.newtonsPerMeganewton, 'MN'),

  /// Millinewton (mN), a common sub-multiple of the Newton.
  millinewton(ForceFactors.newtonsPerMillinewton, 'mN'),

  /// Pound-force (lbf), the imperial/US customary unit of force.
  poundForce(ForceFactors.newtonsPerPoundForce, 'lbf'),

  /// Dyne (dyn), the CGS unit of force.
  dyne(ForceFactors.newtonsPerDyne, 'dyn'),

  /// Kilogram-force (kgf) or Kilopond (kp), a gravitational metric unit of force.
  kilogramForce(ForceFactors.newtonsPerKilogramForce, 'kgf'),

  /// Gram-force (gf), the force exerted by one gram in standard gravity.
  gramForce(ForceFactors.newtonsPerGramForce, 'gf'),

  /// Poundal (pdl), the force to accelerate 1 pound-mass by 1 ft/s².
  poundal(ForceFactors.newtonsPerPoundal, 'pdl');

  /// Constant constructor for enum members.
  const ForceUnit(double toNewtonFactor, this.symbol)
      : _toNewtonFactor = toNewtonFactor,
        _factorToNewton = toNewtonFactor / 1.0,
        _factorToKilonewton = toNewtonFactor / ForceFactors.newtonsPerKilonewton,
        _factorToMeganewton = toNewtonFactor / ForceFactors.newtonsPerMeganewton,
        _factorToMillinewton = toNewtonFactor / ForceFactors.newtonsPerMillinewton,
        _factorToPoundForce = toNewtonFactor / ForceFactors.newtonsPerPoundForce,
        _factorToDyne = toNewtonFactor / ForceFactors.newtonsPerDyne,
        _factorToKilogramForce = toNewtonFactor / ForceFactors.newtonsPerKilogramForce,
        _factorToGramForce = toNewtonFactor / ForceFactors.newtonsPerGramForce,
        _factorToPoundal = toNewtonFactor / ForceFactors.newtonsPerPoundal;

  // ignore: unused_field // Used to store the conversion factor to Newton (N).
  final double _toNewtonFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToNewton;
  final double _factorToKilonewton;
  final double _factorToMeganewton;
  final double _factorToMillinewton;
  final double _factorToPoundForce;
  final double _factorToDyne;
  final double _factorToKilogramForce;
  final double _factorToGramForce;
  final double _factorToPoundal;

  @override
  @internal
  double factorTo(ForceUnit targetUnit) {
    switch (targetUnit) {
      case ForceUnit.newton:
        return _factorToNewton;
      case ForceUnit.kilonewton:
        return _factorToKilonewton;
      case ForceUnit.meganewton:
        return _factorToMeganewton;
      case ForceUnit.millinewton:
        return _factorToMillinewton;
      case ForceUnit.poundForce:
        return _factorToPoundForce;
      case ForceUnit.dyne:
        return _factorToDyne;
      case ForceUnit.kilogramForce:
        return _factorToKilogramForce;
      case ForceUnit.gramForce:
        return _factorToGramForce;
      case ForceUnit.poundal:
        return _factorToPoundal;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/force/force_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/frequency/frequency.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import '../time/time.dart';
import '../time/time_extensions.dart';
import '../time/time_unit.dart';
import 'frequency_unit.dart';

/// Represents a quantity of frequency.
///
/// Frequency is a derived quantity representing the number of occurrences of a
/// repeating event per unit of time. The SI derived unit is the Hertz (Hz),
/// defined as one cycle per second (s⁻¹).
@immutable
class Frequency extends Quantity<FrequencyUnit> {
  /// Creates a new `Frequency` with a given [value] and [unit].
  const Frequency(super.value, super.unit);

  // --- Dimensional Analysis ---

  /// Creates a `Frequency` instance from a `Time` duration representing the
  /// period of one cycle (f = 1/T).
  ///
  /// Throws an [ArgumentError] if the `time` is zero.
  ///
  /// Example:
  /// ```dart
  /// final period = 20.ms; // A 20 millisecond period
  /// final frequency = Frequency.from(period);
  /// print(frequency.inHertz); // Output: 50.0
  /// ```
  factory Frequency.from(Time time) {
    final seconds = time.inSeconds;
    if (seconds == 0) {
      throw ArgumentError('Time period cannot be zero when calculating frequency.');
    }
    return Frequency(1.0 / seconds, FrequencyUnit.hertz);
  }

  /// Calculates the time period for one cycle of this frequency (T = 1/f).
  ///
  /// Throws an [UnsupportedError] if the frequency is zero.
  /// The result is returned as a `Time` quantity in seconds.
  ///
  /// Example:
  /// ```dart
  /// final cpuClock = 4.2.ghz;
  /// final cycleTime = cpuClock.period;
  /// print(cycleTime.inNanoseconds); // Output: ~0.238
  /// ```
  Time get period {
    final hertz = getValue(FrequencyUnit.hertz);
    if (hertz == 0) {
      throw UnsupportedError('Cannot calculate period for zero frequency.');
    }
    return Time(1.0 / hertz, TimeUnit.second);
  }

  // --- Boilerplate ---

  /// Converts this frequency's value to the specified [targetUnit].
  @override
  double getValue(FrequencyUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Frequency] instance with the value converted to the [targetUnit].
  @override
  Frequency convertTo(FrequencyUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Frequency(newValue, targetUnit);
  }

  @override
  int compareTo(Quantity<FrequencyUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this frequency to another.
  Frequency operator +(Frequency other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Frequency(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another frequency from this one.
  Frequency operator -(Frequency other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Frequency(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this frequency by a scalar.
  Frequency operator *(double scalar) {
    return Frequency(value * scalar, unit);
  }

  /// Divides this frequency by a scalar.
  Frequency operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Frequency(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/frequency/frequency.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/frequency/frequency_extensions.dart -->
import 'frequency.dart';
import 'frequency_unit.dart';

/// Provides convenient access to [Frequency] values in specific units.
extension FrequencyValueGetters on Frequency {
  /// Returns the frequency value in Hertz (Hz).
  double get inHertz => getValue(FrequencyUnit.hertz);

  /// Returns the frequency value in Terahertz (THz).
  double get inTerahertz => getValue(FrequencyUnit.terahertz);

  /// Returns the frequency value in Gigahertz (GHz).
  double get inGigahertz => getValue(FrequencyUnit.gigahertz);

  /// Returns the frequency value in Megahertz (MHz).
  double get inMegahertz => getValue(FrequencyUnit.megahertz);

  /// Returns the frequency value in Kilohertz (kHz).
  double get inKilohertz => getValue(FrequencyUnit.kilohertz);

  /// Returns the frequency value in Revolutions per minute (rpm).
  double get inRevolutionsPerMinute => getValue(FrequencyUnit.revolutionsPerMinute);

  /// Returns the frequency value in Beats per minute (bpm).
  double get inBeatsPerMinute => getValue(FrequencyUnit.beatsPerMinute);

  /// Returns the frequency value in Radians per second (rad/s).
  double get inRadiansPerSecond => getValue(FrequencyUnit.radianPerSecond);

  /// Returns the frequency value in Degrees per second (°/s).
  double get inDegreesPerSecond => getValue(FrequencyUnit.degreePerSecond);

  /// Returns a new [Frequency] object representing this frequency in Hertz (Hz).
  Frequency get asHertz => convertTo(FrequencyUnit.hertz);

  /// Returns a new [Frequency] object representing this frequency in Terahertz (THz).
  Frequency get asTerahertz => convertTo(FrequencyUnit.terahertz);

  /// Returns a new [Frequency] object representing this frequency in Gigahertz (GHz).
  Frequency get asGigahertz => convertTo(FrequencyUnit.gigahertz);

  /// Returns a new [Frequency] object representing this frequency in Megahertz (MHz).
  Frequency get asMegahertz => convertTo(FrequencyUnit.megahertz);

  /// Returns a new [Frequency] object representing this frequency in Kilohertz (kHz).
  Frequency get asKilohertz => convertTo(FrequencyUnit.kilohertz);

  /// Returns a new [Frequency] object representing this frequency in Revolutions per minute (rpm).
  Frequency get asRevolutionsPerMinute => convertTo(FrequencyUnit.revolutionsPerMinute);

  /// Returns a new [Frequency] object representing this frequency in Beats per minute (bpm).
  Frequency get asBeatsPerMinute => convertTo(FrequencyUnit.beatsPerMinute);

  /// Returns a new [Frequency] object representing this frequency in Radians per second (rad/s).
  Frequency get asRadiansPerSecond => convertTo(FrequencyUnit.radianPerSecond);

  /// Returns a new [Frequency] object representing this frequency in Degrees per second (°/s).
  Frequency get asDegreesPerSecond => convertTo(FrequencyUnit.degreePerSecond);
}

/// Provides convenient factory methods for creating [Frequency] instances from [num].
extension FrequencyCreation on num {
  /// Creates a [Frequency] instance from this value in Hertz (Hz).
  Frequency get hz => Frequency(toDouble(), FrequencyUnit.hertz);

  /// Creates a [Frequency] instance from this value in Terahertz (THz).
  Frequency get thz => Frequency(toDouble(), FrequencyUnit.terahertz);

  /// Creates a [Frequency] instance from this value in Gigahertz (GHz).
  Frequency get ghz => Frequency(toDouble(), FrequencyUnit.gigahertz);

  /// Creates a [Frequency] instance from this value in Megahertz (MHz).
  Frequency get mhz => Frequency(toDouble(), FrequencyUnit.megahertz);

  /// Creates a [Frequency] instance from this value in Kilohertz (kHz).
  Frequency get khz => Frequency(toDouble(), FrequencyUnit.kilohertz);

  /// Creates a [Frequency] instance from this value in Revolutions per minute (rpm).
  ///
  /// This is functionally equivalent to the `rpm` extension in `AngularVelocity`.
  /// Use the one that is most semantically appropriate for your context.
  //Frequency get rpm => Frequency(toDouble(), FrequencyUnit.revolutionsPerMinute);

  /// Creates a [Frequency] instance from this value in Beats per minute (bpm).
  Frequency get bpm => Frequency(toDouble(), FrequencyUnit.beatsPerMinute);

  /// Creates a [Frequency] instance from this value in Radians per second (rad/s).
  Frequency get radPerSec => Frequency(toDouble(), FrequencyUnit.radianPerSecond);

  /// Creates a [Frequency] instance from this value in Degrees per second (°/s).
  Frequency get degPerSec => Frequency(toDouble(), FrequencyUnit.degreePerSecond);
}

/// Provides an alias for the `rpm` extension on `num` for creating [Frequency] instances.
extension FrequencyCreationRpm on num {
  /// Creates a [Frequency] instance from this value in Revolutions per minute (rpm).
  ///
  /// This is functionally equivalent to the `rpm` extension in `AngularVelocity`.
  /// Use the one that is most semantically appropriate for your context.
  Frequency get rpm => Frequency(toDouble(), FrequencyUnit.revolutionsPerMinute);
}

<!-- END FILE: [v0.12.0] lib/src/units/frequency/frequency_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/frequency/frequency_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'dart:math' as math;

/// Defines base conversion factors for various frequency units relative to the
/// Hertz (Hz), which is the SI derived unit for frequency (s⁻¹).
///
/// These constants represent: `1 [Unit] = Z [Hertz]`.
class FrequencyFactors {
  // --- SI Prefixed Units (relative to Hertz) ---

  /// Hertz per Terahertz: 1 THz = 1e12 Hz.
  static const double hzPerTerahertz = 1e12;

  /// Hertz per Gigahertz: 1 GHz = 1e9 Hz.
  static const double hzPerGigahertz = 1e9;

  /// Hertz per Megahertz: 1 MHz = 1e6 Hz.
  static const double hzPerMegahertz = 1e6;

  /// Hertz per Kilohertz: 1 kHz = 1e3 Hz.
  static const double hzPerKilohertz = 1e3;

  // --- Rotational / Event-based Units ---

  /// Hertz per Revolution Per Minute (RPM): 1 rev/min = (1/60) rev/s = (1/60) Hz.
  static const double hzPerRpm = 1.0 / 60.0;

  /// Hertz per Beats Per Minute (BPM): Same as RPM.
  static const double hzPerBpm = 1.0 / 60.0;

  /// Hertz per Radian per second (rad/s): 1 rad/s = 1/(2π) Hz.
  /// Since 1 rev/s (or 1 Hz) is 2π rad/s.
  static const double hzPerRadPerSecond = 1.0 / (2 * math.pi);

  /// Hertz per Degree per second (deg/s): 1 deg/s = 1/360 Hz.
  /// Since 1 rev/s (or 1 Hz) is 360 deg/s.
  static const double hzPerDegPerSecond = 1.0 / 360.0;
}

<!-- END FILE: [v0.12.0] lib/src/units/frequency/frequency_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/frequency/frequency_interop.dart -->
import '../angular_velocity/angular_velocity.dart';
import '../angular_velocity/angular_velocity_unit.dart';
import 'frequency.dart';
import 'frequency_unit.dart';

/// Provides interoperability extensions between [Frequency] and [AngularVelocity].
///
/// These methods allow for safe and explicit conversions between the general-purpose
/// [Frequency] type and the specialized [AngularVelocity] type.
extension AngularVelocityFrequencyInterop on AngularVelocity {
  /// Converts this [AngularVelocity] to its equivalent [Frequency] representation.
  ///
  /// Since every angular velocity is fundamentally a frequency (a rate of events
  /// over time), this conversion is always safe and direct. It creates a new
  /// [Frequency] object with the same numerical value and the corresponding
  /// frequency unit.
  ///
  /// Example:
  /// ```dart
  /// final motorSpeed = 3000.rpm; // An AngularVelocity object
  /// final motorFrequency = motorSpeed.asFrequency; // A Frequency object
  ///
  /// print(motorFrequency.inHertz); // Outputs 50.0
  /// ```
  Frequency get asFrequency {
    final correspondingUnit = switch (unit) {
      AngularVelocityUnit.radianPerSecond => FrequencyUnit.radianPerSecond,
      AngularVelocityUnit.degreePerSecond => FrequencyUnit.degreePerSecond,
      AngularVelocityUnit.revolutionPerMinute => FrequencyUnit.revolutionsPerMinute,
      // Note: 'rps' in AngularVelocity is covered by `revolutionPerSecond` in Frequency.
      // Assuming AngularVelocityUnit has 'revolutionPerSecond' for a complete mapping.
      // If AngularVelocityUnit uses 'rps', this would need to be mapped.
      // Based on the current files, `revolutionPerSecond` is the correct name.
      AngularVelocityUnit.revolutionPerSecond => FrequencyUnit.hertz,
    };
    return Frequency(value, correspondingUnit);
  }
}

/// Provides interoperability extensions between [Frequency] and [AngularVelocity].
extension FrequencyAngularVelocityInterop on Frequency {
  /// Converts this [Frequency] to its equivalent [AngularVelocity] representation.
  ///
  /// This conversion is only valid if the frequency unit has a direct rotational
  /// equivalent (e.g., `rpm`, `rad/s`, `deg/s`). It will throw an
  /// [UnsupportedError] if the conversion is not applicable, such as for
  /// units like `Hz` (when not representing revolutions per second) or `bpm`.
  ///
  /// This guarded approach ensures type safety and prevents logical errors in
  /// physics and engineering calculations where a true angular velocity is required.
  ///
  /// Example:
  /// ```dart
  /// // This is valid
  /// final rotationalFreq = 60.rpm; // A Frequency object
  /// final motorSpeed = rotationalFreq.asAngularVelocity; // An AngularVelocity object
  ///
  /// // This will throw an error
  /// final heartRate = 120.bpm;
  /// // final invalidSpeed = heartRate.asAngularVelocity; // throws UnsupportedError
  /// ```
  ///
  /// @throws [UnsupportedError] if the frequency unit is not rotational.
  AngularVelocity get asAngularVelocity {
    final correspondingUnit = switch (unit) {
      FrequencyUnit.radianPerSecond => AngularVelocityUnit.radianPerSecond,
      FrequencyUnit.degreePerSecond => AngularVelocityUnit.degreePerSecond,
      FrequencyUnit.revolutionsPerMinute => AngularVelocityUnit.revolutionPerMinute,
      // Hertz (Hz) is 1/s, which corresponds to RPS (revolutions per second)
      FrequencyUnit.hertz => AngularVelocityUnit.revolutionPerSecond,
      _ => null, // Any other unit is not convertible
    };

    if (correspondingUnit != null) {
      return AngularVelocity(value, correspondingUnit);
    } else {
      throw UnsupportedError(
        'Cannot convert a Frequency with unit "${unit.symbol}" to an AngularVelocity. '
        'This operation is only valid for rotational frequency units like rpm, rad/s, deg/s, or Hz (as rps).',
      );
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/frequency/frequency_interop.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/frequency/frequency_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'frequency_factors.dart';

/// Represents units of frequency.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each frequency unit.
/// All conversion factors are pre-calculated in the constructor relative to
/// Hertz (Hz).
enum FrequencyUnit implements Unit<FrequencyUnit> {
  /// Hertz (Hz), the SI derived unit of frequency, equal to one cycle per second.
  hertz(1, 'Hz'),

  /// Terahertz (THz), a multiple of the Hertz.
  terahertz(FrequencyFactors.hzPerTerahertz, 'THz'),

  /// Gigahertz (GHz), a multiple of the Hertz.
  gigahertz(FrequencyFactors.hzPerGigahertz, 'GHz'),

  /// Megahertz (MHz), a multiple of the Hertz.
  megahertz(FrequencyFactors.hzPerMegahertz, 'MHz'),

  /// Kilohertz (kHz), a multiple of the Hertz.
  kilohertz(FrequencyFactors.hzPerKilohertz, 'kHz'),

  /// Revolutions per minute (rpm), a unit of rotational speed.
  revolutionsPerMinute(FrequencyFactors.hzPerRpm, 'rpm'),

  /// Beats per minute (bpm), commonly used for heart rate or music tempo.
  beatsPerMinute(FrequencyFactors.hzPerBpm, 'bpm'),

  /// Radian per second (rad/s), the SI unit for angular velocity, also a measure of frequency.
  radianPerSecond(FrequencyFactors.hzPerRadPerSecond, 'rad/s'),

  /// Degree per second (°/s), a common unit for rotational speed.
  degreePerSecond(FrequencyFactors.hzPerDegPerSecond, '°/s');

  /// Constant constructor for enum members.
  const FrequencyUnit(double toHertzFactor, this.symbol)
      : _toHertzFactor = toHertzFactor,
        _factorToHertz = toHertzFactor / 1.0,
        _factorToTerahertz = toHertzFactor / FrequencyFactors.hzPerTerahertz,
        _factorToGigahertz = toHertzFactor / FrequencyFactors.hzPerGigahertz,
        _factorToMegahertz = toHertzFactor / FrequencyFactors.hzPerMegahertz,
        _factorToKilohertz = toHertzFactor / FrequencyFactors.hzPerKilohertz,
        _factorToRevolutionsPerMinute = toHertzFactor / FrequencyFactors.hzPerRpm,
        _factorToBeatsPerMinute = toHertzFactor / FrequencyFactors.hzPerBpm,
        _factorToRadianPerSecond = toHertzFactor / FrequencyFactors.hzPerRadPerSecond,
        _factorToDegreePerSecond = toHertzFactor / FrequencyFactors.hzPerDegPerSecond;

  // ignore: unused_field // The factor to convert this unit to Hertz (Hz).
  final double _toHertzFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToHertz;
  final double _factorToTerahertz;
  final double _factorToGigahertz;
  final double _factorToMegahertz;
  final double _factorToKilohertz;
  final double _factorToRevolutionsPerMinute;
  final double _factorToBeatsPerMinute;
  final double _factorToRadianPerSecond;
  final double _factorToDegreePerSecond;

  @override
  @internal
  double factorTo(FrequencyUnit targetUnit) {
    switch (targetUnit) {
      case FrequencyUnit.hertz:
        return _factorToHertz;
      case FrequencyUnit.terahertz:
        return _factorToTerahertz;
      case FrequencyUnit.gigahertz:
        return _factorToGigahertz;
      case FrequencyUnit.megahertz:
        return _factorToMegahertz;
      case FrequencyUnit.kilohertz:
        return _factorToKilohertz;
      case FrequencyUnit.revolutionsPerMinute:
        return _factorToRevolutionsPerMinute;
      case FrequencyUnit.beatsPerMinute:
        return _factorToBeatsPerMinute;
      case FrequencyUnit.radianPerSecond:
        return _factorToRadianPerSecond;
      case FrequencyUnit.degreePerSecond:
        return _factorToDegreePerSecond;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/frequency/frequency_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/length/length.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'length_unit.dart';

/// Represents a quantity of length.
@immutable
class Length extends Quantity<LengthUnit> {
  /// Creates a new Length quantity with the given [value] and [unit].
  const Length(super.value, super.unit);

  /// Converts this length's value to the specified [targetUnit].
  @override
  double getValue(LengthUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Length] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Length` object in a different unit
  /// without losing the type information.
  ///
  /// Example:
  /// ```dart
  /// final oneFoot = Length(1.0, LengthUnit.foot);
  /// final inInches = oneFoot.convertTo(LengthUnit.inch); // Length(12.0, LengthUnit.inch)
  /// print(inInches.value); // 12.0
  /// ```
  @override
  Length convertTo(LengthUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Length(newValue, targetUnit);
  }

  /// Compares this [Length] object to another [Quantity<LengthUnit>].
  ///
  /// Comparison is based on the physical magnitude of the lengths.
  /// For comparison, this length is converted to the unit of the [other] length.
  ///
  /// Returns:
  /// - A negative integer if this length is less than [other].
  /// - Zero if this length is equal to [other].
  /// - A positive integer if this length is greater than [other].
  @override
  int compareTo(Quantity<LengthUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this length to another length.
  /// The [other] length is converted to the unit of this length before addition.
  /// Returns a new [Length] instance with the result in the unit of this length.
  Length operator +(Length other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Length(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another length from this length.
  /// The [other] length is converted to the unit of this length before subtraction.
  /// Returns a new [Length] instance with the result in the unit of this length.
  Length operator -(Length other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Length(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this length by a scalar value.
  /// Returns a new [Length] instance with the scaled value in the original unit.
  Length operator *(double scalar) {
    return Length(value * scalar, unit);
  }

  /// Divides this length by a scalar value.
  /// Returns a new [Length] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Length operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Length(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/length/length.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/length/length_extensions.dart -->
import 'length.dart';
import 'length_unit.dart';

/// Provides convenient access to [Length] values in specific units
/// using shortened unit names where appropriate.
extension LengthValueGetters on Length {
  /// Returns the length value in Meters (m).
  double get inM => getValue(LengthUnit.meter);

  /// Returns the length value in Kilometers (km).
  double get inKm => getValue(LengthUnit.kilometer);

  /// Returns the length value in Kilometers (km).
  double get inKilometers => getValue(LengthUnit.kilometer);

  /// Returns the length value in Megameters (Mm).
  double get inMegaM => getValue(LengthUnit.megameter);

  /// Returns the length value in Gigameters (Gm).
  double get inGigaM => getValue(LengthUnit.gigameter);

  /// Returns the length value in Hectometers (hm).
  double get inHm => getValue(LengthUnit.hectometer);

  /// Returns the length value in Decameters (dam).
  double get inDam => getValue(LengthUnit.decameter);

  /// Returns the length value in Decimeters (dm).
  double get inDm => getValue(LengthUnit.decimeter);

  /// Returns the length value in Centimeters (cm).
  double get inCm => getValue(LengthUnit.centimeter);

  /// Returns the length value in Millimeters (mm).
  double get inMm => getValue(LengthUnit.millimeter);

  /// Returns the length value in Micrometers (μm).
  double get inUm => getValue(LengthUnit.micrometer);

  /// Returns the length value in Nanometers (nm).
  double get inNm => getValue(LengthUnit.nanometer);

  /// Returns the length value in Picometers (pm).
  double get inPm => getValue(LengthUnit.picometer);

  /// Returns the length value in Femtometers (fm).
  double get inFm => getValue(LengthUnit.femtometer);

  /// Returns the length value in Inches (in).
  double get inInch => getValue(LengthUnit.inch);

  /// Returns the length value in Feet (ft).
  double get inFt => getValue(LengthUnit.foot);

  /// Returns the length value in Yards (yd).
  double get inYd => getValue(LengthUnit.yard);

  /// Returns the length value in Miles (mi).
  double get inMi => getValue(LengthUnit.mile);

  /// Returns the length value in Nautical Miles (nmi).
  double get inNmi => getValue(LengthUnit.nauticalMile);

  /// Returns the length value in Astronomical Units (AU).
  double get inAU => getValue(LengthUnit.astronomicalUnit);

  /// Returns the length value in Light Years (ly).
  double get inLy => getValue(LengthUnit.lightYear);

  /// Returns the length value in Parsecs (pc).
  double get inPc => getValue(LengthUnit.parsec);

  /// Returns the length value in Ångströms (Å).
  double get inAngstrom => getValue(LengthUnit.angstrom);

  /// Returns a Length representing this length in Meters (m).
  Length get asM => convertTo(LengthUnit.meter);

  /// Returns a Length representing this length in Kilometers (km).
  Length get asKm => convertTo(LengthUnit.kilometer);

  /// Returns a Length representing this length in Megameters (Mm).
  Length get asMegaM => convertTo(LengthUnit.megameter);

  /// Returns a Length representing this length in Gigameters (Gm).
  Length get asGigaM => convertTo(LengthUnit.gigameter);

  /// Returns a Length representing this length in Hectometers (hm).
  Length get asHm => convertTo(LengthUnit.hectometer);

  /// Returns a Length representing this length in Decameters (dam).
  Length get asDam => convertTo(LengthUnit.decameter);

  /// Returns a Length representing this length in Decimeters (dm).
  Length get asDm => convertTo(LengthUnit.decimeter);

  /// Returns a Length representing this length in Centimeters (cm).
  Length get asCm => convertTo(LengthUnit.centimeter);

  /// Returns a Length representing this length in Millimeters (mm).
  Length get asMm => convertTo(LengthUnit.millimeter);

  /// Returns a Length representing this length in Micrometers (μm).
  Length get asUm => convertTo(LengthUnit.micrometer);

  /// Returns a Length representing this length in Nanometers (nm).
  Length get asNm => convertTo(LengthUnit.nanometer);

  /// Returns a Length representing this length in Picometers (pm).
  Length get asPm => convertTo(LengthUnit.picometer);

  /// Returns a Length representing this length in Femtometers (fm).
  Length get asFm => convertTo(LengthUnit.femtometer);

  /// Returns a Length representing this length in Inches (in).
  Length get asInch => convertTo(LengthUnit.inch);

  /// Returns a Length representing this length in Feet (ft).
  Length get asFt => convertTo(LengthUnit.foot);

  /// Returns a Length representing this length in Yards (yd).
  Length get asYd => convertTo(LengthUnit.yard);

  /// Returns a Length representing this length in Miles (mi).
  Length get asMi => convertTo(LengthUnit.mile);

  /// Returns a Length representing this length in Nautical Miles (nmi).
  Length get asNmi => convertTo(LengthUnit.nauticalMile);

  /// Returns a Length representing this length in Astronomical Units (AU).
  Length get asAU => convertTo(LengthUnit.astronomicalUnit);

  /// Returns a Length representing this length in Light Years (ly).
  Length get asLy => convertTo(LengthUnit.lightYear);

  /// Returns a Length representing this length in Parsecs (pc).
  Length get asPc => convertTo(LengthUnit.parsec);

  /// Returns a Length representing this length in Ångströms (Å).
  Length get asAngstrom => convertTo(LengthUnit.angstrom);
}

/// Provides convenient factory methods for creating [Length] instances from [num]
/// using shortened unit names where appropriate.
extension LengthCreation on num {
  /// Creates a [Length] instance representing this numerical value in Meters (m).
  Length get m => Length(toDouble(), LengthUnit.meter);

  /// Creates a [Length] instance representing this numerical value in Kilometers (km).
  Length get km => Length(toDouble(), LengthUnit.kilometer);

  /// Creates a [Length] instance representing this numerical value in Megameters (Mm).
  Length get megaM => Length(toDouble(), LengthUnit.megameter);

  /// Creates a [Length] instance representing this numerical value in Gigameters (Gm).
  Length get gigaM => Length(toDouble(), LengthUnit.gigameter);

  /// Creates a [Length] instance representing this numerical value in Hectometers (hm).
  Length get hm => Length(toDouble(), LengthUnit.hectometer);

  /// Creates a [Length] instance representing this numerical value in Decameters (dam).
  Length get dam => Length(toDouble(), LengthUnit.decameter);

  /// Creates a [Length] instance representing this numerical value in Decimeters (dm).
  Length get dm => Length(toDouble(), LengthUnit.decimeter);

  /// Creates a [Length] instance representing this numerical value in Centimeters (cm).
  Length get cm => Length(toDouble(), LengthUnit.centimeter);

  /// Creates a [Length] instance representing this numerical value in Millimeters (mm).
  Length get mm => Length(toDouble(), LengthUnit.millimeter);

  /// Creates a [Length] instance representing this numerical value in Micrometers (μm).
  Length get um => Length(toDouble(), LengthUnit.micrometer);

  /// Creates a [Length] instance representing this numerical value in Nanometers (nm).
  Length get nm => Length(toDouble(), LengthUnit.nanometer);

  /// Creates a [Length] instance representing this numerical value in Picometers (pm).
  Length get pm => Length(toDouble(), LengthUnit.picometer);

  /// Creates a [Length] instance representing this numerical value in Femtometers (fm).
  Length get fm => Length(toDouble(), LengthUnit.femtometer);

  /// Creates a [Length] instance representing this numerical value in Inches (in).
  Length get inch => Length(toDouble(), LengthUnit.inch);

  /// Creates a [Length] instance representing this numerical value in Feet (ft).
  Length get ft => Length(toDouble(), LengthUnit.foot);

  /// Creates a [Length] instance representing this numerical value in Yards (yd).
  Length get yd => Length(toDouble(), LengthUnit.yard);

  /// Creates a [Length] instance representing this numerical value in Miles (mi).
  Length get mi => Length(toDouble(), LengthUnit.mile);

  /// Creates a [Length] instance representing this numerical value in Nautical Miles (nmi).
  Length get nmi => Length(toDouble(), LengthUnit.nauticalMile);

  /// Creates a [Length] instance representing this numerical value in Astronomical Units (AU).
  // ignore: non_constant_identifier_names
  Length get AU => Length(toDouble(), LengthUnit.astronomicalUnit);

  /// Creates a [Length] instance representing this numerical value in Light Years (ly).
  Length get ly => Length(toDouble(), LengthUnit.lightYear);

  /// Creates a [Length] instance representing this numerical value in Parsecs (pc).
  Length get pc => Length(toDouble(), LengthUnit.parsec);

  /// Creates a [Length] instance representing this numerical value in Ångströms (Å).
  Length get angstrom => Length(toDouble(), LengthUnit.angstrom);

  // Longer aliases (can be added or chosen over short forms)
  // Length get meters => Length(toDouble(), LengthUnit.meter);
  // Length get kilometers => Length(toDouble(), LengthUnit.kilometer);
  // Length get hectometers => Length(toDouble(), LengthUnit.hectometer);
  // Length get decameters => Length(toDouble(), LengthUnit.decameter);
  // Length get decimeters => Length(toDouble(), LengthUnit.decimeter);
  // Length get centimeters => Length(toDouble(), LengthUnit.centimeter);
  // Length get millimeters => Length(toDouble(), LengthUnit.millimeter);
  // Length get micrometers => Length(toDouble(), LengthUnit.micrometer);
  // Length get nanometers => Length(toDouble(), LengthUnit.nanometer);
  // Length get picometers => Length(toDouble(), LengthUnit.picometer);
  // Length get femtometers => Length(toDouble(), LengthUnit.femtometer);
  // Length get inches => Length(toDouble(), LengthUnit.inch);
  // Length get feet => Length(toDouble(), LengthUnit.foot);
  // Length get yards => Length(toDouble(), LengthUnit.yard);
  // Length get miles => Length(toDouble(), LengthUnit.mile);
  // Length get nauticalMiles => Length(toDouble(), LengthUnit.nauticalMile);
  // Length get astronomicalUnits => Length(toDouble(), LengthUnit.astronomicalUnit);
  // Length get lightYears => Length(toDouble(), LengthUnit.lightYear);
  // Length get parsecs => Length(toDouble(), LengthUnit.parsec);
  // Length get angstroms => Length(toDouble(), LengthUnit.angstrom);
}

<!-- END FILE: [v0.12.0] lib/src/units/length/length_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/length/length_factors.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

/// Defines base conversion factors for various length units relative to Meter.
///
/// These constants are based on international standards (e.g., NIST).
class LengthFactors {
  // The base unit for internal calculations is Meter.
  // Factors represent: 1 [Unit] = X [Meters]

  /// Meters per Kilometer: 1 kilometer = 1000.0 meters.
  static const double metersPerKilometer = 1000.0;

  /// Meters per Megameter: 1 megameter = 1e6 meters.
  static const double metersPerMegameter = 1e6;

  /// Meters per Gigameter: 1 gigameter = 1e9 meters.
  static const double metersPerGigameter = 1e9;

  /// Meters per Hectometer: 1 hectometer = 100.0 meters.
  static const double metersPerHectometer = 100.0;

  /// Meters per Decameter: 1 decameter = 10.0 meters.
  static const double metersPerDecameter = 10.0;

  /// Meters per Decimeter: 1 decimeter = 0.1 meters.
  static const double metersPerDecimeter = 0.1;

  /// Meters per Centimeter: 1 centimeter = 0.01 meters.
  static const double metersPerCentimeter = 0.01;

  /// Meters per Millimeter: 1 millimeter = 0.001 meters.
  static const double metersPerMillimeter = 0.001;

  /// Meters per Micrometer: 1 micrometer = 1e-6 meters.
  static const double metersPerMicrometer = 1e-6;

  /// Meters per Nanometer: 1 nanometer = 1e-9 meters.
  static const double metersPerNanometer = 1e-9;

  /// Meters per Picometer: 1 picometer = 1e-12 meters.
  static const double metersPerPicometer = 1e-12;

  /// Meters per Femtometer: 1 femtometer = 1e-15 meters.
  static const double metersPerFemtometer = 1e-15;

  /// Meters per Inch: 1 inch = 0.0254 meters (exact definition).
  static const double metersPerInch = 0.0254;

  /// Meters per Foot: 1 foot = 0.3048 meters (exact definition, as 1 foot = 12 inches).
  static const double metersPerFoot = 0.3048;

  /// Meters per Yard: 1 yard = 0.9144 meters (exact definition, as 1 yard = 3 feet).
  static const double metersPerYard = 0.9144;

  /// Meters per Mile: 1 mile = 1609.344 meters (exact definition, as 1 mile = 1760 yards).
  static const double metersPerMile = 1609.344;

  /// Meters per Nautical Mile: 1 nautical mile = 1852.0 meters (international definition).
  static const double metersPerNauticalMile = 1852.0;

  /// Meters per Astronomical Unit: 1 AU = 149597870700.0 meters (exact definition, IAU 2012).
  static const double metersPerAstronomicalUnit = 149597870700.0;

  /// Meters per Light Year: 1 light year = 9460730472580800.0 meters.
  /// Based on Julian year (365.25 days) and exact speed of light.
  static const double metersPerLightYear = 9460730472580800.0;

  /// Meters per Parsec: 1 parsec ≈ 3.0856775814913673e16 meters.
  /// Derived from astronomical unit: 1 pc = 648000/π AU.
  static const double metersPerParsec = 3.0856775814913673e16;

  /// Meters per Ångström: 1 ångström = 1e-10 meters (exact definition).
  static const double metersPerAngstrom = 1e-10;
}

<!-- END FILE: [v0.12.0] lib/src/units/length/length_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/length/length_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'length_factors.dart';

/// Represents units of length.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each length unit.
/// All conversion factors are pre-calculated in the constructor relative to Meter.
enum LengthUnit implements Unit<LengthUnit> {
  /// Meter (m), the SI base unit of length.
  meter(1, 'm'),

  /// Kilometer (km), equal to 1000 meters.
  kilometer(LengthFactors.metersPerKilometer, 'km'),

  /// Megameter (Mm), equal to 1e6 meters.
  megameter(LengthFactors.metersPerMegameter, 'Mm'),

  /// Gigameter (Gm), equal to 1e9 meters.
  gigameter(LengthFactors.metersPerGigameter, 'Gm'),

  /// Hectometer (hm), equal to 100 meters.
  hectometer(LengthFactors.metersPerHectometer, 'hm'),

  /// Decameter (dam), equal to 10 meters.
  decameter(LengthFactors.metersPerDecameter, 'dam'),

  /// Decimeter (dm), equal to 0.1 meters.
  decimeter(LengthFactors.metersPerDecimeter, 'dm'),

  /// Centimeter (cm), equal to 0.01 meters.
  centimeter(LengthFactors.metersPerCentimeter, 'cm'),

  /// Millimeter (mm), equal to 0.001 meters.
  millimeter(LengthFactors.metersPerMillimeter, 'mm'),

  /// Micrometer (μm), equal to 1e-6 meters.
  micrometer(LengthFactors.metersPerMicrometer, 'μm'),

  /// Nanometer (nm), equal to 1e-9 meters.
  nanometer(LengthFactors.metersPerNanometer, 'nm'),

  /// Picometer (pm), equal to 1e-12 meters.
  picometer(LengthFactors.metersPerPicometer, 'pm'),

  /// Femtometer (fm), equal to 1e-15 meters.
  femtometer(LengthFactors.metersPerFemtometer, 'fm'),

  /// Inch (in), defined as exactly 0.0254 meters.
  inch(LengthFactors.metersPerInch, 'in'),

  /// Foot (ft), defined as exactly 0.3048 meters (12 inches).
  foot(LengthFactors.metersPerFoot, 'ft'),

  /// Yard (yd), defined as exactly 0.9144 meters (3 feet).
  yard(LengthFactors.metersPerYard, 'yd'),

  /// Mile (mi), defined as exactly 1609.344 meters (1760 yards).
  mile(LengthFactors.metersPerMile, 'mi'),

  /// Nautical Mile (nmi), internationally defined as 1852 meters.
  nauticalMile(LengthFactors.metersPerNauticalMile, 'nmi'),

  /// Astronomical Unit (AU), defined as exactly 149597870700 meters.
  astronomicalUnit(LengthFactors.metersPerAstronomicalUnit, 'AU'),

  /// Light Year (ly), the distance light travels in one Julian year.
  lightYear(LengthFactors.metersPerLightYear, 'ly'),

  /// Parsec (pc), approximately 3.26 light years.
  parsec(LengthFactors.metersPerParsec, 'pc'),

  /// Ångström (Å), equal to 1e-10 meters.
  angstrom(LengthFactors.metersPerAngstrom, 'Å');

  /// Constant constructor for enum members.
  ///
  /// [toBaseFactor] is the factor to convert from this unit to the base unit (Meter).
  /// For Meter itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `LengthUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used.
  const LengthUnit(double toBaseFactor, this.symbol)
      : _toMeterFactor = toBaseFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToMeter = toBaseFactor / 1.0,
        _factorToKilometer = toBaseFactor / LengthFactors.metersPerKilometer,
        _factorToMegameter = toBaseFactor / LengthFactors.metersPerMegameter,
        _factorToGigameter = toBaseFactor / LengthFactors.metersPerGigameter,
        _factorToHectometer = toBaseFactor / LengthFactors.metersPerHectometer,
        _factorToDecameter = toBaseFactor / LengthFactors.metersPerDecameter,
        _factorToDecimeter = toBaseFactor / LengthFactors.metersPerDecimeter,
        _factorToCentimeter = toBaseFactor / LengthFactors.metersPerCentimeter,
        _factorToMillimeter = toBaseFactor / LengthFactors.metersPerMillimeter,
        _factorToMicrometer = toBaseFactor / LengthFactors.metersPerMicrometer,
        _factorToNanometer = toBaseFactor / LengthFactors.metersPerNanometer,
        _factorToPicometer = toBaseFactor / LengthFactors.metersPerPicometer,
        _factorToFemtometer = toBaseFactor / LengthFactors.metersPerFemtometer,
        _factorToInch = toBaseFactor / LengthFactors.metersPerInch,
        _factorToFoot = toBaseFactor / LengthFactors.metersPerFoot,
        _factorToYard = toBaseFactor / LengthFactors.metersPerYard,
        _factorToMile = toBaseFactor / LengthFactors.metersPerMile,
        _factorToNauticalMile = toBaseFactor / LengthFactors.metersPerNauticalMile,
        _factorToAstronomicalUnit = toBaseFactor / LengthFactors.metersPerAstronomicalUnit,
        _factorToLightYear = toBaseFactor / LengthFactors.metersPerLightYear,
        _factorToParsec = toBaseFactor / LengthFactors.metersPerParsec,
        _factorToAngstrom = toBaseFactor / LengthFactors.metersPerAngstrom;

  /// The factor to convert a value from this unit to the base unit (Meter).
  /// Example: For Kilometer, this is 1000.0 (meaning 1 km = 1000.0 m).
  // ignore: unused_field
  final double _toMeterFactor;

  /// The human-readable symbol for this length unit (e.g., "m", "km").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToMeter;
  final double _factorToKilometer;
  final double _factorToMegameter;
  final double _factorToGigameter;
  final double _factorToHectometer;
  final double _factorToDecameter;
  final double _factorToDecimeter;
  final double _factorToCentimeter;
  final double _factorToMillimeter;
  final double _factorToMicrometer;
  final double _factorToNanometer;
  final double _factorToPicometer;
  final double _factorToFemtometer;
  final double _factorToInch;
  final double _factorToFoot;
  final double _factorToYard;
  final double _factorToMile;
  final double _factorToNauticalMile;
  final double _factorToAstronomicalUnit;
  final double _factorToLightYear;
  final double _factorToParsec;
  final double _factorToAngstrom;

  /// Returns the direct conversion factor to convert a value from this [LengthUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(LengthUnit targetUnit) {
    switch (targetUnit) {
      case LengthUnit.meter:
        return _factorToMeter;
      case LengthUnit.kilometer:
        return _factorToKilometer;
      case LengthUnit.megameter:
        return _factorToMegameter;
      case LengthUnit.gigameter:
        return _factorToGigameter;

      case LengthUnit.hectometer:
        return _factorToHectometer;
      case LengthUnit.decameter:
        return _factorToDecameter;
      case LengthUnit.decimeter:
        return _factorToDecimeter;
      case LengthUnit.centimeter:
        return _factorToCentimeter;
      case LengthUnit.millimeter:
        return _factorToMillimeter;
      case LengthUnit.micrometer:
        return _factorToMicrometer;
      case LengthUnit.nanometer:
        return _factorToNanometer;
      case LengthUnit.picometer:
        return _factorToPicometer;
      case LengthUnit.femtometer:
        return _factorToFemtometer;
      case LengthUnit.inch:
        return _factorToInch;
      case LengthUnit.foot:
        return _factorToFoot;
      case LengthUnit.yard:
        return _factorToYard;
      case LengthUnit.mile:
        return _factorToMile;
      case LengthUnit.nauticalMile:
        return _factorToNauticalMile;
      case LengthUnit.astronomicalUnit:
        return _factorToAstronomicalUnit;
      case LengthUnit.lightYear:
        return _factorToLightYear;
      case LengthUnit.parsec:
        return _factorToParsec;
      case LengthUnit.angstrom:
        return _factorToAngstrom;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/length/length_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/luminous/luminous_intensity.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'luminous_intensity_unit.dart';

/// Represents a quantity of luminous intensity.
///
/// Luminous intensity is a measure of the wavelength-weighted power emitted
/// by a light source in a particular direction per unit solid angle, based on
/// the luminosity function, a standardized model of the sensitivity of the
/// human eye. The SI base unit for luminous intensity is the Candela (cd).
///
/// This class provides a type-safe way to handle luminous intensity values and
/// conversions between different units (e.g., candelas, millicandelas).
@immutable
class LuminousIntensity extends Quantity<LuminousIntensityUnit> {
  /// Creates a new `LuminousIntensity` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final ledBrightness = LuminousIntensity(150.0, LuminousIntensityUnit.millicandela);
  /// final headlightIntensity = LuminousIntensity(800.0, LuminousIntensityUnit.candela);
  /// ```
  const LuminousIntensity(super.value, super.unit);

  /// Converts this luminous intensity's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the
  /// `LuminousIntensityUnit` enum for efficiency.
  ///
  /// Example:
  /// ```dart
  /// final intensityInCd = LuminousIntensity(0.5, LuminousIntensityUnit.candela);
  /// final valueInMcd = intensityInCd.getValue(LuminousIntensityUnit.millicandela); // 500.0
  /// ```
  @override
  double getValue(LuminousIntensityUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [LuminousIntensity] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final intensityInMcd = LuminousIntensity(2500.0, LuminousIntensityUnit.millicandela);
  /// final intensityInCdObj = intensityInMcd.convertTo(LuminousIntensityUnit.candela);
  /// // intensityInCdObj is LuminousIntensity(2.5, LuminousIntensityUnit.candela)
  /// print(intensityInCdObj); // Output: "2.5 cd"
  /// ```
  @override
  LuminousIntensity convertTo(LuminousIntensityUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return LuminousIntensity(newValue, targetUnit);
  }

  /// Compares this [LuminousIntensity] object to another [Quantity<LuminousIntensityUnit>].
  ///
  /// Comparison is based on the physical magnitude of the luminous intensities.
  ///
  /// Example:
  /// ```dart
  /// final li1 = LuminousIntensity(1.0, LuminousIntensityUnit.candela);      // 1000 mcd
  /// final li2 = LuminousIntensity(1000.0, LuminousIntensityUnit.millicandela); // 1000 mcd
  /// final li3 = LuminousIntensity(0.5, LuminousIntensityUnit.candela);     // 500 mcd
  ///
  /// print(li1.compareTo(li2)); // 0 (equal magnitude)
  /// print(li1.compareTo(li3)); // 1 (li1 > li3)
  /// ```
  @override
  int compareTo(Quantity<LuminousIntensityUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this luminous intensity to another luminous intensity.
  ///
  /// This is physically meaningful if, for example, combining light from multiple
  /// sources in the same direction (though solid angle considerations can be complex).
  /// The [other] intensity is converted to the unit of this intensity before addition.
  ///
  /// Example:
  /// ```dart
  /// final sourceA = LuminousIntensity(100.0, LuminousIntensityUnit.candela);
  /// final sourceB = LuminousIntensity(50000.0, LuminousIntensityUnit.millicandela); // 50 cd
  /// final combinedIntensity = sourceA + sourceB; // Result: LuminousIntensity(150.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator +(LuminousIntensity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return LuminousIntensity(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another luminous intensity from this luminous intensity.
  ///
  /// This could represent the reduction in intensity if one source is removed or shielded.
  /// The [other] intensity is converted to the unit of this intensity before subtraction.
  ///
  /// Example:
  /// ```dart
  /// final totalLight = LuminousIntensity(500.0, LuminousIntensityUnit.candela);
  /// final blockedLight = LuminousIntensity(150.0, LuminousIntensityUnit.candela);
  /// final remainingLight = totalLight - blockedLight; // Result: LuminousIntensity(350.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator -(LuminousIntensity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return LuminousIntensity(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this luminous intensity by a scalar value (a dimensionless number).
  ///
  /// Example:
  /// ```dart
  /// final singleLed = LuminousIntensity(20.0, LuminousIntensityUnit.millicandela);
  /// final arrayBrightness = singleLed * 10.0; // Result: LuminousIntensity(200.0, LuminousIntensityUnit.millicandela)
  /// ```
  LuminousIntensity operator *(double scalar) {
    return LuminousIntensity(value * scalar, unit);
  }

  /// Divides this luminous intensity by a scalar value (a dimensionless number).
  ///
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalOutput = LuminousIntensity(1000.0, LuminousIntensityUnit.candela);
  /// final outputPerSegment = totalOutput / 5.0; // Result: LuminousIntensity(200.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return LuminousIntensity(value / scalar, unit);
  }

  // Potential future enhancements:
  // - LuminousIntensity * SolidAngle = LuminousFlux (would require SolidAngle type or representation)
  // - LuminousIntensity / Area = Luminance (would require Area type)
}

<!-- END FILE: [v0.12.0] lib/src/units/luminous/luminous_intensity.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/luminous/luminous_intensity_extensions.dart -->
import 'luminous_intensity.dart';
import 'luminous_intensity_unit.dart';

/// Provides convenient access to [LuminousIntensity] values in specific units
/// using getter properties.
extension LuminousIntensityValueGetters on LuminousIntensity {
  /// Returns the luminous intensity value in Candelas (cd).
  double get inCandelas => getValue(LuminousIntensityUnit.candela);

  /// Returns the luminous intensity value in Millicandelas (mcd).
  double get inMillicandelas => getValue(LuminousIntensityUnit.millicandela);

  /// Returns the luminous intensity value in Kilocandelas (kcd).
  double get inKilocandelas => getValue(LuminousIntensityUnit.kilocandela);

  // --- "As" Getters for new LuminousIntensity objects ---

  /// Returns a new [LuminousIntensity] object representing this intensity in Candelas (cd).
  LuminousIntensity get asCandelas => convertTo(LuminousIntensityUnit.candela);

  /// Returns a new [LuminousIntensity] object representing this intensity in Millicandelas (mcd).
  LuminousIntensity get asMillicandelas => convertTo(LuminousIntensityUnit.millicandela);

  /// Returns a new [LuminousIntensity] object representing this intensity in Kilocandelas (kcd).
  LuminousIntensity get asKilocandelas => convertTo(LuminousIntensityUnit.kilocandela);
}

/// Provides convenient factory methods for creating [LuminousIntensity] instances from [num]
/// using getter properties named after common unit symbols or names.
extension LuminousIntensityCreation on num {
  /// Creates a [LuminousIntensity] instance from this numerical value in Candelas (cd).
  LuminousIntensity get cd => LuminousIntensity(toDouble(), LuminousIntensityUnit.candela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Candelas (cd).
  /// Alias for `cd`.
  LuminousIntensity get candelas => LuminousIntensity(toDouble(), LuminousIntensityUnit.candela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Millicandelas (mcd).
  LuminousIntensity get mcd => LuminousIntensity(toDouble(), LuminousIntensityUnit.millicandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Millicandelas (mcd).
  /// Alias for `mcd`.
  LuminousIntensity get millicandelas =>
      LuminousIntensity(toDouble(), LuminousIntensityUnit.millicandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Kilocandelas (kcd).
  LuminousIntensity get kcd => LuminousIntensity(toDouble(), LuminousIntensityUnit.kilocandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Kilocandelas (kcd).
  /// Alias for `kcd`.
  LuminousIntensity get kilocandelas =>
      LuminousIntensity(toDouble(), LuminousIntensityUnit.kilocandela);
}

<!-- END FILE: [v0.12.0] lib/src/units/luminous/luminous_intensity_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/luminous/luminous_intensity_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various luminous intensity units relative
/// to the Candela (cd), which is the SI base unit for luminous intensity.
///
/// These constants represent: `1 [Unit] = Z [Candelas]`.
/// So, `candelasPerMillicandela` means `1 millicandela = candelasPerMillicandela candelas`.
class LuminousIntensityFactors {
  // --- SI Prefixed Units (relative to Candela) ---

  /// Candelas per Millicandela: 1 millicandela (mcd) = 0.001 candelas (cd).
  static const double candelasPerMillicandela = 0.001;

  /// Candelas per Kilocandela: 1 kilocandela (kcd) = 1000 candelas (cd).
  /// Note: Kilocandela is a valid SI unit but less commonly used in practice
  /// compared to candela or millicandela for typical light sources.
  static const double candelasPerKilocandela = 1000.0;

  // --- Other historical or specialized units (less common) ---
  // Example: Hefnerkerze (HK) or Hefner candle, an old German unit of luminous intensity.
  // 1 HK ≈ 0.903 cd.
  // static const double candelasPerHefnerCandle = 0.903;

  // Example: Carcel, an old French unit.
  // 1 Carcel ≈ 9.74 cd (varies by definition).
  // static const double candelasPerCarcel = 9.74;

  // For a primary SI base unit like Candela, prefixed versions are the most relevant.
  // Other units are typically for historical context or very specialized applications.
  // Focusing on SI prefixed units for the core implementation.
}

<!-- END FILE: [v0.12.0] lib/src/units/luminous/luminous_intensity_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/luminous/luminous_intensity_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'luminous_intensity_factors.dart';

/// Represents units for luminous intensity.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each luminous intensity unit.
/// All conversion factors are pre-calculated in the constructor relative to Candela (cd),
/// which is the SI base unit for luminous intensity.
enum LuminousIntensityUnit implements Unit<LuminousIntensityUnit> {
  /// Candela (cd), the SI base unit of luminous intensity.
  /// It is defined by taking the fixed numerical value of the luminous efficacy
  /// of monochromatic radiation of frequency 540 × 10¹² Hz, Kcd, to be 683
  /// when expressed in the unit lm W⁻¹, which is equal to cd sr W⁻¹ or
  /// cd sr kg⁻¹ m⁻² s³.
  candela(1, 'cd'),

  /// Millicandela (mcd), equal to 0.001 candelas.
  /// Commonly used for LEDs and indicator lights.
  millicandela(LuminousIntensityFactors.candelasPerMillicandela, 'mcd'),

  /// Kilocandela (kcd), equal to 1000 candelas.
  /// A less common unit, might be used for very high-intensity light sources
  /// like searchlights or lighthouses.
  kilocandela(LuminousIntensityFactors.candelasPerKilocandela, 'kcd');

  // If Hefnerkerze were to be added:
  // /// Hefnerkerze (HK) or Hefner candle, an old German unit.
  // /// 1 HK ≈ 0.903 cd.
  // hefnerCandle(LuminousIntensityFactors.candelasPerHefnerCandle, 'HK');

  /// Constant constructor for enum members.
  ///
  /// [_toCandelaFactor] is the factor to convert from this unit to the base unit (Candela).
  /// For Candela itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `LuminousIntensityUnit`.
  const LuminousIntensityUnit(double toCandelaFactor, this.symbol)
      : _toCandelaFactor = toCandelaFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToCandela = toCandelaFactor / 1.0, // Base unit factor for candela is 1.0
        _factorToMillicandela = toCandelaFactor / LuminousIntensityFactors.candelasPerMillicandela,
        _factorToKilocandela = toCandelaFactor / LuminousIntensityFactors.candelasPerKilocandela;
  // If hefnerCandle were added:
  // _factorToHefnerCandle = toCandelaFactor / LuminousIntensityFactors.candelasPerHefnerCandle;

  /// The factor to convert a value from this unit to the base unit (Candela).
  /// Example: For Millicandela, this is 0.001 (meaning 1 mcd = 0.001 cd).
  /// This field is primarily used internally by the constructor.
  // ignore: unused_field
  final double _toCandelaFactor;

  /// The human-readable symbol for this luminous intensity unit (e.g., "cd", "mcd").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToCandela;
  final double _factorToMillicandela;
  final double _factorToKilocandela;
  // If hefnerCandle were added:
  // final double _factorToHefnerCandle;

  /// Returns the direct conversion factor to convert a value from this [LuminousIntensityUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `LuminousIntensity`
  /// class for conversions.
  @override
  @internal
  double factorTo(LuminousIntensityUnit targetUnit) {
    switch (targetUnit) {
      case LuminousIntensityUnit.candela:
        return _factorToCandela;
      case LuminousIntensityUnit.millicandela:
        return _factorToMillicandela;
      case LuminousIntensityUnit.kilocandela:
        return _factorToKilocandela;
      // If hefnerCandle were added:
      // case LuminousIntensityUnit.hefnerCandle:
      //  return _factorToHefnerCandle;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/luminous/luminous_intensity_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/mass/mass.dart -->
// BEGIN FILE: lib/src/units/mass/mass.dart
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'mass_unit.dart';

/// Represents a quantity of mass.
///
/// Mass is a fundamental physical property of matter. It is a measure of an
/// object's resistance to acceleration (a change in its state of motion)
/// when a net force is applied. It also determines the strength of its
/// mutual gravitational attraction to other bodies. The SI base unit of mass
/// is the Kilogram (kg).
///
/// This class provides a type-safe way to handle mass values and conversions
/// between different units of mass (e.g., kilograms, grams, pounds, ounces).
@immutable
class Mass extends Quantity<MassUnit> {
  /// Creates a new `Mass` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final personWeightKg = Mass(70.0, MassUnit.kilogram);
  /// final sugarAmountGrams = Mass(500.0, MassUnit.gram);
  /// final packageWeightLbs = Mass(5.0, MassUnit.pound);
  /// ```
  const Mass(super.value, super.unit);

  /// Converts this mass's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `MassUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final weightInKg = Mass(1.0, MassUnit.kilogram);
  /// final weightInGramsValue = weightInKg.getValue(MassUnit.gram); // 1000.0
  ///
  /// final weightInLbs = Mass(2.20462, MassUnit.pound);
  /// final weightInKgValue = weightInLbs.getValue(MassUnit.kilogram); // approx 1.0
  /// ```
  @override
  double getValue(MassUnit targetUnit) {
    // If the target unit is the same as the current unit, no conversion is needed.
    if (targetUnit == unit) return value;
    // Otherwise, multiply by the direct conversion factor.
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Mass] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Mass` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final weightInGrams = Mass(1500.0, MassUnit.gram);
  /// final weightInKilogramsObj = weightInGrams.convertTo(MassUnit.kilogram);
  /// // weightInKilogramsObj is Mass(1.5, MassUnit.kilogram)
  /// print(weightInKilogramsObj); // Output: "1.5 kg" (depending on toString formatting)
  /// ```
  @override
  Mass convertTo(MassUnit targetUnit) {
    // If the target unit is the same, return this instance (immutable optimization).
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Mass(newValue, targetUnit);
  }

  /// Compares this [Mass] object to another [Quantity<MassUnit>].
  ///
  /// Comparison is based on the physical magnitude of the masses.
  /// For an accurate comparison, this mass's value is converted to the unit
  /// of the [other] mass before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this mass is less than [other].
  /// - Zero if this mass is equal in magnitude to [other].
  /// - A positive integer if this mass is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final m1 = Mass(1.0, MassUnit.kilogram);    // 1000 g
  /// final m2 = Mass(1000.0, MassUnit.gram);    // 1000 g
  /// final m3 = Mass(2.0, MassUnit.pound);     // approx 907.18 g
  ///
  /// print(m1.compareTo(m2)); // 0 (equal magnitude)
  /// print(m1.compareTo(m3)); // 1 (m1 > m3, since 1kg > 2lb)
  /// print(m3.compareTo(m1)); // -1 (m3 < m1)
  /// ```
  @override
  int compareTo(Quantity<MassUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison of their magnitudes.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this mass to another mass.
  ///
  /// The [other] mass is converted to the unit of this mass before addition.
  /// The result is a new [Mass] instance with the sum, expressed in the unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final item1 = Mass(1.5, MassUnit.kilogram);
  /// final item2 = Mass(500.0, MassUnit.gram); // 0.5 kg
  /// final totalMass = item1 + item2; // Result: Mass(2.0, MassUnit.kilogram)
  /// ```
  Mass operator +(Mass other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Mass(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another mass from this mass.
  ///
  /// The [other] mass is converted to the unit of this mass before subtraction.
  /// The result is a new [Mass] instance with the difference, expressed in the unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final containerWithContents = Mass(5.0, MassUnit.kilogram);
  /// final contents = Mass(1500.0, MassUnit.gram); // 1.5 kg
  /// final emptyContainer = containerWithContents - contents; // Result: Mass(3.5, MassUnit.kilogram)
  /// ```
  Mass operator -(Mass other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Mass(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this mass by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Mass] instance with the scaled value, in the original unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final singleItemMass = Mass(0.25, MassUnit.kilogram);
  /// final massOfFourItems = singleItemMass * 4.0; // Result: Mass(1.0, MassUnit.kilogram)
  /// ```
  Mass operator *(double scalar) {
    return Mass(value * scalar, unit);
  }

  /// Divides this mass by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Mass] instance with the scaled value, in the original unit of this mass.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalMass = Mass(10.0, MassUnit.kilogram);
  /// final massPerPortion = totalMass / 5.0; // Result: Mass(2.0, MassUnit.kilogram)
  /// ```
  Mass operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Mass(value / scalar, unit);
  }

  // Potential future enhancement:
  // Mass / Volume = Density (would require a Density quantity type)
  // Mass * Acceleration = Force (would require Force and Acceleration types)
}

<!-- END FILE: [v0.12.0] lib/src/units/mass/mass.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/mass/mass_extensions.dart -->
import 'mass.dart';
import 'mass_unit.dart';

/// Provides convenient access to [Mass] values in specific units
/// using getter properties.
///
/// These getters simplify retrieving the numerical value of a mass
/// in a desired unit without explicitly calling `getValue()`.
extension MassValueGetters on Mass {
  /// Returns the mass value in Kilograms (kg).
  double get inKilograms => getValue(MassUnit.kilogram);

  /// Returns the mass value in Hectograms (hg).
  double get inHectograms => getValue(MassUnit.hectogram);

  /// Returns the mass value in Decagrams (dag).
  double get inDecagrams => getValue(MassUnit.decagram);

  /// Returns the mass value in Grams (g).
  double get inGrams => getValue(MassUnit.gram);

  /// Returns the mass value in Decigrams (dg).
  double get inDecigrams => getValue(MassUnit.decigram);

  /// Returns the mass value in Centigrams (cg).
  double get inCentigrams => getValue(MassUnit.centigram);

  /// Returns the mass value in Milligrams (mg).
  double get inMilligrams => getValue(MassUnit.milligram);

  /// Returns the mass value in Micrograms (μg).
  double get inMicrograms => getValue(MassUnit.microgram);

  /// Returns the mass value in Nanograms (ng).
  double get inNanograms => getValue(MassUnit.nanogram);

  /// Returns the mass value in Megagrams (Mg).
  double get inMegaG => getValue(MassUnit.megagram);

  /// Returns the mass value in Gigagrams (Gg).
  double get inGigaG => getValue(MassUnit.gigagram);

  /// Returns the mass value in Tonnes (t, metric tons).
  double get inTonnes => getValue(MassUnit.tonne);

  /// Returns the mass value in Pounds (lb).
  double get inPounds => getValue(MassUnit.pound);

  /// Returns the mass value in Ounces (oz).
  double get inOunces => getValue(MassUnit.ounce);

  /// Returns the mass value in Stones (st).
  double get inStones => getValue(MassUnit.stone);

  /// Returns the mass value in Slugs (slug).
  double get inSlugs => getValue(MassUnit.slug);

  /// Returns the mass value in Short Tons (US).
  double get inShortTons => getValue(MassUnit.shortTon);

  /// Returns the mass value in Long Tons (UK).
  double get inLongTons => getValue(MassUnit.longTon);

  /// Returns the mass value in Atomic Mass Units (u).
  double get inAtomicMassUnits => getValue(MassUnit.atomicMassUnit);

  /// Returns the mass value in Carats (ct).
  double get inCarats => getValue(MassUnit.carat);

  // --- "As" Getters for new Mass objects ---

  /// Returns a new [Mass] object representing this mass in Kilograms (kg).
  Mass get asKilograms => convertTo(MassUnit.kilogram);

  /// Returns a new [Mass] object representing this mass in Hectograms (hg).
  Mass get asHectograms => convertTo(MassUnit.hectogram);

  /// Returns a new [Mass] object representing this mass in Decagrams (dag).
  Mass get asDecagrams => convertTo(MassUnit.decagram);

  /// Returns a new [Mass] object representing this mass in Grams (g).
  Mass get asGrams => convertTo(MassUnit.gram);

  /// Returns a new [Mass] object representing this mass in Decigrams (dg).
  Mass get asDecigrams => convertTo(MassUnit.decigram);

  /// Returns a new [Mass] object representing this mass in Centigrams (cg).
  Mass get asCentigrams => convertTo(MassUnit.centigram);

  /// Returns a new [Mass] object representing this mass in Milligrams (mg).
  Mass get asMilligrams => convertTo(MassUnit.milligram);

  /// Returns a new [Mass] object representing this mass in Micrograms (μg).
  Mass get asMicrograms => convertTo(MassUnit.microgram);

  /// Returns a new [Mass] object representing this mass in Nanograms (ng).
  Mass get asNanograms => convertTo(MassUnit.nanogram);

  /// Returns a new [Mass] object representing this mass in Megagrams (Mg).
  Mass get asMegaG => convertTo(MassUnit.megagram);

  /// Returns a new [Mass] object representing this mass in Gigagrams (Gg).
  Mass get asGigaG => convertTo(MassUnit.gigagram);

  /// Returns a new [Mass] object representing this mass in Tonnes (t).
  Mass get asTonnes => convertTo(MassUnit.tonne);

  /// Returns a new [Mass] object representing this mass in Pounds (lb).
  Mass get asPounds => convertTo(MassUnit.pound);

  /// Returns a new [Mass] object representing this mass in Ounces (oz).
  Mass get asOunces => convertTo(MassUnit.ounce);

  /// Returns a new [Mass] object representing this mass in Stones (st).
  Mass get asStones => convertTo(MassUnit.stone);

  /// Returns a new [Mass] object representing this mass in Slugs (slug).
  Mass get asSlugs => convertTo(MassUnit.slug);

  /// Returns a new [Mass] object representing this mass in Short Tons (US).
  Mass get asShortTons => convertTo(MassUnit.shortTon);

  /// Returns a new [Mass] object representing this mass in Long Tons (UK).
  Mass get asLongTons => convertTo(MassUnit.longTon);

  /// Returns a new [Mass] object representing this mass in Atomic Mass Units (u).
  Mass get asAtomicMassUnits => convertTo(MassUnit.atomicMassUnit);

  /// Returns a new [Mass] object representing this mass in Carats (ct).
  Mass get asCarats => convertTo(MassUnit.carat);
}

/// Provides convenient factory methods for creating [Mass] instances from [num]
/// using getter properties named after common unit symbols or names.
///
/// This allows for an intuitive and concise way to create mass quantities,
/// for example: `70.kg` or `500.grams`.
extension MassCreation on num {
  /// Creates a [Mass] instance representing this numerical value in Kilograms (kg).
  Mass get kg => Mass(toDouble(), MassUnit.kilogram);

  /// Creates a [Mass] instance representing this numerical value in Hectograms (hg).
  Mass get hg => Mass(toDouble(), MassUnit.hectogram);

  /// Creates a [Mass] instance representing this numerical value in Decagrams (dag).
  Mass get dag => Mass(toDouble(), MassUnit.decagram);

  /// Creates a [Mass] instance representing this numerical value in Grams (g).
  Mass get g => Mass(toDouble(), MassUnit.gram);

  /// Creates a [Mass] instance representing this numerical value in Grams (g).
  /// Alias for `g`.
  Mass get grams => Mass(toDouble(), MassUnit.gram);

  /// Creates a [Mass] instance representing this numerical value in Decigrams (dg).
  Mass get dg => Mass(toDouble(), MassUnit.decigram);

  /// Creates a [Mass] instance representing this numerical value in Centigrams (cg).
  Mass get cg => Mass(toDouble(), MassUnit.centigram);

  /// Creates a [Mass] instance representing this numerical value in Milligrams (mg).
  Mass get mg => Mass(toDouble(), MassUnit.milligram);

  /// Creates a [Mass] instance representing this numerical value in Milligrams (mg).
  /// Alias for `mg`.
  Mass get milligrams => Mass(toDouble(), MassUnit.milligram);

  /// Creates a [Mass] instance representing this numerical value in Micrograms (μg).
  Mass get ug => Mass(toDouble(), MassUnit.microgram);

  /// Creates a [Mass] instance representing this numerical value in Micrograms (μg).
  /// Alias for `ug`.
  Mass get micrograms => Mass(toDouble(), MassUnit.microgram);

  /// Creates a [Mass] instance representing this numerical value in Nanograms (ng).
  Mass get ng => Mass(toDouble(), MassUnit.nanogram);

  /// Creates a [Mass] instance representing this numerical value in Nanograms (ng).
  /// Alias for `ng`.
  Mass get nanograms => Mass(toDouble(), MassUnit.nanogram);

  /// Creates a [Mass] instance representing this numerical value in Megagrams (Mg).
  Mass get megaG => Mass(toDouble(), MassUnit.megagram);

  /// Creates a [Mass] instance representing this numerical value in Gigagrams (Gg).
  Mass get gigaG => Mass(toDouble(), MassUnit.gigagram);

  /// Creates a [Mass] instance representing this numerical value in Tonnes (t, metric tons).
  Mass get t => Mass(toDouble(), MassUnit.tonne);

  /// Creates a [Mass] instance representing this numerical value in Tonnes (t, metric tons).
  /// Alias for `t`.
  Mass get tonnes => Mass(toDouble(), MassUnit.tonne);

  /// Creates a [Mass] instance representing this numerical value in Pounds (lb).
  Mass get lb => Mass(toDouble(), MassUnit.pound);

  /// Creates a [Mass] instance representing this numerical value in Pounds (lb).
  /// Alias for `lb`.
  Mass get pounds => Mass(toDouble(), MassUnit.pound);

  /// Creates a [Mass] instance representing this numerical value in Ounces (oz).
  Mass get oz => Mass(toDouble(), MassUnit.ounce);

  /// Creates a [Mass] instance representing this numerical value in Ounces (oz).
  /// Alias for `oz`.
  Mass get ounces => Mass(toDouble(), MassUnit.ounce);

  /// Creates a [Mass] instance representing this numerical value in Stones (st).
  Mass get st => Mass(toDouble(), MassUnit.stone);

  /// Creates a [Mass] instance representing this numerical value in Stones (st).
  /// Alias for `st`.
  Mass get stones => Mass(toDouble(), MassUnit.stone);

  /// Creates a [Mass] instance representing this numerical value in Slugs (slug).
  Mass get slugs => Mass(toDouble(), MassUnit.slug);

  /// Creates a [Mass] instance representing this numerical value in Short Tons (US).
  Mass get shortTons => Mass(toDouble(), MassUnit.shortTon);

  /// Creates a [Mass] instance representing this numerical value in Long Tons (UK).
  Mass get longTons => Mass(toDouble(), MassUnit.longTon);

  /// Creates a [Mass] instance representing this numerical value in Atomic Mass Units (u).
  Mass get u => Mass(toDouble(), MassUnit.atomicMassUnit);

  /// Creates a [Mass] instance representing this numerical value in Atomic Mass Units (u).
  /// Alias for `u`.
  Mass get atomicMassUnits => Mass(toDouble(), MassUnit.atomicMassUnit);

  /// Creates a [Mass] instance representing this numerical value in Carats (ct).
  Mass get ct => Mass(toDouble(), MassUnit.carat);

  /// Creates a [Mass] instance representing this numerical value in Carats (ct).
  /// Alias for `ct`.
  Mass get carats => Mass(toDouble(), MassUnit.carat);
}

<!-- END FILE: [v0.12.0] lib/src/units/mass/mass_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/mass/mass_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

import '../../../quantify.dart' show Unit;
import '../../core/unit.dart' show Unit;

/// Defines base conversion factors for various mass units relative to the Kilogram (kg),
/// which is the SI base unit for mass.
///
/// These constants are based on international standards and exact definitions where available
/// (e.g., the international avoirdupois pound).
///
/// The structure `X_per_Y` means "how many X are in one Y".
/// However, for consistency with how factors are used (1 [Unit] = X BaseUnit),
/// these constants represent: `1 [Unit] = Z [Kilograms]`.
/// So, `kilogramsPerGram` means `1 gram = kilogramsPerGram kilograms`.
class MassFactors {
  // --- SI Units (relative to Kilogram) ---

  /// Kilograms per Hectogram: 1 hectogram = 0.1 kilograms.
  static const double kilogramsPerHectogram = 0.1;

  /// Kilograms per Decagram: 1 decagram = 0.01 kilograms.
  static const double kilogramsPerDecagram = 0.01;

  /// Kilograms per Gram: 1 gram = 0.001 kilograms.
  static const double kilogramsPerGram = 0.001;

  /// Kilograms per Decigram: 1 decigram = 0.0001 kilograms.
  static const double kilogramsPerDecigram = 0.0001;

  /// Kilograms per Centigram: 1 centigram = 0.00001 kilograms.
  static const double kilogramsPerCentigram = 0.00001;

  /// Kilograms per Milligram: 1 milligram = 0.000001 kilograms.
  /// (1 mg = 0.001 g, and 1 g = 0.001 kg)
  static const double kilogramsPerMilligram = kilogramsPerGram * 0.001;

  /// Kilograms per Microgram: 1 microgram = 1e-9 kilograms.
  static const double kilogramsPerMicrogram = 1e-9;

  /// Kilograms per Nanogram: 1 nanogram = 1e-12 kilograms.
  static const double kilogramsPerNanogram = 1e-12;

  /// Kilograms per Megagram: 1 megagram = 1000 kilograms (equivalent to 1 tonne).
  static const double kilogramsPerMegagram = 1000.0;

  /// Kilograms per Gigagram: 1 gigagram = 1e6 kilograms.
  static const double kilogramsPerGigagram = 1e6;

  /// Kilograms per Tonne (Metric Ton): 1 tonne = 1000 kilograms.
  static const double kilogramsPerTonne = 1000.0;

  // --- Imperial / US Customary Units (relative to Kilogram) ---

  /// Kilograms per Pound (Avoirdupois): 1 pound = 0.45359237 kilograms.
  /// This is an exact definition based on the international pound and yard agreement of 1959.
  static const double kilogramsPerPound = 0.45359237;

  /// Kilograms per Ounce (Avoirdupois): 1 ounce = 1/16 pound.
  /// 1 ounce = (0.45359237 / 16) kilograms.
  static const double kilogramsPerOunce = kilogramsPerPound / 16.0;

  /// Kilograms per Stone: 1 stone = 14 pounds.
  /// 1 stone = (14 * 0.45359237) kilograms.
  static const double kilogramsPerStone = kilogramsPerPound * 14.0;

  /// Kilograms per Slug: 1 slug ≈ 14.5939029372 kilograms.
  /// The slug is a unit of mass in the gravitational systems of units,
  /// defined as the mass that accelerates by 1 ft/s² when a force of one pound-force (lbf)
  /// is exerted on it.
  /// 1 slug = 1 lbf⋅s²/ft.
  /// Using g₀ = 9.80665 m/s² (standard gravity) and 1 ft = 0.3048 m:
  /// 1 lbf = 0.45359237 kg * 9.80665 m/s² (force)
  /// 1 slug = (0.45359237 * 9.80665) / 0.3048 kg (approx, if derived from lbf definition relative to kg-mass and g0)
  /// A more commonly cited direct conversion factor for slug to kg is used here.
  /// For example, NIST Special Publication 811 (2008 edition), Appendix B.8, lists:
  /// slug -> 1.459 390 E+01 kg
  static const double kilogramsPerSlug = 14.5939029372;

  /// Kilograms per Short Ton (US): 1 short ton = 2000 pounds.
  /// 1 short ton = (2000 * 0.45359237) kilograms = 907.18474 kg.
  static const double kilogramsPerShortTon = kilogramsPerPound * 2000.0;

  /// Kilograms per Long Ton (UK): 1 long ton = 2240 pounds.
  /// 1 long ton = (2240 * 0.45359237) kilograms = 1016.0469088 kg.
  static const double kilogramsPerLongTon = kilogramsPerPound * 2240.0;

  // --- Special Units ---

  /// Kilograms per Atomic Mass Unit: 1 u ≈ 1.66053906660e-27 kilograms.
  /// Based on 2018 CODATA recommended value.
  static const double kilogramsPerAtomicMassUnit = 1.66053906660e-27;

  /// Kilograms per Carat: 1 carat = 0.0002 kilograms (exact).
  /// The metric carat is defined as exactly 200 milligrams.
  static const double kilogramsPerCarat = 0.0002;

  // --- Other potential units (can be added if needed) ---
  // Example: Troy ounce (for precious metals)
  // /// Kilograms per Troy Ounce: 1 troy ounce ≈ 0.0311034768 kilograms.
  // static const double kilogramsPerTroyOunce = 0.0311034768;
}

<!-- END FILE: [v0.12.0] lib/src/units/mass/mass_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/mass/mass_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'mass_factors.dart';

/// Represents units of mass.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each mass unit.
/// All conversion factors are pre-calculated in the constructor relative to Kilogram (kg),
/// which is the SI base unit for mass.
enum MassUnit implements Unit<MassUnit> {
  /// Kilogram (kg), the SI base unit of mass.
  kilogram(1, 'kg'),

  /// Hectogram (hg), equal to 0.1 kilograms.
  hectogram(MassFactors.kilogramsPerHectogram, 'hg'),

  /// Decagram (dag), equal to 0.01 kilograms.
  decagram(MassFactors.kilogramsPerDecagram, 'dag'),

  /// Gram (g), equal to 0.001 kilograms.
  gram(MassFactors.kilogramsPerGram, 'g'),

  /// Decigram (dg), equal to 0.0001 kilograms.
  decigram(MassFactors.kilogramsPerDecigram, 'dg'),

  /// Centigram (cg), equal to 0.00001 kilograms.
  centigram(MassFactors.kilogramsPerCentigram, 'cg'),

  /// Milligram (mg), equal to 0.000001 kilograms (or 0.001 grams).
  milligram(MassFactors.kilogramsPerMilligram, 'mg'),

  /// Microgram (μg), equal to 1e-9 kilograms.
  microgram(MassFactors.kilogramsPerMicrogram, 'μg'),

  /// Nanogram (ng), equal to 1e-12 kilograms.
  nanogram(MassFactors.kilogramsPerNanogram, 'ng'),

  /// Megagram (Mg), equal to 1000 kilograms. It is equivalent to a metric ton (tonne).
  megagram(MassFactors.kilogramsPerMegagram, 'Mg'),

  /// Gigagram (Gg), equal to 1e6 kilograms.
  gigagram(MassFactors.kilogramsPerGigagram, 'Gg'),

  /// Tonne (metric ton) (t), equal to 1000 kilograms.
  tonne(MassFactors.kilogramsPerTonne, 't'),

  /// Pound (lb), an avoirdupois pound, defined as exactly 0.45359237 kilograms.
  pound(MassFactors.kilogramsPerPound, 'lb'),

  /// Ounce (oz), an avoirdupois ounce, defined as 1/16 of an avoirdupois pound.
  ounce(MassFactors.kilogramsPerOunce, 'oz'),

  /// Stone (st), a unit of weight in the imperial system, equal to 14 pounds.
  stone(MassFactors.kilogramsPerStone, 'st'),

  /// Slug, a unit of mass in the British Imperial and US customary systems,
  /// defined as the mass that accelerates by 1 ft/s² when a force of one pound-force (lbf) is exerted on it.
  /// 1 slug ≈ 14.59390 kilograms.
  slug(MassFactors.kilogramsPerSlug, 'slug'),

  /// Short Ton (US), equal to 2000 pounds or approximately 907.18474 kilograms.
  shortTon(MassFactors.kilogramsPerShortTon, 'short ton'),

  /// Long Ton (UK), equal to 2240 pounds or approximately 1016.0469088 kilograms.
  longTon(MassFactors.kilogramsPerLongTon, 'long ton'),

  /// Atomic Mass Unit (u), approximately 1.66053906660e-27 kilograms.
  /// Used for expressing atomic and molecular masses.
  atomicMassUnit(MassFactors.kilogramsPerAtomicMassUnit, 'u'),

  /// Carat (ct), equal to exactly 0.0002 kilograms (200 milligrams).
  /// Used for measuring the mass of gemstones and pearls.
  carat(MassFactors.kilogramsPerCarat, 'ct');

  /// Constant constructor for enum members.
  ///
  /// [_toKilogramFactor] is the factor to convert from this unit to the base unit (Kilogram).
  /// For Kilogram itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `MassUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used,
  /// where the base unit is Kilogram.
  const MassUnit(double toKilogramFactor, this.symbol)
      : _toKilogramFactor = toKilogramFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToKilogram = toKilogramFactor / 1.0, // Base unit factor for kilogram is 1.0
        _factorToHectogram = toKilogramFactor / MassFactors.kilogramsPerHectogram,
        _factorToDecagram = toKilogramFactor / MassFactors.kilogramsPerDecagram,
        _factorToGram = toKilogramFactor / MassFactors.kilogramsPerGram,
        _factorToDecigram = toKilogramFactor / MassFactors.kilogramsPerDecigram,
        _factorToCentigram = toKilogramFactor / MassFactors.kilogramsPerCentigram,
        _factorToMilligram = toKilogramFactor / MassFactors.kilogramsPerMilligram,
        _factorToMicrogram = toKilogramFactor / MassFactors.kilogramsPerMicrogram,
        _factorToNanogram = toKilogramFactor / MassFactors.kilogramsPerNanogram,
        _factorToMegagram = toKilogramFactor / MassFactors.kilogramsPerMegagram,
        _factorToGigagram = toKilogramFactor / MassFactors.kilogramsPerGigagram,
        _factorToTonne = toKilogramFactor / MassFactors.kilogramsPerTonne,
        _factorToPound = toKilogramFactor / MassFactors.kilogramsPerPound,
        _factorToOunce = toKilogramFactor / MassFactors.kilogramsPerOunce,
        _factorToStone = toKilogramFactor / MassFactors.kilogramsPerStone,
        _factorToSlug = toKilogramFactor / MassFactors.kilogramsPerSlug,
        _factorToShortTon = toKilogramFactor / MassFactors.kilogramsPerShortTon,
        _factorToLongTon = toKilogramFactor / MassFactors.kilogramsPerLongTon,
        _factorToAtomicMassUnit = toKilogramFactor / MassFactors.kilogramsPerAtomicMassUnit,
        _factorToCarat = toKilogramFactor / MassFactors.kilogramsPerCarat;

  /// The factor to convert a value from this unit to the base unit (Kilogram).
  /// Example: For Gram, this is 0.001 (meaning 1 g = 0.001 kg).
  // ignore: unused_field
  final double _toKilogramFactor;

  /// The human-readable symbol for this mass unit (e.g., "kg", "g", "lb").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToKilogram;
  final double _factorToHectogram;
  final double _factorToDecagram;
  final double _factorToGram;
  final double _factorToDecigram;
  final double _factorToCentigram;
  final double _factorToMilligram;
  final double _factorToMicrogram;
  final double _factorToNanogram;
  final double _factorToMegagram;
  final double _factorToGigagram;
  final double _factorToTonne;
  final double _factorToPound;
  final double _factorToOunce;
  final double _factorToStone;
  final double _factorToSlug;
  final double _factorToShortTon;
  final double _factorToLongTon;
  final double _factorToAtomicMassUnit;
  final double _factorToCarat;

  /// Returns the direct conversion factor to convert a value from this [MassUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `Mass`
  /// class for conversions.
  @override
  @internal
  double factorTo(MassUnit targetUnit) {
    switch (targetUnit) {
      case MassUnit.kilogram:
        return _factorToKilogram;
      case MassUnit.hectogram:
        return _factorToHectogram;
      case MassUnit.decagram:
        return _factorToDecagram;
      case MassUnit.gram:
        return _factorToGram;
      case MassUnit.decigram:
        return _factorToDecigram;
      case MassUnit.centigram:
        return _factorToCentigram;
      case MassUnit.milligram:
        return _factorToMilligram;
      case MassUnit.microgram:
        return _factorToMicrogram;
      case MassUnit.nanogram:
        return _factorToNanogram;
      case MassUnit.megagram:
        return _factorToMegagram;
      case MassUnit.gigagram:
        return _factorToGigagram;
      case MassUnit.tonne:
        return _factorToTonne;
      case MassUnit.pound:
        return _factorToPound;
      case MassUnit.ounce:
        return _factorToOunce;
      case MassUnit.stone:
        return _factorToStone;
      case MassUnit.slug:
        return _factorToSlug;
      case MassUnit.shortTon:
        return _factorToShortTon;
      case MassUnit.longTon:
        return _factorToLongTon;
      case MassUnit.atomicMassUnit:
        return _factorToAtomicMassUnit;
      case MassUnit.carat:
        return _factorToCarat;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/mass/mass_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/molar/molar_amount.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'molar_unit.dart';

/// Represents a quantity of amount of substance, typically measured in moles.
///
/// The amount of substance is a measure of the number of elementary entities
/// (such as atoms, molecules, ions, or electrons) in a sample. The SI base unit
/// for amount of substance is the Mole (mol).
///
/// This class provides a type-safe way to handle molar amount values and
/// conversions between different units (e.g., moles, millimoles, kilomoles).
/// It is fundamental in chemistry and related fields.
@immutable
class MolarAmount extends Quantity<MolarUnit> {
  /// Creates a new `MolarAmount` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final glucoseSample = MolarAmount(0.5, MolarUnit.mole);
  /// final reagentAmount = MolarAmount(25.0, MolarUnit.millimole);
  /// ```
  const MolarAmount(super.value, super.unit);

  /// Converts this molar amount's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `MolarUnit`
  /// enum for efficiency, involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final substanceInMoles = MolarAmount(0.05, MolarUnit.mole);
  /// final valueInMillimoles = substanceInMoles.getValue(MolarUnit.millimole); // 50.0
  /// ```
  @override
  double getValue(MolarUnit targetUnit) {
    // If the target unit is the same as the current unit, no conversion is needed.
    if (targetUnit == unit) return value;
    // Otherwise, multiply by the direct conversion factor.
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [MolarAmount] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `MolarAmount` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final amountInMillimoles = MolarAmount(1500.0, MolarUnit.millimole);
  /// final amountInMolesObj = amountInMillimoles.convertTo(MolarUnit.mole);
  /// // amountInMolesObj is MolarAmount(1.5, MolarUnit.mole)
  /// print(amountInMolesObj); // Output: "1.5 mol" (depending on toString formatting)
  /// ```
  @override
  MolarAmount convertTo(MolarUnit targetUnit) {
    // If the target unit is the same, return this instance (immutable optimization).
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return MolarAmount(newValue, targetUnit);
  }

  /// Compares this [MolarAmount] object to another [Quantity<MolarUnit>].
  ///
  /// Comparison is based on the physical magnitude of the amounts of substance.
  /// For an accurate comparison, this molar amount's value is converted to the unit
  /// of the [other] molar amount before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this molar amount is less than [other].
  /// - Zero if this molar amount is equal in magnitude to [other].
  /// - A positive integer if this molar amount is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final ma1 = MolarAmount(1.0, MolarUnit.mole);      // 1000 mmol
  /// final ma2 = MolarAmount(1000.0, MolarUnit.millimole); // 1000 mmol
  /// final ma3 = MolarAmount(0.5, MolarUnit.mole);     // 500 mmol
  ///
  /// print(ma1.compareTo(ma2)); // 0 (equal magnitude)
  /// print(ma1.compareTo(ma3)); // 1 (ma1 > ma3)
  /// print(ma3.compareTo(ma1)); // -1 (ma3 < ma1)
  /// ```
  @override
  int compareTo(Quantity<MolarUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison of their magnitudes.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this molar amount to another molar amount.
  ///
  /// The [other] molar amount is converted to the unit of this molar amount before addition.
  /// The result is a new [MolarAmount] instance with the sum, expressed in the unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final reagentA = MolarAmount(0.2, MolarUnit.mole);
  /// final reagentB = MolarAmount(150.0, MolarUnit.millimole); // 0.15 mol
  /// final totalAmount = reagentA + reagentB; // Result: MolarAmount(0.35, MolarUnit.mole)
  /// ```
  MolarAmount operator +(MolarAmount other) {
    final otherValueInThisUnit = other.getValue(unit);
    return MolarAmount(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another molar amount from this molar amount.
  ///
  /// The [other] molar amount is converted to the unit of this molar amount before subtraction.
  /// The result is a new [MolarAmount] instance with the difference, expressed in the unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final initialAmount = MolarAmount(1.0, MolarUnit.mole);
  /// final amountUsed = MolarAmount(250.0, MolarUnit.millimole); // 0.25 mol
  /// final remainingAmount = initialAmount - amountUsed; // Result: MolarAmount(0.75, MolarUnit.mole)
  /// ```
  MolarAmount operator -(MolarAmount other) {
    final otherValueInThisUnit = other.getValue(unit);
    return MolarAmount(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this molar amount by a scalar value (a dimensionless number).
  ///
  /// Returns a new [MolarAmount] instance with the scaled value, in the original unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final singleReactionAmount = MolarAmount(0.05, MolarUnit.mole);
  /// final amountForTenReactions = singleReactionAmount * 10.0; // Result: MolarAmount(0.5, MolarUnit.mole)
  /// ```
  MolarAmount operator *(double scalar) {
    return MolarAmount(value * scalar, unit);
  }

  /// Divides this molar amount by a scalar value (a dimensionless number).
  ///
  /// Returns a new [MolarAmount] instance with the scaled value, in the original unit of this molar amount.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalStock = MolarAmount(2.0, MolarUnit.mole);
  /// final amountPerAliquot = totalStock / 20.0; // Result: MolarAmount(0.1, MolarUnit.mole)
  /// ```
  MolarAmount operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return MolarAmount(value / scalar, unit);
  }

  // Potential future enhancements for MolarAmount:
  // - MolarAmount / Volume = MolarConcentration (would require Volume and MolarConcentration types)
  // - Mass / MolarAmount = MolarMass (would require Mass and MolarMass types or a way to handle compound units)
}

<!-- END FILE: [v0.12.0] lib/src/units/molar/molar_amount.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/molar/molar_extensions.dart -->
import 'molar_amount.dart';
import 'molar_unit.dart';

/// Provides convenient access to [MolarAmount] values in specific units
/// using getter properties.
///
/// These getters simplify retrieving the numerical value of a molar amount
/// in a desired unit without explicitly calling `getValue()`.
extension MolarAmountValueGetters on MolarAmount {
  /// Returns the molar amount value in Moles (mol).
  double get inMoles => getValue(MolarUnit.mole);

  /// Returns the molar amount value in Millimoles (mmol).
  double get inMillimoles => getValue(MolarUnit.millimole);

  /// Returns the molar amount value in Micromoles (µmol).
  double get inMicromoles => getValue(MolarUnit.micromole);

  /// Returns the molar amount value in Nanomoles (nmol).
  double get inNanomoles => getValue(MolarUnit.nanomole);

  /// Returns the molar amount value in Picomoles (pmol).
  double get inPicomoles => getValue(MolarUnit.picomole);

  /// Returns the molar amount value in Kilomoles (kmol).
  double get inKilomoles => getValue(MolarUnit.kilomole);

  // --- "As" Getters for new MolarAmount objects ---

  /// Returns a new [MolarAmount] object representing this amount in Moles (mol).
  MolarAmount get asMoles => convertTo(MolarUnit.mole);

  /// Returns a new [MolarAmount] object representing this amount in Millimoles (mmol).
  MolarAmount get asMillimoles => convertTo(MolarUnit.millimole);

  /// Returns a new [MolarAmount] object representing this amount in Micromoles (µmol).
  MolarAmount get asMicromoles => convertTo(MolarUnit.micromole);

  /// Returns a new [MolarAmount] object representing this amount in Nanomoles (nmol).
  MolarAmount get asNanomoles => convertTo(MolarUnit.nanomole);

  /// Returns a new [MolarAmount] object representing this amount in Picomoles (pmol).
  MolarAmount get asPicomoles => convertTo(MolarUnit.picomole);

  /// Returns a new [MolarAmount] object representing this amount in Kilomoles (kmol).
  MolarAmount get asKilomoles => convertTo(MolarUnit.kilomole);
}

/// Provides convenient factory methods for creating [MolarAmount] instances from [num]
/// using getter properties named after common unit symbols or names.
///
/// This allows for an intuitive and concise way to create molar amount quantities,
/// for example: `0.5.mol` or `25.millimoles`.
extension MolarAmountCreation on num {
  /// Creates a [MolarAmount] instance representing this numerical value in Moles (mol).
  MolarAmount get mol => MolarAmount(toDouble(), MolarUnit.mole);

  /// Creates a [MolarAmount] instance representing this numerical value in Moles (mol).
  /// Alias for `mol`.
  MolarAmount get moles => MolarAmount(toDouble(), MolarUnit.mole);

  /// Creates a [MolarAmount] instance representing this numerical value in Millimoles (mmol).
  MolarAmount get mmol => MolarAmount(toDouble(), MolarUnit.millimole);

  /// Creates a [MolarAmount] instance representing this numerical value in Millimoles (mmol).
  /// Alias for `mmol`.
  MolarAmount get millimoles => MolarAmount(toDouble(), MolarUnit.millimole);

  /// Creates a [MolarAmount] instance representing this numerical value in Micromoles (µmol).
  MolarAmount get umol => MolarAmount(toDouble(), MolarUnit.micromole); // Using 'u' for micro

  /// Creates a [MolarAmount] instance representing this numerical value in Micromoles (µmol).
  /// Alias for `umol`.
  MolarAmount get micromoles => MolarAmount(toDouble(), MolarUnit.micromole);

  /// Creates a [MolarAmount] instance representing this numerical value in Nanomoles (nmol).
  MolarAmount get nmol => MolarAmount(toDouble(), MolarUnit.nanomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Nanomoles (nmol).
  /// Alias for `nmol`.
  MolarAmount get nanomoles => MolarAmount(toDouble(), MolarUnit.nanomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Picomoles (pmol).
  MolarAmount get pmol => MolarAmount(toDouble(), MolarUnit.picomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Picomoles (pmol).
  /// Alias for `pmol`.
  MolarAmount get picomoles => MolarAmount(toDouble(), MolarUnit.picomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Kilomoles (kmol).
  MolarAmount get kmol => MolarAmount(toDouble(), MolarUnit.kilomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Kilomoles (kmol).
  /// Alias for `kmol`.
  MolarAmount get kilomoles => MolarAmount(toDouble(), MolarUnit.kilomole);
}
// END FILE: lib/src/units/molar/molar_extensions.dart

<!-- END FILE: [v0.12.0] lib/src/units/molar/molar_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/molar/molar_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

/// Defines base conversion factors for various molar amount units relative to the Mole (mol),
/// which is the SI base unit for amount of substance.
///
/// These constants represent: `1 [Unit] = Z [Moles]`.
/// So, `molesPerMillimole` means `1 millimole = molesPerMillimole moles`.
class MolarFactors {
  // --- SI Prefixed Units (relative to Mole) ---

  /// Moles per Millimole: 1 millimole (mmol) = 0.001 moles (mol).
  static const double molesPerMillimole = 0.001;

  /// Moles per Micromole: 1 micromole (µmol) = 0.000001 moles (mol).
  static const double molesPerMicromole = 0.000001;

  /// Moles per Nanomole: 1 nanomole (nmol) = 1e-9 moles (mol).
  static const double molesPerNanomole = 1.0e-9;

  /// Moles per Picomole: 1 picomole (pmol) = 1e-12 moles (mol).
  static const double molesPerPicomole = 1.0e-12;

  /// Moles per Kilomole: 1 kilomole (kmol) = 1000 moles (mol).
  static const double molesPerKilomole = 1000.0;

  // --- Other potential units (less common for direct amount of substance,
  //      but could be relevant in specific contexts or conversions) ---

  // Example: Pound-mole (lb-mol) - an imperial unit occasionally used in chemical engineering.
  // 1 lb-mol is the amount of a substance whose mass in pounds is numerically equal
  // to its molar mass in g/mol.
  // 1 lb-mol ≈ 453.59237 mol (since 1 lb ≈ 453.59237 g)
  // static const double molesPerPoundMole = 453.592370000104; // Derived from lb to g conversion.
  // Using a more direct reference or if precision is critical, this might need verification.
  // For now, focusing on SI prefixed units.
}

<!-- END FILE: [v0.12.0] lib/src/units/molar/molar_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/molar/molar_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'molar_factors.dart';

/// Represents units for amount of substance (molar amount).
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each molar amount unit.
/// All conversion factors are pre-calculated in the constructor relative to Mole (mol),
/// which is the SI base unit for amount of substance.
enum MolarUnit implements Unit<MolarUnit> {
  /// Mole (mol), the SI base unit for amount of substance.
  /// One mole contains exactly 6.02214076 × 10²³ elementary entities (Avogadro's number).
  mole(1, 'mol'),

  /// Millimole (mmol), equal to 0.001 moles.
  millimole(MolarFactors.molesPerMillimole, 'mmol'),

  /// Micromole (µmol), equal to 1e-6 moles.
  micromole(MolarFactors.molesPerMicromole, 'µmol'),

  /// Nanomole (nmol), equal to 1e-9 moles.
  nanomole(MolarFactors.molesPerNanomole, 'nmol'),

  /// Picomole (pmol), equal to 1e-12 moles.
  picomole(MolarFactors.molesPerPicomole, 'pmol'),

  /// Kilomole (kmol), equal to 1000 moles.
  kilomole(MolarFactors.molesPerKilomole, 'kmol');

  // If pound-mole were to be added:
  // /// Pound-mole (lb-mol), an imperial unit for amount of substance.
  // /// 1 lb-mol ≈ 453.59237 mol.
  // poundMole(MolarFactors.molesPerPoundMole, 'lb-mol');

  /// Constant constructor for enum members.
  ///
  /// [_toMoleFactor] is the factor to convert from this unit to the base unit (Mole).
  /// For Mole itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `MolarUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used,
  /// where the base unit is Mole.
  const MolarUnit(double toMoleFactor, this.symbol)
      : _toMoleFactor = toMoleFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToMole = toMoleFactor / 1.0, // Base unit factor for mole is 1.0
        _factorToMillimole = toMoleFactor / MolarFactors.molesPerMillimole,
        _factorToMicromole = toMoleFactor / MolarFactors.molesPerMicromole,
        _factorToNanomole = toMoleFactor / MolarFactors.molesPerNanomole,
        _factorToPicomole = toMoleFactor / MolarFactors.molesPerPicomole,
        _factorToKilomole = toMoleFactor / MolarFactors.molesPerKilomole;
  // If poundMole were added:
  // _factorToPoundMole = toMoleFactor / MolarFactors.molesPerPoundMole;

  /// The factor to convert a value from this unit to the base unit (Mole).
  /// Example: For Millimole, this is 0.001 (meaning 1 mmol = 0.001 mol).
  /// This field is primarily used internally by the constructor to derive
  /// direct inter-unit conversion factors.
  // ignore: unused_field
  final double _toMoleFactor;

  /// The human-readable symbol for this molar amount unit (e.g., "mol", "mmol").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  // These are calculated once in the const constructor for performance.

  final double _factorToMole;
  final double _factorToMillimole;
  final double _factorToMicromole;
  final double _factorToNanomole;
  final double _factorToPicomole;
  final double _factorToKilomole;
  // If poundMole were added:
  // final double _factorToPoundMole;

  /// Returns the direct conversion factor to convert a value from this [MolarUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `MolarAmount`
  /// class for conversions.
  ///
  /// Example: `MolarUnit.millimole.factorTo(MolarUnit.mole)` would return `0.001`.
  /// `MolarUnit.mole.factorTo(MolarUnit.millimole)` would return `1000.0`.
  ///
  /// - [targetUnit]: The `MolarUnit` to which a value should be converted.
  ///
  /// Returns the multiplication factor.
  @override
  @internal
  double factorTo(MolarUnit targetUnit) {
    switch (targetUnit) {
      case MolarUnit.mole:
        return _factorToMole;
      case MolarUnit.millimole:
        return _factorToMillimole;
      case MolarUnit.micromole:
        return _factorToMicromole;
      case MolarUnit.nanomole:
        return _factorToNanomole;
      case MolarUnit.picomole:
        return _factorToPicomole;
      case MolarUnit.kilomole:
        return _factorToKilomole;
      // If poundMole were added:
      // case MolarUnit.poundMole:
      //   return _factorToPoundMole;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/molar/molar_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/power/power.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'power_unit.dart';

/// Represents a quantity of power.
///
/// Power is the rate at which energy is transferred or work is done.
/// The SI derived unit for power is the Watt (W), defined as one Joule per second.
/// This class provides a type-safe way to handle power values and conversions
/// between different units (e.g., watts, horsepower, Btu/h).
@immutable
class Power extends Quantity<PowerUnit> {
  /// Creates a new `Power` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final lightBulbPower = Power(60.0, PowerUnit.watt);
  /// final carEnginePower = Power(150.0, PowerUnit.horsepower);
  /// final nuclearPlantOutput = Power(1.2, PowerUnit.gigawatt);
  /// ```
  const Power(super.value, super.unit);

  /// Converts this power's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `PowerUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final enginePowerHp = Power(200.0, PowerUnit.horsepower);
  /// final valueInKw = enginePowerHp.getValue(PowerUnit.kilowatt); // approx. 149.14
  /// ```
  @override
  double getValue(PowerUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Power] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Power` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final powerInWatts = Power(75000.0, PowerUnit.watt);
  /// final powerInHpObj = powerInWatts.convertTo(PowerUnit.horsepower);
  /// // powerInHpObj is Energy(approx. 100.57, PowerUnit.horsepower)
  /// print(powerInHpObj);
  /// ```
  @override
  Power convertTo(PowerUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Power(newValue, targetUnit);
  }

  /// Compares this [Power] object to another [Quantity<PowerUnit>].
  ///
  /// Comparison is based on the physical magnitude of the powers. For an
  /// accurate comparison, this power's value is converted to the unit of the
  /// [other] power before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this power is less than [other].
  /// - Zero if this power is equal in magnitude to [other].
  /// - A positive integer if this power is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final p1 = Power(1.0, PowerUnit.kilowatt);    // 1000 W
  /// final p2 = Power(1000.0, PowerUnit.watt);      // 1000 W
  /// final p3 = Power(1.0, PowerUnit.horsepower);   // ~745.7 W
  ///
  /// print(p1.compareTo(p2)); // 0 (equal magnitude)
  /// print(p1.compareTo(p3)); // 1 (p1 > p3)
  /// ```
  @override
  int compareTo(Quantity<PowerUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this power to another power.
  ///
  /// The [other] power is converted to the unit of this power before addition.
  /// The result is a new [Power] instance with the sum, expressed in the unit
  /// of this power (the left-hand operand).
  Power operator +(Power other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Power(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another power from this power.
  ///
  /// The [other] power is converted to the unit of this power before subtraction.
  /// The result is a new [Power] instance with the difference, expressed in the
  /// unit of this power (the left-hand operand).
  Power operator -(Power other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Power(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this power by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Power] instance with the scaled value, in the original
  /// unit of this power.
  Power operator *(double scalar) {
    return Power(value * scalar, unit);
  }

  /// Divides this power by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Power] instance with the scaled value, in the original
  /// unit of this power. Throws [ArgumentError] if the [scalar] is zero.
  Power operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Power(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/power/power.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/power/power_extensions.dart -->
// lib/src/units/power/power_extensions.dart

import 'power.dart';
import 'power_unit.dart';

/// Provides convenient access to [Power] values in specific units
/// using getter properties.
extension PowerValueGetters on Power {
  // --- SI Units ---
  /// Returns the power value in Watts (W).
  double get inWatts => getValue(PowerUnit.watt);

  /// Returns the power value in Milliwatts (mW).
  double get inMilliwatts => getValue(PowerUnit.milliwatt);

  /// Returns the power value in Kilowatts (kW).
  double get inKilowatts => getValue(PowerUnit.kilowatt);

  /// Returns the power value in Megawatts (MW).
  double get inMegawatts => getValue(PowerUnit.megawatt);

  /// Returns the power value in Gigawatts (GW).
  double get inGigawatts => getValue(PowerUnit.gigawatt);

  // --- Engineering / Common Units ---
  /// Returns the power value in mechanical Horsepower (hp).
  double get inHorsepower => getValue(PowerUnit.horsepower);

  /// Returns the power value in metric Horsepower (PS).
  double get inMetricHorsepower => getValue(PowerUnit.metricHorsepower);

  /// Returns the power value in British Thermal Units per hour (Btu/h).
  double get inBtuPerHour => getValue(PowerUnit.btuPerHour);

  // --- CGS Units ---
  /// Returns the power value in Ergs per second (erg/s).
  double get inErgPerSecond => getValue(PowerUnit.ergPerSecond);

  // --- "As" Getters for new Power objects ---

  /// Returns a new [Power] object representing this power in Watts (W).
  Power get asWatts => convertTo(PowerUnit.watt);

  /// Returns a new [Power] object representing this power in Milliwatts (mW).
  Power get asMilliwatts => convertTo(PowerUnit.milliwatt);

  /// Returns a new [Power] object representing this power in Kilowatts (kW).
  Power get asKilowatts => convertTo(PowerUnit.kilowatt);

  /// Returns a new [Power] object representing this power in Megawatts (MW).
  Power get asMegawatts => convertTo(PowerUnit.megawatt);

  /// Returns a new [Power] object representing this power in Gigawatts (GW).
  Power get asGigawatts => convertTo(PowerUnit.gigawatt);

  /// Returns a new [Power] object representing this power in mechanical Horsepower (hp).
  Power get asHorsepower => convertTo(PowerUnit.horsepower);

  /// Returns a new [Power] object representing this power in metric Horsepower (PS).
  Power get asMetricHorsepower => convertTo(PowerUnit.metricHorsepower);

  /// Returns a new [Power] object representing this power in British Thermal Units per hour (Btu/h).
  Power get asBtuPerHour => convertTo(PowerUnit.btuPerHour);

  /// Returns a new [Power] object representing this power in Ergs per second (erg/s).
  Power get asErgPerSecond => convertTo(PowerUnit.ergPerSecond);
}

/// Provides convenient factory methods for creating [Power] instances from [num].
extension PowerCreation on num {
  // --- SI Units ---
  /// Creates a [Power] instance from this value in Watts (W).
  Power get W => Power(toDouble(), PowerUnit.watt);

  /// Creates a [Power] instance from this value in Watts (W).
  Power get watts => Power(toDouble(), PowerUnit.watt);

  /// Creates a [Power] instance from this value in Milliwatts (mW).
  Power get mW => Power(toDouble(), PowerUnit.milliwatt);

  /// Creates a [Power] instance from this value in Milliwatts (mW).
  Power get milliwatts => Power(toDouble(), PowerUnit.milliwatt);

  /// Creates a [Power] instance from this value in Kilowatts (kW).
  Power get kW => Power(toDouble(), PowerUnit.kilowatt);

  /// Creates a [Power] instance from this value in Kilowatts (kW).
  Power get kilowatts => Power(toDouble(), PowerUnit.kilowatt);

  /// Creates a [Power] instance from this value in Megawatts (MW).
  Power get megaW => Power(toDouble(), PowerUnit.megawatt);

  /// Creates a [Power] instance from this value in Megawatts (MW).
  Power get megawatts => Power(toDouble(), PowerUnit.megawatt);

  /// Creates a [Power] instance from this value in Gigawatts (GW).
  Power get gigaW => Power(toDouble(), PowerUnit.gigawatt);

  /// Creates a [Power] instance from this value in Gigawatts (GW).
  Power get gigawatts => Power(toDouble(), PowerUnit.gigawatt);

  // --- Engineering / Common Units ---

  /// Creates a [Power] instance from this value in mechanical Horsepower (hp).
  Power get hp => Power(toDouble(), PowerUnit.horsepower);

  /// Creates a [Power] instance from this value in metric Horsepower (PS).
  Power get metricHp => Power(toDouble(), PowerUnit.metricHorsepower);

  /// Creates a [Power] instance from this value in British Thermal Units per hour (Btu/h).
  Power get btuPerHour => Power(toDouble(), PowerUnit.btuPerHour);

  // --- CGS Units ---

  /// Creates a [Power] instance from this value in Ergs per second (erg/s).
  Power get ergPerSecond => Power(toDouble(), PowerUnit.ergPerSecond);
}

<!-- END FILE: [v0.12.0] lib/src/units/power/power_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/power/power_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various power units relative to the
/// Watt (W), which is the SI derived unit for power (J/s).
///
/// These constants represent the value of `1 [Unit]` in Watts.
class PowerFactors {
  // --- SI Prefixed Units (relative to Watt) ---

  /// Watts per Gigawatt: 1 GW = 1,000,000,000 W.
  static const double wattsPerGigawatt = 1e9;

  /// Watts per Megawatt: 1 MW = 1,000,000 W.
  static const double wattsPerMegawatt = 1e6;

  /// Watts per Kilowatt: 1 kW = 1,000 W.
  static const double wattsPerKilowatt = 1000.0;

  /// Watts per Milliwatt: 1 mW = 0.001 W.
  static const double wattsPerMilliwatt = 0.001;

  // --- CGS Units ---

  /// Watts per Erg per second: 1 erg/s = 10⁻⁷ W.
  /// The erg is the CGS unit of energy, so 1 erg/s is the CGS unit of power.
  static const double wattsPerErgPerSecond = 1e-7;

  // --- Common and Engineering Units ---

  /// Watts per mechanical Horsepower (hp): 1 hp = 745.69987158227022 W.
  /// This is the exact definition of mechanical horsepower, equivalent to
  /// 550 ft⋅lbf/s. It is commonly used for rating engines and motors.
  static const double wattsPerHorsepower = 745.69987158227022;

  /// Watts per metric Horsepower (PS): 1 PS = 735.49875 W.
  /// This is defined as the power to raise 75 kilograms by 1 meter in 1 second
  /// under standard gravity (75 kgf·m/s).
  static const double wattsPerMetricHorsepower = 735.49875;

  /// Watts per British Thermal Unit per hour (Btu/h): 1 Btu/h ≈ 0.293071 W.
  /// Based on the International Table Btu (1055.056 J) divided by 3600 seconds.
  /// Commonly used in the HVAC and heating/cooling industries.
  static const double wattsPerBtuPerHour = 1055.056 / 3600.0;
}

<!-- END FILE: [v0.12.0] lib/src/units/power/power_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/power/power_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'power_factors.dart';

/// Represents units of power.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each power unit. All conversion factors are
/// pre-calculated in the constructor relative to the Watt (W).
enum PowerUnit implements Unit<PowerUnit> {
  // --- SI Units ---
  /// Watt (W), the SI derived unit of power, equal to one Joule per second.
  watt(1, 'W'),

  /// Milliwatt (mW), a sub-multiple of the Watt, common in electronics.
  milliwatt(PowerFactors.wattsPerMilliwatt, 'mW'),

  /// Kilowatt (kW), a common multiple of the Watt.
  kilowatt(PowerFactors.wattsPerKilowatt, 'kW'),

  /// Megawatt (MW), a common multiple of the Watt, used for large-scale power.
  megawatt(PowerFactors.wattsPerMegawatt, 'MW'),

  /// Gigawatt (GW), a multiple of the Watt, used for large power plants.
  gigawatt(PowerFactors.wattsPerGigawatt, 'GW'),

  // --- Engineering / Common Units ---

  /// Mechanical Horsepower (hp), a common unit for engine and motor power.
  horsepower(PowerFactors.wattsPerHorsepower, 'hp'),

  /// Metric Horsepower (PS), used commonly in the automotive industry.
  metricHorsepower(PowerFactors.wattsPerMetricHorsepower, 'PS'),

  /// British Thermal Unit per hour (Btu/h), common in HVAC.
  btuPerHour(PowerFactors.wattsPerBtuPerHour, 'Btu/h'),

  // --- CGS Units ---

  /// Erg per second (erg/s), the power unit in the CGS system.
  ergPerSecond(PowerFactors.wattsPerErgPerSecond, 'erg/s');

  /// Constant constructor for enum members.
  const PowerUnit(double toWattFactor, this.symbol)
      : _toWattFactor = toWattFactor,
        _factorToWatt = toWattFactor / 1.0,
        _factorToMilliwatt = toWattFactor / PowerFactors.wattsPerMilliwatt,
        _factorToKilowatt = toWattFactor / PowerFactors.wattsPerKilowatt,
        _factorToMegawatt = toWattFactor / PowerFactors.wattsPerMegawatt,
        _factorToGigawatt = toWattFactor / PowerFactors.wattsPerGigawatt,
        _factorToHorsepower = toWattFactor / PowerFactors.wattsPerHorsepower,
        _factorToMetricHorsepower = toWattFactor / PowerFactors.wattsPerMetricHorsepower,
        _factorToBtuPerHour = toWattFactor / PowerFactors.wattsPerBtuPerHour,
        _factorToErgPerSecond = toWattFactor / PowerFactors.wattsPerErgPerSecond;

  /// The factor to convert a value from this unit to the base unit (Watt).
  // ignore: unused_field
  final double _toWattFactor;

  /// The human-readable symbol for this power unit (e.g., "W", "kW", "hp").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToWatt;
  final double _factorToMilliwatt;
  final double _factorToKilowatt;
  final double _factorToMegawatt;
  final double _factorToGigawatt;
  final double _factorToHorsepower;
  final double _factorToMetricHorsepower;
  final double _factorToBtuPerHour;
  final double _factorToErgPerSecond;

  /// Returns the direct conversion factor to convert a value from this [PowerUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(PowerUnit targetUnit) {
    switch (targetUnit) {
      case PowerUnit.watt:
        return _factorToWatt;
      case PowerUnit.milliwatt:
        return _factorToMilliwatt;
      case PowerUnit.kilowatt:
        return _factorToKilowatt;
      case PowerUnit.megawatt:
        return _factorToMegawatt;
      case PowerUnit.gigawatt:
        return _factorToGigawatt;
      case PowerUnit.horsepower:
        return _factorToHorsepower;
      case PowerUnit.metricHorsepower:
        return _factorToMetricHorsepower;
      case PowerUnit.btuPerHour:
        return _factorToBtuPerHour;
      case PowerUnit.ergPerSecond:
        return _factorToErgPerSecond;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/power/power_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/pressure/pressure.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'pressure_unit.dart';

/// Represents a quantity of pressure.
///
/// Pressure is a fundamental physical quantity, defined as force per unit area.
/// This class provides a type-safe way to handle pressure values and conversions
/// between different units of pressure.
@immutable
class Pressure extends Quantity<PressureUnit> {
  /// Creates a new Pressure quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final standardAtmosphere = Pressure(1.0, PressureUnit.atmosphere);
  /// final tirePressure = Pressure(32.0, PressureUnit.psi);
  /// ```
  const Pressure(super.value, super.unit);

  /// Converts this pressure's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors for efficiency,
  /// typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final p_atm = Pressure(1.0, PressureUnit.atmosphere);
  /// final p_pascals = p_atm.getValue(PressureUnit.pascal); // 101325.0
  /// ```
  @override
  double getValue(PressureUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Pressure] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Pressure` object in a different unit
  /// while preserving type safety and quantity semantics.
  ///
  /// Example:
  /// ```dart
  /// final p_bar = Pressure(1.5, PressureUnit.bar);
  /// final p_psi = p_bar.convertTo(PressureUnit.psi);
  /// print(p_psi); // Output: approx "21.7557 psi"
  /// ```
  @override
  Pressure convertTo(PressureUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Pressure(newValue, targetUnit);
  }

  /// Compares this [Pressure] object to another [Quantity<PressureUnit>].
  ///
  /// Comparison is based on the physical magnitude of the pressures.
  /// For comparison, this pressure is converted to the unit of the [other] pressure.
  ///
  /// Returns:
  /// - A negative integer if this pressure is less than [other].
  /// - Zero if this pressure is equal to [other].
  /// - A positive integer if this pressure is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final p1 = Pressure(1.0, PressureUnit.bar);    // 100000 Pa
  /// final p2 = Pressure(1000.0, PressureUnit.millibar); // 100000 Pa
  /// final p3 = Pressure(15.0, PressureUnit.psi);   // approx 103421 Pa
  ///
  /// print(p1.compareTo(p2)); // 0 (equal)
  /// print(p1.compareTo(p3)); // -1 (p1 < p3)
  /// ```
  @override
  int compareTo(Quantity<PressureUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this pressure to another pressure.
  /// The [other] pressure is converted to the unit of this pressure before addition.
  /// Returns a new [Pressure] instance with the result in the unit of this pressure.
  Pressure operator +(Pressure other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Pressure(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another pressure from this pressure.
  /// The [other] pressure is converted to the unit of this pressure before subtraction.
  /// Returns a new [Pressure] instance with the result in the unit of this pressure.
  Pressure operator -(Pressure other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Pressure(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this pressure by a scalar value.
  /// Returns a new [Pressure] instance with the scaled value in the original unit.
  Pressure operator *(double scalar) {
    return Pressure(value * scalar, unit);
  }

  /// Divides this pressure by a scalar value.
  /// Returns a new [Pressure] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Pressure operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Pressure(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/pressure/pressure.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/pressure/pressure_extensions.dart -->
import 'pressure.dart';
import 'pressure_unit.dart';

/// Provides convenient access to [Pressure] values in specific units
/// using shortened unit names where appropriate.
extension PressureValueGetters on Pressure {
  /// Returns the pressure value in Pascals (Pa).
  double get inPa => getValue(PressureUnit.pascal);

  /// Returns the pressure value in Atmospheres (atm).
  double get inAtm => getValue(PressureUnit.atmosphere); // "atm" is already short

  /// Returns the pressure value in Bars (bar).
  double get inBar => getValue(PressureUnit.bar); // "bar" is already short

  /// Returns the pressure value in Pounds per Square Inch (psi).
  double get inPsi => getValue(PressureUnit.psi); // "psi" is already short

  /// Returns the pressure value in Torrs (Torr).
  double get inTorr => getValue(PressureUnit.torr);

  /// Returns the pressure value in Millimeters of Mercury (mmHg).
  double get inMmHg => getValue(PressureUnit.millimeterOfMercury);

  /// Returns the pressure value in Inches of Mercury (inHg).
  double get inInHg => getValue(PressureUnit.inchOfMercury);

  /// Returns the pressure value in Megapascals (MPa).
  double get inMegaPascals => getValue(PressureUnit.megapascal);

  /// Returns the pressure value in Kilopascals (kPa).
  double get inKiloPascals => getValue(PressureUnit.kilopascal);

  /// Returns the pressure value in Kilopascals (kPa).
  double get inKPa => getValue(PressureUnit.kilopascal);

  /// Returns the pressure value in Hectopascals (hPa).
  double get inHPa => getValue(PressureUnit.hectopascal);

  /// Returns the pressure value in Millibars (mbar).
  double get inMbar => getValue(PressureUnit.millibar);

  /// Returns the pressure value in Centimeters of Water (cmH₂O) at 4°C.
  double get inCmH2O => getValue(PressureUnit.centimeterOfWater);

  /// Returns the pressure value in Inches of Water (inH₂O) at 4°C.
  double get inInH2O => getValue(PressureUnit.inchOfWater);

  /// Returns a Pressure representing this pressure in Pascals (Pa).
  Pressure get asPa => convertTo(PressureUnit.pascal);

  /// Returns a Pressure representing this pressure in Atmospheres (atm).
  Pressure get asAtm => convertTo(PressureUnit.atmosphere);

  /// Returns a Pressure representing this pressure in Bars (bar).
  Pressure get asBar => convertTo(PressureUnit.bar);

  /// Returns a Pressure representing this pressure in Pounds per Square Inch (psi).
  Pressure get asPsi => convertTo(PressureUnit.psi);

  /// Returns a Pressure representing this pressure in Torrs (Torr).
  Pressure get asTorr => convertTo(PressureUnit.torr);

  /// Returns a Pressure representing this pressure in Millimeters of Mercury (mmHg).
  Pressure get asMmHg => convertTo(PressureUnit.millimeterOfMercury);

  /// Returns a Pressure representing this pressure in Inches of Mercury (inHg).
  Pressure get asInHg => convertTo(PressureUnit.inchOfMercury);

  /// Returns a Pressure representing this pressure in Megapascals (MPa).
  Pressure get asMegaPascals => convertTo(PressureUnit.megapascal);

  /// Returns a Pressure representing this pressure in Kilopascals (kPa).
  Pressure get asKiloPascals => convertTo(PressureUnit.kilopascal);

  /// Returns a Pressure representing this pressure in Hectopascals (hPa).
  Pressure get asHPa => convertTo(PressureUnit.hectopascal);

  /// Returns a Pressure representing this pressure in Millibars (mbar).
  Pressure get asMbar => convertTo(PressureUnit.millibar);

  /// Returns a Pressure representing this pressure in Centimeters of Water (cmH₂O).
  Pressure get asCmH2O => convertTo(PressureUnit.centimeterOfWater);

  /// Returns a Pressure representing this pressure in Inches of Water (inH₂O).
  Pressure get asInH2O => convertTo(PressureUnit.inchOfWater);
}

/// Provides convenient factory methods for creating [Pressure] instances from [num]
/// using shortened unit names where appropriate.
extension PressureCreation on num {
  /// Creates a [Pressure] instance representing this numerical value in Pascals (Pa).
  Pressure get pa => Pressure(toDouble(), PressureUnit.pascal);

  /// Creates a [Pressure] instance representing this numerical value in Atmospheres (atm).
  Pressure get atm => Pressure(toDouble(), PressureUnit.atmosphere);

  /// Creates a [Pressure] instance representing this numerical value in Bars (bar).
  Pressure get bar => Pressure(toDouble(), PressureUnit.bar);

  /// Creates a [Pressure] instance representing this numerical value in Pounds per Square Inch (psi).
  Pressure get psi => Pressure(toDouble(), PressureUnit.psi);

  /// Creates a [Pressure] instance representing this numerical value in Torrs (Torr).
  Pressure get torr => Pressure(toDouble(), PressureUnit.torr);

  /// Creates a [Pressure] instance representing this numerical value in Millimeters of Mercury (mmHg).
  Pressure get mmHg => Pressure(toDouble(), PressureUnit.millimeterOfMercury);

  /// Creates a [Pressure] instance representing this numerical value in Inches of Mercury (inHg).
  Pressure get inHg => Pressure(toDouble(), PressureUnit.inchOfMercury);

  /// Creates a [Pressure] instance representing this numerical value in Megapascals (MPa).
  Pressure get megaPascals => Pressure(toDouble(), PressureUnit.megapascal);

  /// Creates a [Pressure] instance representing this numerical value in Megapascals (MPa).
  /// Alias for `megaPascals`.
  Pressure get mpa => Pressure(toDouble(), PressureUnit.megapascal);

  /// Creates a [Pressure] instance representing this numerical value in Kilopascals (kPa).
  Pressure get kiloPascals => Pressure(toDouble(), PressureUnit.kilopascal);

  /// Creates a [Pressure] instance representing this numerical value in Kilopascals (kPa).
  /// Alias for `kiloPascals`.
  Pressure get kPa => Pressure(toDouble(), PressureUnit.kilopascal);

  /// Creates a [Pressure] instance representing this numerical value in Hectopascals (hPa).
  Pressure get hPa => Pressure(toDouble(), PressureUnit.hectopascal);

  /// Creates a [Pressure] instance representing this numerical value in Millibars (mbar).
  Pressure get mbar => Pressure(toDouble(), PressureUnit.millibar);

  /// Creates a [Pressure] instance representing this numerical value in Centimeters of Water (cmH₂O) at 4°C.
  Pressure get cmH2O => Pressure(toDouble(), PressureUnit.centimeterOfWater);

  /// Creates a [Pressure] instance representing this numerical value in Inches of Water (inH₂O) at 4°C.
  Pressure get inH2O => Pressure(toDouble(), PressureUnit.inchOfWater);
}

<!-- END FILE: [v0.12.0] lib/src/units/pressure/pressure_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/pressure/pressure_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various pressure units relative to Pascal (Pa).
///
/// These constants are based on international standards (e.g., NIST) where available.
/// The base unit for internal calculations is Pascal.
/// Factors represent: 1 Unit = X Pascals.
/// All water column units (cmH₂O, inH₂O) refer to a water temperature of 4°C (39.2°F)
/// unless otherwise specified, aligning with common scientific reference points for water density
/// and conventional values (e.g., NIST SP 811).
class PressureFactors {
  /// Pascals per Standard Atmosphere (atm): 1 atm = 101325 Pa (exact definition).
  static const double pascalsPerAtmosphere = 101325.0;

  /// Pascals per Bar (bar): 1 bar = 100000 Pa (exact definition).
  static const double pascalsPerBar = 100000.0;

  /// Pascals per Pound per Square Inch (psi): 1 psi ≈ 6894.757293168361 Pa.
  /// Derived from the international yard and pound agreement:
  /// 1 pound-force (lbf) ≈ 4.4482216152605 N and 1 inch = 0.0254 m.
  static const double pascalsPerPsi = 6894.757293168361;

  /// Pascals per Torr (Torr): 1 Torr ≈ 133.322368421 Pa.
  /// Defined as 1/760 of a standard atmosphere. Mercury at 0°C.
  static const double pascalsPerTorr = pascalsPerAtmosphere / 760.0;

  /// Pascals per Millimeter of Mercury (mmHg) at 0°C: Same as Torr.
  /// 1 mmHg (at 0°C) ≈ 133.322368421 Pa.
  static const double pascalsPerMillimeterOfMercury = pascalsPerTorr;

  /// Pascals per Inch of Mercury (inHg) at 0°C: 1 inHg ≈ 3386.388687636 Pa.
  /// Defined as `pascalsPerMillimeterOfMercury * 25.4` (since 1 inch = 25.4 mm).
  /// Conventional value often cited from NIST SP 811 is 3386.389 Pa.
  /// The calculated value is (101325.0 / 760.0) * 25.4 = 3386.3886876315788
  static const double pascalsPerInchOfMercury = pascalsPerMillimeterOfMercury * 25.4;
  // For reference, NIST SP 811 Appendix B.8 lists:
  // Inch of mercury (0 °C)  = 3.386 389 E+03 Pa
  // The calculated value is extremely close and based on fundamental definitions.
  // Using the calculated one for consistency, the difference is negligible for doubles.

  /// Pascals per Megapascal (MPa): 1 MPa = 1,000,000 Pa.
  static const double pascalsPerMegapascal = 1000000.0;

  /// Pascals per Kilopascal (kPa): 1 kPa = 1000 Pa.
  static const double pascalsPerKilopascal = 1000.0;

  /// Pascals per Hectopascal (hPa): 1 hPa = 100 Pa.
  static const double pascalsPerHectopascal = 100.0;

  /// Pascals per Millibar (mbar): 1 mbar = 100 Pa (same as hPa).
  static const double pascalsPerMillibar = 100.0;

  /// Conventional value for Pascals per Centimeter of Water (cmH₂O) at 4°C.
  /// 1 cmH₂O (at 4°C) = 98.0665 Pa.
  /// This value is commonly cited, e.g., in NIST SP 811, based on a conventional
  /// standard gravity (gₙ = 9.80665 m/s²) and water density of 1000 kg/m³ at 4°C.
  static const double conventionalPascalsPerCentimeterOfWater4C = 98.0665;

  /// Conventional value for Pascals per Inch of Water (inH₂O) at 4°C.
  /// 1 inH₂O (at 4°C) = 249.08891 Pa.
  /// This value is commonly cited, e.g., in NIST SP 811, and is derived from
  /// `conventionalPascalsPerCentimeterOfWater4C * 2.54` (since 1 inch = 2.54 cm).
  static const double conventionalPascalsPerInchOfWater4C = 249.08891;
}

<!-- END FILE: [v0.12.0] lib/src/units/pressure/pressure_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/pressure/pressure_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'pressure_factors.dart';

/// Represents units of pressure.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each pressure unit.
/// All conversion factors are pre-calculated in the constructor relative to Pascal (Pa).
enum PressureUnit implements Unit<PressureUnit> {
  /// Pascal (Pa), the SI derived unit of pressure.
  pascal(1, 'Pa'),

  /// Atmosphere (atm), standard atmosphere.
  atmosphere(PressureFactors.pascalsPerAtmosphere, 'atm'),

  /// Bar (bar).
  bar(PressureFactors.pascalsPerBar, 'bar'),

  /// Pound per square inch (psi).
  psi(PressureFactors.pascalsPerPsi, 'psi'),

  /// Torr (Torr), approximately 1 mmHg.
  torr(PressureFactors.pascalsPerTorr, 'Torr'),

  /// Millimeter of mercury (mmHg) at 0°C.
  millimeterOfMercury(PressureFactors.pascalsPerMillimeterOfMercury, 'mmHg'),

  /// Inch of mercury (inHg) at 0°C.
  inchOfMercury(PressureFactors.pascalsPerInchOfMercury, 'inHg'),

  /// Megapascal (MPa).
  megapascal(PressureFactors.pascalsPerMegapascal, 'MPa'),

  /// Kilopascal (kPa).
  kilopascal(PressureFactors.pascalsPerKilopascal, 'kPa'),

  /// Hectopascal (hPa).
  hectopascal(PressureFactors.pascalsPerHectopascal, 'hPa'),

  /// Millibar (mbar), equivalent to hectopascal.
  millibar(PressureFactors.pascalsPerMillibar, 'mbar'),

  /// Centimeter of water (cmH₂O) at 4°C.
  centimeterOfWater(PressureFactors.conventionalPascalsPerCentimeterOfWater4C, 'cmH₂O'),

  /// Inch of water (inH₂O) at 4°C.
  inchOfWater(PressureFactors.conventionalPascalsPerInchOfWater4C, 'inH₂O');

  /// Constant constructor for enum members.
  ///
  /// [_toPascalFactor] is the factor to convert from this unit to the base unit (Pascal).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `PressureUnit`.
  /// The formula `factor_A_to_B = _toPascalFactor_A / _toPascalFactor_B` is used.
  const PressureUnit(this._toPascalFactor, this.symbol)
      : _factorToPascal = _toPascalFactor / 1.0, // Pascal's _toPascalFactor is 1.0
        _factorToAtmosphere = _toPascalFactor / PressureFactors.pascalsPerAtmosphere,
        _factorToBar = _toPascalFactor / PressureFactors.pascalsPerBar,
        _factorToPsi = _toPascalFactor / PressureFactors.pascalsPerPsi,
        _factorToTorr = _toPascalFactor / PressureFactors.pascalsPerTorr,
        _factorToMillimeterOfMercury =
            _toPascalFactor / PressureFactors.pascalsPerMillimeterOfMercury,
        _factorToInchOfMercury = _toPascalFactor / PressureFactors.pascalsPerInchOfMercury,
        _factorToMegapascal = _toPascalFactor / PressureFactors.pascalsPerMegapascal,
        _factorToKilopascal = _toPascalFactor / PressureFactors.pascalsPerKilopascal,
        _factorToHectopascal = _toPascalFactor / PressureFactors.pascalsPerHectopascal,
        _factorToMillibar = _toPascalFactor / PressureFactors.pascalsPerMillibar,
        _factorToCentimeterOfWater =
            _toPascalFactor / PressureFactors.conventionalPascalsPerCentimeterOfWater4C,
        _factorToInchOfWater =
            _toPascalFactor / PressureFactors.conventionalPascalsPerInchOfWater4C;

  /// The factor to convert a value from this unit to the base unit (Pascal).
  // ignore: unused_field
  final double _toPascalFactor;

  /// The human-readable symbol for this pressure unit (e.g., "Pa", "psi").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToPascal;
  final double _factorToAtmosphere;
  final double _factorToBar;
  final double _factorToPsi;
  final double _factorToTorr;
  final double _factorToMillimeterOfMercury;
  final double _factorToInchOfMercury;
  final double _factorToMegapascal;
  final double _factorToKilopascal;
  final double _factorToHectopascal;
  final double _factorToMillibar;
  final double _factorToCentimeterOfWater;
  final double _factorToInchOfWater;

  /// Returns the direct conversion factor to convert a value from this [PressureUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(PressureUnit targetUnit) {
    switch (targetUnit) {
      case PressureUnit.pascal:
        return _factorToPascal;
      case PressureUnit.atmosphere:
        return _factorToAtmosphere;
      case PressureUnit.bar:
        return _factorToBar;
      case PressureUnit.psi:
        return _factorToPsi;
      case PressureUnit.torr:
        return _factorToTorr;
      case PressureUnit.millimeterOfMercury:
        return _factorToMillimeterOfMercury;
      case PressureUnit.inchOfMercury:
        return _factorToInchOfMercury;
      case PressureUnit.megapascal:
        return _factorToMegapascal;
      case PressureUnit.kilopascal:
        return _factorToKilopascal;
      case PressureUnit.hectopascal:
        return _factorToHectopascal;
      case PressureUnit.millibar:
        return _factorToMillibar;
      case PressureUnit.centimeterOfWater:
        return _factorToCentimeterOfWater;
      case PressureUnit.inchOfWater:
        return _factorToInchOfWater;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/pressure/pressure_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/solid_angle/solid_angle.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'solid_angle_unit.dart';

/// Represents a quantity of solid angle.
///
/// A solid angle is the two-dimensional angle in three-dimensional space that
/// an object subtends at a point. It is a measure of how large the object appears
/// to an observer looking from that point. The SI derived unit is the Steradian (sr).
@immutable
class SolidAngle extends Quantity<SolidAngleUnit> {
  /// Creates a new `SolidAngle` with a given [value] and [unit].
  const SolidAngle(super.value, super.unit);

  // --- Boilerplate ---

  /// Converts this solid angle's value to the specified [targetUnit].
  @override
  double getValue(SolidAngleUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [SolidAngle] instance with the value converted to the [targetUnit].
  @override
  SolidAngle convertTo(SolidAngleUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return SolidAngle(newValue, targetUnit);
  }

  @override
  int compareTo(Quantity<SolidAngleUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this solid angle to another.
  SolidAngle operator +(SolidAngle other) {
    final otherValueInThisUnit = other.getValue(unit);
    return SolidAngle(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another solid angle from this one.
  SolidAngle operator -(SolidAngle other) {
    final otherValueInThisUnit = other.getValue(unit);
    return SolidAngle(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this solid angle by a scalar.
  SolidAngle operator *(double scalar) {
    return SolidAngle(value * scalar, unit);
  }

  /// Divides this solid angle by a scalar.
  SolidAngle operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return SolidAngle(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/solid_angle/solid_angle.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/solid_angle/solid_angle_extensions.dart -->
import 'solid_angle.dart';
import 'solid_angle_unit.dart';

/// Provides convenient access to [SolidAngle] values in specific units.
extension SolidAngleValueGetters on SolidAngle {
  /// Returns the solid angle value in Steradians (sr).
  double get inSteradians => getValue(SolidAngleUnit.steradian);

  /// Returns the solid angle value in Square Degrees (deg²).
  double get inSquareDegrees => getValue(SolidAngleUnit.squareDegree);

  /// Returns the solid angle value in Spat (sp).
  double get inSpat => getValue(SolidAngleUnit.spat);

  /// Returns a new [SolidAngle] object representing this solid angle in Steradians (sr).
  SolidAngle get asSteradians => convertTo(SolidAngleUnit.steradian);

  /// Returns a new [SolidAngle] object representing this solid angle in Square Degrees (deg²).
  SolidAngle get asSquareDegrees => convertTo(SolidAngleUnit.squareDegree);

  /// Returns a new [SolidAngle] object representing this solid angle in Spat (sp).
  SolidAngle get asSpat => convertTo(SolidAngleUnit.spat);
}

/// Provides convenient factory methods for creating [SolidAngle] instances from [num].
extension SolidAngleCreation on num {
  /// Creates a [SolidAngle] instance from this value in Steradians (sr).
  SolidAngle get sr => SolidAngle(toDouble(), SolidAngleUnit.steradian);

  /// Creates a [SolidAngle] instance from this value in Steradians (sr).
  /// Alias for `sr`.
  SolidAngle get steradians => SolidAngle(toDouble(), SolidAngleUnit.steradian);

  /// Creates a [SolidAngle] instance from this value in Square Degrees (deg²).
  ///
  /// Following the pattern of `m2` for square meters.
  SolidAngle get deg2 => SolidAngle(toDouble(), SolidAngleUnit.squareDegree);

  /// Creates a [SolidAngle] instance from this value in Square Degrees (deg²).
  /// Alias for `deg2`.
  SolidAngle get squareDegrees => SolidAngle(toDouble(), SolidAngleUnit.squareDegree);

  /// Creates a [SolidAngle] instance from this value in Spat (sp).
  SolidAngle get sp => SolidAngle(toDouble(), SolidAngleUnit.spat);

  /// Creates a [SolidAngle] instance from this value in Spat (sp).
  /// Alias for `sp`.
  SolidAngle get spats => SolidAngle(toDouble(), SolidAngleUnit.spat);
}

<!-- END FILE: [v0.12.0] lib/src/units/solid_angle/solid_angle_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/solid_angle/solid_angle_factors.dart -->
import 'dart:math' as math;

/// Defines base conversion factors for various solid angle units relative to the
/// Steradian (sr), which is the SI derived unit for solid angle.
///
/// These constants represent: `1 [Unit] = Z [Steradians]`.
class SolidAngleFactors {
  /// Steradians per Square Degree: (π/180)².
  /// This is derived from the conversion of one degree to radians, squared.
  static const double steradiansPerSquareDegree = (math.pi / 180.0) * (math.pi / 180.0);

  /// Steradians per Spat: The solid angle of a full sphere, which is 4π steradians.
  /// A spat is an obsolete unit for a full sphere solid angle.
  static const double steradiansPerSpat = 4 * math.pi;
}

<!-- END FILE: [v0.12.0] lib/src/units/solid_angle/solid_angle_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/solid_angle/solid_angle_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'solid_angle_factors.dart';

/// Represents units of solid angle.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each solid angle unit.
/// All conversion factors are pre-calculated in the constructor relative to
/// Steradian (sr).
enum SolidAngleUnit implements Unit<SolidAngleUnit> {
  /// Steradian (sr), the SI derived unit of solid angle.
  steradian(1, 'sr'),

  /// Square Degree (deg²), a non-SI unit for solid angle.
  squareDegree(SolidAngleFactors.steradiansPerSquareDegree, 'deg²'),

  /// Spat (sp), an obsolete unit for the solid angle of a full sphere (4π sr).
  spat(SolidAngleFactors.steradiansPerSpat, 'sp');

  /// Constant constructor for enum members.
  const SolidAngleUnit(double toSteradianFactor, this.symbol)
      : _toSteradianFactor = toSteradianFactor,
        _factorToSteradian = toSteradianFactor / 1.0,
        _factorToSquareDegree = toSteradianFactor / SolidAngleFactors.steradiansPerSquareDegree,
        _factorToSpat = toSteradianFactor / SolidAngleFactors.steradiansPerSpat;

  // ignore: unused_field // The factor to convert this unit to Steradian (sr).
  final double _toSteradianFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToSteradian;
  final double _factorToSquareDegree;
  final double _factorToSpat;

  @override
  @internal
  double factorTo(SolidAngleUnit targetUnit) {
    switch (targetUnit) {
      case SolidAngleUnit.steradian:
        return _factorToSteradian;
      case SolidAngleUnit.squareDegree:
        return _factorToSquareDegree;
      case SolidAngleUnit.spat:
        return _factorToSpat;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/solid_angle/solid_angle_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/speed/speed.dart -->
import 'package:meta/meta.dart';

import '../../../length.dart';
import '../time/time.dart';
import '../time/time_extensions.dart';
import 'speed_unit.dart';

/// Represents a quantity of speed (or velocity).
///
/// Speed is a derived quantity representing the rate of change of position
/// over time. The SI derived unit is Meter per Second (m/s).
@immutable
class Speed extends Quantity<SpeedUnit> {
  /// Creates a new `Speed` with a given [value] and [unit].
  const Speed(super.value, super.unit);

  /// Creates a `Speed` instance from a `Length` and a `Time`.
  ///
  /// This factory method performs the dimensional calculation `Speed = Length / Time`.
  /// It converts the inputs to their base SI units (meters and seconds) for correctness.
  /// Throws an [ArgumentError] if the `time` is zero.
  ///
  /// Example:
  /// ```dart
  /// final distance = 100.m;
  /// final duration = 10.s;
  /// final speed = Speed.from(distance, duration); // Results in Speed(10.0, SpeedUnit.meterPerSecond)
  /// ```
  factory Speed.from(Length distance, Time time) {
    final meters = distance.inM;
    final seconds = time.inSeconds;
    if (seconds == 0) {
      throw ArgumentError('Time cannot be zero when calculating speed.');
    }
    return Speed(meters / seconds, SpeedUnit.meterPerSecond);
  }

  /// Converts this speed's value to the specified [targetUnit].
  @override
  double getValue(SpeedUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Speed] instance with the value converted to the [targetUnit].
  @override
  Speed convertTo(SpeedUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Speed(newValue, targetUnit);
  }

  /// Compares this [Speed] object to another [Quantity<SpeedUnit>].
  @override
  int compareTo(Quantity<SpeedUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this speed to another.
  Speed operator +(Speed other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Speed(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another speed from this one.
  Speed operator -(Speed other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Speed(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this speed by a scalar.
  Speed operator *(double scalar) {
    return Speed(value * scalar, unit);
  }

  /// Divides this speed by a scalar.
  Speed operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Speed(value / scalar, unit);
  }

  // --- Dimensional Analysis ---

  /// Calculates the total [Length] traveled over a given [Time] duration.
  ///
  /// This method performs the dimensional calculation `Length = Speed × Time`.
  /// The calculation is performed in the base units (m/s and s) to ensure
  /// correctness, and the result is returned as a `Length` in meters.
  ///
  /// Example:
  /// ```dart
  /// final carSpeed = 60.kmh;
  /// final travelTime = 2.h;
  /// final distance = carSpeed.distanceOver(travelTime);
  /// print(distance.inKm); // Output: 120.0
  /// ```
  Length distanceOver(Time duration) {
    final valueInMps = getValue(SpeedUnit.meterPerSecond);
    final timeInSeconds = duration.inSeconds;
    final resultingDistanceInMeters = valueInMps * timeInSeconds;
    return Length(resultingDistanceInMeters, LengthUnit.meter);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/speed/speed.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/speed/speed_extensions.dart -->
import 'speed.dart';
import 'speed_unit.dart';

/// Provides convenient access to [Speed] values in specific units.
extension SpeedValueGetters on Speed {
  /// Returns the speed value in Meters per second (m/s).
  double get inMetersPerSecond => getValue(SpeedUnit.meterPerSecond);

  /// Returns the speed value in Meters per second (m/s).
  /// Alias for `inMetersPerSecond`.
  double get inMps => getValue(SpeedUnit.meterPerSecond);

  /// Returns the speed value in Kilometers per second (km/s).
  double get inKilometersPerSecond => getValue(SpeedUnit.kilometerPerSecond);

  /// Returns the speed value in Kilometers per hour (km/h).
  double get inKilometersPerHour => getValue(SpeedUnit.kilometerPerHour);

  /// Returns the speed value in Kilometers per hour (km/h).
  /// Alias for `inKilometersPerHour`.
  double get inKmh => getValue(SpeedUnit.kilometerPerHour);

  /// Returns the speed value in Miles per hour (mph).
  double get inMilesPerHour => getValue(SpeedUnit.milePerHour);

  /// Returns the speed value in Miles per hour (mph).
  /// Alias for `inMilesPerHour`.
  double get inMph => getValue(SpeedUnit.milePerHour);

  /// Returns the speed value in Knots (kn).
  double get inKnots => getValue(SpeedUnit.knot);

  /// Returns the speed value in Feet per second (ft/s).
  double get inFeetPerSecond => getValue(SpeedUnit.footPerSecond);

  /// Returns an [Speed] object representing this speed in Meters per second (m/s).
  Speed get asMetersPerSecond => convertTo(SpeedUnit.meterPerSecond);

  /// Returns an [Speed] object representing this speed in Kilometers per second (km/s).
  Speed get asKilometersPerSecond => convertTo(SpeedUnit.kilometerPerSecond);

  /// Returns an [Speed] object representing this speed in Kilometers per hour (km/h).
  Speed get asKilometersPerHour => convertTo(SpeedUnit.kilometerPerHour);

  /// Returns an [Speed] object representing this speed in Miles per hour (mph).
  Speed get asMilesPerHour => convertTo(SpeedUnit.milePerHour);

  /// Returns an [Speed] object representing this speed in Knots (kn).
  Speed get asKnots => convertTo(SpeedUnit.knot);

  /// Returns an [Speed] object representing this speed in Feet per second (ft/s).
  Speed get asFeetPerSecond => convertTo(SpeedUnit.footPerSecond);
}

/// Provides convenient factory methods for creating [Speed] instances from [num].
extension SpeedCreation on num {
  /// Creates a [Speed] instance from this value in Meters per second (m/s).
  Speed get mps => Speed(toDouble(), SpeedUnit.meterPerSecond);

  /// Creates a [Speed] instance from this value in Meters per second (m/s).
  Speed get metersPerSecond => Speed(toDouble(), SpeedUnit.meterPerSecond);

  /// Creates a [Speed] instance from this value in Kilometers per second (km/s).
  Speed get kps => Speed(toDouble(), SpeedUnit.kilometerPerSecond);

  /// Creates a [Speed] instance from this value in Kilometers per second (km/s).
  Speed get kilometersPerSecond => Speed(toDouble(), SpeedUnit.kilometerPerSecond);

  /// Creates a [Speed] instance from this value in Kilometers per hour (km/h).
  Speed get kmh => Speed(toDouble(), SpeedUnit.kilometerPerHour);

  /// Creates a [Speed] instance from this value in Kilometers per hour (km/h).
  Speed get kilometersPerHour => Speed(toDouble(), SpeedUnit.kilometerPerHour);

  /// Creates a [Speed] instance from this value in Miles per hour (mph).
  Speed get mph => Speed(toDouble(), SpeedUnit.milePerHour);

  /// Creates a [Speed] instance from this value in Miles per hour (mph).
  Speed get milesPerHour => Speed(toDouble(), SpeedUnit.milePerHour);

  /// Creates a [Speed] instance from this value in Knots (kn).
  Speed get knots => Speed(toDouble(), SpeedUnit.knot);

  /// Creates a [Speed] instance from this value in Feet per second (ft/s).
  Speed get fps => Speed(toDouble(), SpeedUnit.footPerSecond);

  /// Creates a [Speed] instance from this value in Feet per second (ft/s).
  Speed get feetPerSecond => Speed(toDouble(), SpeedUnit.footPerSecond);
}

<!-- END FILE: [v0.12.0] lib/src/units/speed/speed_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/speed/speed_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various speed units relative to the
/// Meter per Second (m/s), which is the SI derived unit for speed.
///
/// These constants represent: `1 [Unit] = Z [Meters Per Second]`.
/// So, `mpsPerKmh` means `1 kilometer per hour = mpsPerKmh meters per second`.
class SpeedFactors {
  /// Meters per second per Kilometer per hour: 1 km/h = 1000m / 3600s.
  static const double mpsPerKmh = 1000.0 / 3600.0;

  /// Meters per second per Mile per hour: 1 mph = 1609.344m / 3600s.
  /// (based on the exact definition of a mile in meters).
  static const double mpsPerMph = 1609.344 / 3600.0;

  /// Meters per second per Knot: 1 kn = 1852m / 3600s.
  /// (based on the international definition of a nautical mile).
  static const double mpsPerKnot = 1852.0 / 3600.0;

  /// Meters per second per Foot per second: 1 ft/s = 0.3048 m/s.
  /// (based on the exact definition of a foot in meters).
  static const double mpsPerFps = 0.3048;

  /// Meters per second per Kilometer per second: 1 km/s = 1000 m/s.
  static const double mpsPerKps = 1000.0;

  // --- Other potential units (can be added if needed) ---
  // Example: Speed of Light (c)
  // /// Meters per second per speed of light: 1 c = 299792458 m/s.
  // static const double mpsPerSpeedOfLight = 299792458.0;
}

<!-- END FILE: [v0.12.0] lib/src/units/speed/speed_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/speed/speed_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'speed_factors.dart';

/// Represents units of speed.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each speed unit.
/// All conversion factors are pre-calculated in the constructor relative to
/// Meter per Second (m/s).
enum SpeedUnit implements Unit<SpeedUnit> {
  /// Meter per second (m/s), the SI derived unit of speed.
  meterPerSecond(1, 'm/s'),

  /// Kilometer per second (km/s), a common unit in scientific contexts like astronomy.
  kilometerPerSecond(SpeedFactors.mpsPerKps, 'km/s'),

  /// Kilometer per hour (km/h), a common unit for road vehicle speed.
  kilometerPerHour(SpeedFactors.mpsPerKmh, 'km/h'),

  /// Mile per hour (mph), a common unit for road vehicle speed in some countries.
  milePerHour(SpeedFactors.mpsPerMph, 'mph'),

  /// Knot (kn), a unit of speed equal to one nautical mile per hour.
  /// Commonly used in maritime and aviation contexts.
  knot(SpeedFactors.mpsPerKnot, 'kn'),

  /// Foot per second (ft/s), used in some engineering contexts.
  footPerSecond(SpeedFactors.mpsPerFps, 'ft/s');

  /// Constant constructor for enum members.
  ///
  /// [_toMpsFactor] is the factor to convert from this unit to the base unit (Meter per Second).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `SpeedUnit`.
  const SpeedUnit(double toMpsFactor, this.symbol)
      : _toMpsFactor = toMpsFactor,
        _factorToMeterPerSecond = toMpsFactor / 1.0,
        _factorToKilometerPerSecond = toMpsFactor / SpeedFactors.mpsPerKps,
        _factorToKilometerPerHour = toMpsFactor / SpeedFactors.mpsPerKmh,
        _factorToMilePerHour = toMpsFactor / SpeedFactors.mpsPerMph,
        _factorToKnot = toMpsFactor / SpeedFactors.mpsPerKnot,
        _factorToFootPerSecond = toMpsFactor / SpeedFactors.mpsPerFps;

  // ignore: unused_field // Used to store the conversion factor to Meter per Second (m/s).
  final double _toMpsFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToMeterPerSecond;
  final double _factorToKilometerPerSecond;
  final double _factorToKilometerPerHour;
  final double _factorToMilePerHour;
  final double _factorToKnot;
  final double _factorToFootPerSecond;

  /// Returns the direct conversion factor to convert a value from this [SpeedUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(SpeedUnit targetUnit) {
    switch (targetUnit) {
      case SpeedUnit.meterPerSecond:
        return _factorToMeterPerSecond;
      case SpeedUnit.kilometerPerSecond:
        return _factorToKilometerPerSecond;
      case SpeedUnit.kilometerPerHour:
        return _factorToKilometerPerHour;
      case SpeedUnit.milePerHour:
        return _factorToMilePerHour;
      case SpeedUnit.knot:
        return _factorToKnot;
      case SpeedUnit.footPerSecond:
        return _factorToFootPerSecond;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/speed/speed_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/temperature/temperature.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'temperature_unit.dart';

/// Represents a quantity of temperature.
///
/// Temperature conversions are affine (involve offsets) and are handled by
/// specific formulas within the [getValue] method, rather than simple
/// multiplicative factors.
@immutable
class Temperature extends Quantity<TemperatureUnit> {
  /// Creates a new Temperature quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final bodyTemp = Temperature(37.0, TemperatureUnit.celsius);
  /// final absoluteZero = Temperature(0.0, TemperatureUnit.kelvin);
  /// ```
  const Temperature(super.value, super.unit);

  // --- Conversion Constants ---
  // These could also be in a separate TemperatureFactors class if they grew more complex
  // or were needed elsewhere, but for direct formulas they are fine here.

  /// The offset of Kelvin from Celsius (0°C = 273.15K).
  static const double kelvinOffsetFromCelsius = 273.15;

  /// The scaling factor for Fahrenheit to Celsius conversion (9/5).
  static const double fahrenheitScaleFactor = 1.8; // 9.0 / 5.0

  /// The offset for Fahrenheit conversion from Celsius (0°C = 32°F).
  static const double fahrenheitOffset = 32.0;

  /// The offset for Rankine conversion from Fahrenheit (0°F = 459.67°R).
  static const double rankineOffsetFromFahrenheit = 459.67;

  /// Converts this temperature's value to the specified [targetUnit]
  /// using direct, optimized formulas for affine conversions.
  ///
  /// Example:
  /// ```dart
  /// final roomTempC = Temperature(20.0, TemperatureUnit.celsius);
  /// final roomTempF = roomTempC.getValue(TemperatureUnit.fahrenheit); // 68.0
  /// ```
  @override
  double getValue(TemperatureUnit targetUnit) {
    if (targetUnit == unit) return value;

    switch (unit) {
      case TemperatureUnit.celsius:
        switch (targetUnit) {
          case TemperatureUnit.kelvin:
            return value + kelvinOffsetFromCelsius;
          case TemperatureUnit.fahrenheit:
            return (value * fahrenheitScaleFactor) + fahrenheitOffset;
          case TemperatureUnit.rankine:
            // Celsius -> Fahrenheit -> Rankine
            final fahrenheitValue = (value * fahrenheitScaleFactor) + fahrenheitOffset;
            return fahrenheitValue + rankineOffsetFromFahrenheit;
          case TemperatureUnit.celsius:
            return value;
        }
      case TemperatureUnit.kelvin:
        switch (targetUnit) {
          case TemperatureUnit.celsius:
            return value - kelvinOffsetFromCelsius;
          case TemperatureUnit.fahrenheit:
            final celsiusValue = value - kelvinOffsetFromCelsius;
            return (celsiusValue * fahrenheitScaleFactor) + fahrenheitOffset;
          case TemperatureUnit.rankine:
            // Kelvin -> Rankine: multiply by 9/5
            return value * fahrenheitScaleFactor;
          case TemperatureUnit.kelvin:
            return value;
        }
      case TemperatureUnit.fahrenheit:
        switch (targetUnit) {
          case TemperatureUnit.celsius:
            return (value - fahrenheitOffset) / fahrenheitScaleFactor;
          case TemperatureUnit.kelvin:
            final celsiusValue = (value - fahrenheitOffset) / fahrenheitScaleFactor;
            return celsiusValue + kelvinOffsetFromCelsius;
          case TemperatureUnit.rankine:
            return value + rankineOffsetFromFahrenheit;
          case TemperatureUnit.fahrenheit:
            return value;
        }
      case TemperatureUnit.rankine:
        switch (targetUnit) {
          case TemperatureUnit.fahrenheit:
            return value - rankineOffsetFromFahrenheit;
          case TemperatureUnit.celsius:
            // Rankine -> Fahrenheit -> Celsius
            final fahrenheitValue = value - rankineOffsetFromFahrenheit;
            return (fahrenheitValue - fahrenheitOffset) / fahrenheitScaleFactor;
          case TemperatureUnit.kelvin:
            // Rankine -> Kelvin: divide by 9/5
            return value / fahrenheitScaleFactor;
          case TemperatureUnit.rankine:
            return value;
        }
    }
  }

  /// Creates a new [Temperature] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final boilingPointC = Temperature(100.0, TemperatureUnit.celsius);
  /// final boilingPointF = boilingPointC.convertTo(TemperatureUnit.fahrenheit);
  /// print(boilingPointF); // Output: "212.0 °F"
  /// ```
  @override
  Temperature convertTo(TemperatureUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Temperature(newValue, targetUnit);
  }

  /// Compares this [Temperature] object to another [Quantity<TemperatureUnit>].
  ///
  /// Comparison is based on the physical magnitude of the temperatures.
  /// For comparison, this temperature is converted to the unit of the [other] temperature.
  @override
  int compareTo(Quantity<TemperatureUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators (Specific for Temperature) ---

  /// Subtracts another temperature from this temperature, yielding a temperature difference.
  /// The [other] temperature is converted to the unit of this temperature before subtraction.
  /// Returns a [double] representing the difference in the unit of this temperature.
  /// For example, `20.celsius - 10.celsius` yields `10.0` (a difference of 10 Celsius degrees).
  double operator -(Temperature other) {
    final otherValueInThisUnit = other.getValue(unit);
    return value - otherValueInThisUnit;
  }

  // Operator + (Temperature other) is intentionally not implemented as adding
  // absolute temperatures (e.g., 20°C + 10°C) is not physically meaningful.
  // Use the `operator -` to find a temperature difference.

  // Operator * (double scalar) is intentionally not implemented as scaling
  // absolute temperatures is generally not meaningful, except in specific
  // thermodynamic contexts where absolute scales (Kelvin/Rankine) are used.
  // For such cases, it is safer for the user to extract the value and perform the calculation explicitly.

  // Operator / (double scalar) is intentionally not implemented as it's
  // generally not physically meaningful for absolute temperatures.

  /// Divides this temperature by another temperature.
  /// The [other] temperature is converted to the unit of this temperature before division.
  /// Returns a scalar [double] representing the ratio.
  /// Note: This operation is only meaningful in specific thermodynamic contexts (e.g., Carnot efficiency)
  /// and should be used with caution. Both temperatures should ideally be on an absolute scale (Kelvin or Rankine)
  /// for physical meaning, though the calculation will be performed based on converted values.
  /// Throws [ArgumentError] if the effective value of [other] in this unit is zero.
  double operator /(Temperature other) {
    // For ratio calculations, it's often more meaningful if both are converted to Kelvin first,
    // but to keep consistent with other quantity divisions, we convert to `this.unit`.
    final otherValueInThisUnit = other.getValue(unit);
    if (otherValueInThisUnit == 0 && value != 0) {
      // Avoid 0/0 resulting in NaN without error
      // A zero temperature on a non-Kelvin scale might not be absolute zero.
      // However, division by zero magnitude is the primary concern.
      throw ArgumentError('Cannot divide by a zero temperature if the dividend is non-zero.');
    }
    // Handle 0.0 / 0.0 case, which results in NaN. Could throw or return as is.
    // Standard double division handles 0.0/0.0 as NaN.
    if (value == 0 && otherValueInThisUnit == 0) {
      return double.nan; // Or throw, depending on desired strictness for 0/0
    }
    return value / otherValueInThisUnit;
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/temperature/temperature.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/temperature/temperature_extensions.dart -->
import 'temperature.dart';
import 'temperature_unit.dart';

/// Provides convenient access to [Temperature] values in specific units.
extension TemperatureValueGetters on Temperature {
  /// Returns the temperature value in Celsius (°C).
  double get inCelsius => getValue(TemperatureUnit.celsius);

  /// Returns the temperature value in Kelvin (K).
  double get inKelvin => getValue(TemperatureUnit.kelvin);

  /// Returns the temperature value in Fahrenheit (°F).
  double get inFahrenheit => getValue(TemperatureUnit.fahrenheit);

  /// Returns the temperature value in Rankine (°R).
  double get inRankine => getValue(TemperatureUnit.rankine);

  /// Returns a Temperature representing this temperature in Celsius (°C).
  Temperature get asCelsius => convertTo(TemperatureUnit.celsius);

  /// Returns a Temperature representing this temperature in Kelvin (K).
  Temperature get asKelvin => convertTo(TemperatureUnit.kelvin);

  /// Returns a Temperature representing this temperature in Fahrenheit (°F).
  Temperature get asFahrenheit => convertTo(TemperatureUnit.fahrenheit);

  /// Returns a Temperature representing this temperature in Rankine (°R).
  Temperature get asRankine => convertTo(TemperatureUnit.rankine);
}

/// Provides convenient factory methods for creating [Temperature] instances from [num].
extension TemperatureCreation on num {
  /// Creates a [Temperature] instance representing this numerical value in Celsius (°C).
  Temperature get celsius => Temperature(toDouble(), TemperatureUnit.celsius);

  /// Creates a [Temperature] instance representing this numerical value in Kelvin (K).
  Temperature get kelvin => Temperature(toDouble(), TemperatureUnit.kelvin);

  /// Creates a [Temperature] instance representing this numerical value in Fahrenheit (°F).
  Temperature get fahrenheit => Temperature(toDouble(), TemperatureUnit.fahrenheit);

  /// Creates a [Temperature] instance representing this numerical value in Rankine (°R).
  Temperature get rankine => Temperature(toDouble(), TemperatureUnit.rankine);
}

<!-- END FILE: [v0.12.0] lib/src/units/temperature/temperature_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/temperature/temperature_unit.dart -->
import '../../core/unit.dart';
import 'temperature.dart';

/// Represents units of temperature.
///
/// This enum implements the [Unit] interface but its [factorTo] method
/// will throw an [UnsupportedError] because temperature conversions
/// are affine (involve offsets) and cannot be represented by a single
/// multiplicative factor. Use [Temperature.getValue] or [Temperature.convertTo]
/// for proper conversions.
enum TemperatureUnit implements Unit<TemperatureUnit> {
  /// Celsius (°C).
  celsius('°C'),

  /// Kelvin (K), the SI base unit of thermodynamic temperature.
  kelvin('K'),

  /// Fahrenheit (°F).
  fahrenheit('°F'),

  /// Rankine (°R), an absolute temperature scale using Fahrenheit degrees.
  /// °R = °F + 459.67, or °R = °K × 9/5.
  rankine('°R');

  /// Constant constructor for enum members.
  /// [symbol] is the display symbol for the unit.
  const TemperatureUnit(this.symbol);

  @override
  final String symbol;

  /// Throws [UnsupportedError] for temperature units.
  ///
  /// Temperature conversions are affine (involve offsets) and cannot be
  /// represented by a single multiplicative factor.
  /// Use [Temperature.getValue] or [Temperature.convertTo] for proper
  /// temperature conversions.
  @override
  double factorTo(TemperatureUnit targetUnit) {
    throw UnsupportedError(
      'Direct multiplicative factor conversion is not supported for temperature units '
      'due to their affine nature (offsets). '
      'Use Temperature.getValue() or Temperature.convertTo() for proper conversions.',
    );
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/temperature/temperature_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/time/time.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'time_unit.dart';

/// Represents a quantity of time (duration).
@immutable
class Time extends Quantity<TimeUnit> {
  /// Creates a new Time quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final duration = Time(120.0, TimeUnit.second);
  /// final meetingLength = Time(1.5, TimeUnit.hour);
  /// ```
  const Time(super.value, super.unit);

  /// Converts this time's value to the specified [targetUnit].
  @override
  double getValue(TimeUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Time] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final twoMinutes = Time(2.0, TimeUnit.minute);
  /// final inSeconds = twoMinutes.convertTo(TimeUnit.second); // Time(120.0, TimeUnit.second)
  /// print(inSeconds.value); // 120.0
  /// ```
  @override
  Time convertTo(TimeUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Time(newValue, targetUnit);
  }

  /// Compares this [Time] object to another [Quantity<TimeUnit>].
  ///
  /// Comparison is based on the physical magnitude of the durations.
  @override
  int compareTo(Quantity<TimeUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this time duration to another time duration.
  /// The [other] time is converted to the unit of this time before addition.
  /// Returns a new [Time] instance with the result in the unit of this time.
  Time operator +(Time other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Time(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another time duration from this time duration.
  /// The [other] time is converted to the unit of this time before subtraction.
  /// Returns a new [Time] instance with the result in the unit of this time.
  Time operator -(Time other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Time(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this time duration by a scalar value.
  /// Returns a new [Time] instance with the scaled value in the original unit.
  Time operator *(double scalar) {
    return Time(value * scalar, unit);
  }

  /// Divides this time duration by a scalar value.
  /// Returns a new [Time] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Time operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Time(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/time/time.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/time/time_extensions.dart -->
import 'time.dart';
import 'time_unit.dart';

/// Provides convenient access to [Time] values in specific units.
extension TimeValueGetters on Time {
  /// Returns the time value in Seconds (s).
  double get inSeconds => getValue(TimeUnit.second);

  /// Returns the time value in Microseconds (μs).
  double get inMicroseconds => getValue(TimeUnit.microsecond);

  /// Returns the time value in Nanoseconds (ns).
  double get inNanoseconds => getValue(TimeUnit.nanosecond);

  /// Returns the time value in Picoseconds (ps).
  double get inPicoseconds => getValue(TimeUnit.picosecond);

  /// Returns the time value in Milliseconds (ms).
  double get inMilliseconds => getValue(TimeUnit.millisecond);

  /// Returns the time value in Centiseconds (cs).
  double get inCentiseconds => getValue(TimeUnit.centisecond);

  /// Returns the time value in Deciseconds (ds).
  double get inDeciseconds => getValue(TimeUnit.decisecond);

  /// Returns the time value in Decaseconds (das).
  double get inDecaseconds => getValue(TimeUnit.decasecond);

  /// Returns the time value in Hectoseconds (hs).
  double get inHectoseconds => getValue(TimeUnit.hectosecond);

  /// Returns the time value in Kiloseconds (ks).
  double get inKiloseconds => getValue(TimeUnit.kilosecond);

  /// Returns the time value in Megaseconds (Ms).
  double get inMegaseconds => getValue(TimeUnit.megasecond);

  /// Returns the time value in Gigaseconds (Gs).
  double get inGigaseconds => getValue(TimeUnit.gigasecond);

  /// Returns the time value in Minutes (min).
  double get inMinutes => getValue(TimeUnit.minute);

  /// Returns the time value in Hours (h).
  double get inHours => getValue(TimeUnit.hour);

  /// Returns the time value in Days (d).
  double get inDays => getValue(TimeUnit.day);

  /// Returns the time value in Weeks (wk).
  double get inWeeks => getValue(TimeUnit.week);

  /// Returns the time value in Fortnights (fn).
  double get inFortnights => getValue(TimeUnit.fortnight);

  /// Returns the time value in Months (mo).
  double get inMonths => getValue(TimeUnit.month);

  /// Returns the time value in Years (yr).
  double get inYears => getValue(TimeUnit.year);

  /// Returns the time value in Decades (dec).
  double get inDecades => getValue(TimeUnit.decade);

  /// Returns the time value in Centuries (c).
  double get inCenturies => getValue(TimeUnit.century);

  /// Returns a Time representing this time in Seconds (s).
  Time get asSeconds => convertTo(TimeUnit.second);

  /// Returns a Time representing this time in Microseconds (μs).
  Time get asMicroseconds => convertTo(TimeUnit.microsecond);

  /// Returns a Time representing this time in Nanoseconds (ns).
  Time get asNanoseconds => convertTo(TimeUnit.nanosecond);

  /// Returns a Time representing this time in Picoseconds (ps).
  Time get asPicoseconds => convertTo(TimeUnit.picosecond);

  /// Returns a Time representing this time in Milliseconds (ms).
  Time get asMilliseconds => convertTo(TimeUnit.millisecond);

  /// Returns a Time representing this time in Centiseconds (cs).
  Time get asCentiseconds => convertTo(TimeUnit.centisecond);

  /// Returns a Time representing this time in Deciseconds (ds).
  Time get asDeciseconds => convertTo(TimeUnit.decisecond);

  /// Returns a Time representing this time in Decaseconds (das).
  Time get asDecaseconds => convertTo(TimeUnit.decasecond);

  /// Returns a Time representing this time in Hectoseconds (hs).
  Time get asHectoseconds => convertTo(TimeUnit.hectosecond);

  /// Returns a Time representing this time in Kiloseconds (ks).
  Time get asKiloseconds => convertTo(TimeUnit.kilosecond);

  /// Returns a Time representing this time in Megaseconds (Ms).
  Time get asMegaseconds => convertTo(TimeUnit.megasecond);

  /// Returns a Time representing this time in Gigaseconds (Gs).
  Time get asGigaseconds => convertTo(TimeUnit.gigasecond);

  /// Returns a Time representing this time in Fortnights (fn).
  Time get asFortnights => convertTo(TimeUnit.fortnight);

  /// Returns a Time representing this time in Decades (dec).
  Time get asDecades => convertTo(TimeUnit.decade);

  /// Returns a Time representing this time in Centuries (c).
  Time get asCenturies => convertTo(TimeUnit.century);

  /// Returns a Time representing this time in Minutes (min).
  Time get asMinutes => convertTo(TimeUnit.minute);

  /// Returns a Time representing this time in Hours (h).
  Time get asHours => convertTo(TimeUnit.hour);

  /// Returns a Time representing this time in Days (d).
  Time get asDays => convertTo(TimeUnit.day);

  /// Returns a Time representing this time in Weeks (wk).
  Time get asWeeks => convertTo(TimeUnit.week);

  /// Returns a Time representing this time in Months (mo).
  Time get asMonths => convertTo(TimeUnit.month);

  /// Returns a Time representing this time in Years (yr).
  Time get asYears => convertTo(TimeUnit.year);
}

/// Provides convenient factory methods for creating [Time] instances from [num].
extension TimeCreation on num {
  /// Creates a [Time] instance representing this numerical value in Seconds (s).
  Time get seconds => Time(toDouble(), TimeUnit.second);

  /// Creates a [Time] instance representing this numerical value in Microseconds (μs).
  Time get microseconds => Time(toDouble(), TimeUnit.microsecond);

  /// Creates a [Time] instance representing this numerical value in Nanoseconds (ns).
  Time get nanoseconds => Time(toDouble(), TimeUnit.nanosecond);

  /// Creates a [Time] instance representing this numerical value in Picoseconds (ps).
  Time get picoseconds => Time(toDouble(), TimeUnit.picosecond);

  /// Creates a [Time] instance representing this numerical value in Milliseconds (ms).
  Time get milliseconds => Time(toDouble(), TimeUnit.millisecond);

  /// Creates a [Time] instance from this numerical value in Centiseconds (cs).
  Time get cs => Time(toDouble(), TimeUnit.centisecond);

  /// Creates a [Time] instance from this numerical value in Deciseconds (ds).
  Time get ds => Time(toDouble(), TimeUnit.decisecond);

  /// Creates a [Time] instance from this numerical value in Decaseconds (das).
  Time get das => Time(toDouble(), TimeUnit.decasecond);

  /// Creates a [Time] instance from this numerical value in Hectoseconds (hs).
  Time get hs => Time(toDouble(), TimeUnit.hectosecond);

  /// Creates a [Time] instance from this numerical value in Kiloseconds (ks).
  Time get kiloS => Time(toDouble(), TimeUnit.kilosecond);

  /// Creates a [Time] instance from this numerical value in Megaseconds (Ms).
  Time get megaS => Time(toDouble(), TimeUnit.megasecond);

  /// Creates a [Time] instance from this numerical value in Gigaseconds (Gs).
  Time get gigaS => Time(toDouble(), TimeUnit.gigasecond);

  /// Creates a [Time] instance representing this numerical value in Minutes (min).
  Time get minutes => Time(toDouble(), TimeUnit.minute);

  /// Creates a [Time] instance representing this numerical value in Hours (h).
  Time get hours => Time(toDouble(), TimeUnit.hour);

  /// Creates a [Time] instance representing this numerical value in Days (d).
  Time get days => Time(toDouble(), TimeUnit.day);

  /// Creates a [Time] instance representing this numerical value in Weeks (wk).
  Time get weeks => Time(toDouble(), TimeUnit.week);

  /// Creates a [Time] instance from this numerical value in Fortnights (fn).
  Time get fortnights => Time(toDouble(), TimeUnit.fortnight);

  /// Creates a [Time] instance representing this numerical value in Months (mo).
  Time get months => Time(toDouble(), TimeUnit.month);

  /// Creates a [Time] instance representing this numerical value in Years (yr).
  Time get years => Time(toDouble(), TimeUnit.year);

  /// Creates a [Time] instance from this numerical value in Decades (dec).
  Time get decades => Time(toDouble(), TimeUnit.decade);

  /// Creates a [Time] instance from this numerical value in Centuries (c).
  /// Note: `.c` is avoided due to conflict with 'centi' prefix and Celsius.
  Time get centuries => Time(toDouble(), TimeUnit.century);

  // Short aliases for common units
  /// Creates a [Time] instance representing this numerical value in Seconds (s).
  /// Alias for `seconds`.
  Time get s => Time(toDouble(), TimeUnit.second);

  /// Creates a [Time] instance representing this numerical value in Microseconds (μs).
  /// Alias for `microseconds`.
  Time get us => Time(toDouble(), TimeUnit.microsecond);

  /// Creates a [Time] instance representing this numerical value in Nanoseconds (ns).
  /// Alias for `nanoseconds`.
  Time get ns => Time(toDouble(), TimeUnit.nanosecond);

  /// Creates a [Time] instance representing this numerical value in Picoseconds (ps).
  /// Alias for `picoseconds`.
  Time get ps => Time(toDouble(), TimeUnit.picosecond);

  /// Creates a [Time] instance representing this numerical value in Milliseconds (ms).
  /// Alias for `milliseconds`.
  Time get ms => Time(toDouble(), TimeUnit.millisecond);

  /// Creates a [Time] instance representing this numerical value in Minutes (min).
  /// Alias for `minutes`. Note: 'm' is used for meters, so 'min' is better for time.
  Time get min => Time(toDouble(), TimeUnit.minute);

  /// Creates a [Time] instance representing this numerical value in Hours (h).
  /// Alias for `hours`.
  Time get h => Time(toDouble(), TimeUnit.hour);

  /// Creates a [Time] instance representing this numerical value in Days (d).
  /// Alias for `days`.
  Time get d => Time(toDouble(), TimeUnit.day);

  /// Creates a [Time] instance representing this numerical value in Weeks (wk).
  /// Alias for `weeks`.
  Time get wk => Time(toDouble(), TimeUnit.week);

  /// Creates a [Time] instance representing this numerical value in Months (mo).
  /// Alias for `months`.
  Time get mo => Time(toDouble(), TimeUnit.month);

  /// Creates a [Time] instance representing this numerical value in Years (yr).
  /// Alias for `years`.
  Time get yr => Time(toDouble(), TimeUnit.year);
}

<!-- END FILE: [v0.12.0] lib/src/units/time/time_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/time/time_factors.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

/// Defines base conversion factors for various time units relative to Second (s).
///
/// These constants are based on standard definitions.
class TimeFactors {
  // The base unit for internal calculations is Second.
  // Factors represent: 1 [Unit] = X [Seconds]

  /// Seconds per Gigasecond: 1 Gs = 1e9 seconds.
  static const double secondsPerGigasecond = 1e9;

  /// Seconds per Megasecond: 1 Ms = 1e6 seconds.
  static const double secondsPerMegasecond = 1e6;

  /// Seconds per Kilosecond: 1 ks = 1000.0 seconds.
  static const double secondsPerKilosecond = 1000.0;

  /// Seconds per Hectosecond: 1 hs = 100.0 seconds.
  static const double secondsPerHectosecond = 100.0;

  /// Seconds per Decasecond: 1 das = 10.0 seconds.
  static const double secondsPerDecasecond = 10.0;

  /// Seconds per Microsecond: 1 microsecond = 1e-6 seconds.
  static const double secondsPerMicrosecond = 1e-6;

  /// Seconds per Nanosecond: 1 nanosecond = 1e-9 seconds.
  static const double secondsPerNanosecond = 1e-9;

  /// Seconds per Picosecond: 1 picosecond = 1e-12 seconds.
  static const double secondsPerPicosecond = 1e-12;

  /// Seconds per Millisecond: 1 millisecond = 0.001 seconds.
  static const double secondsPerMillisecond = 0.001;

  /// Seconds per Centisecond: 1 cs = 0.01 seconds.
  static const double secondsPerCentisecond = 0.01;

  /// Seconds per Decisecond: 1 ds = 0.1 seconds.
  static const double secondsPerDecisecond = 0.1;

  /// Seconds per Minute: 1 minute = 60.0 seconds.
  static const double secondsPerMinute = 60.0;

  /// Seconds per Hour: 1 hour = 3600.0 seconds (60 minutes * 60 seconds).
  static const double secondsPerHour = 3600.0;

  /// Seconds per Day: 1 day = 86400.0 seconds (24 hours * 3600 seconds/hour).
  static const double secondsPerDay = 86400.0;

  /// Seconds per Week: 1 week = 604800.0 seconds (7 days * 86400 seconds/day).
  static const double secondsPerWeek = 604800.0;

  /// Seconds per Fortnight: 1 fortnight = 1209600.0 seconds (14 days).
  static const double secondsPerFortnight = secondsPerDay * 14.0;

  /// Seconds per Month: 1 month ≈ 2629800.0 seconds.
  /// Based on average month length: 365.25 days / 12 months = 30.4375 days/month.
  static const double secondsPerMonth = 2629800.0;

  /// Seconds per Year: 1 year = 31557600.0 seconds.
  /// Based on Julian year: 365.25 days * 24 hours/day * 3600 seconds/hour.
  static const double secondsPerYear = 31557600.0;

  /// Seconds per Decade: 1 decade = 315576000.0 seconds (10 Julian years).
  static const double secondsPerDecade = secondsPerYear * 10.0;

  /// Seconds per Century: 1 century = 3155760000.0 seconds (100 Julian years).
  static const double secondsPerCentury = secondsPerYear * 100.0;
}

<!-- END FILE: [v0.12.0] lib/src/units/time/time_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/time/time_unit.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'time_factors.dart';

/// Represents units of time.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each time unit.
/// All conversion factors are pre-calculated in the constructor relative to Second (s).
enum TimeUnit implements Unit<TimeUnit> {
  /// Second (s), the SI base unit of time.
  second(1.0, 's'),

  /// Microsecond (μs), equal to 1e-6 seconds.
  microsecond(TimeFactors.secondsPerMicrosecond, 'μs'),

  /// Nanosecond (ns), equal to 1e-9 seconds.
  nanosecond(TimeFactors.secondsPerNanosecond, 'ns'),

  /// Picosecond (ps), equal to 1e-12 seconds.
  picosecond(TimeFactors.secondsPerPicosecond, 'ps'),

  /// Millisecond (ms), equal to 0.001 seconds.
  millisecond(TimeFactors.secondsPerMillisecond, 'ms'),

  /// Centisecond (cs), equal to 0.01 seconds.
  centisecond(TimeFactors.secondsPerCentisecond, 'cs'),

  /// Decisecond (ds), equal to 0.1 seconds.
  decisecond(TimeFactors.secondsPerDecisecond, 'ds'),

  /// Decasecond (das), equal to 10 seconds.
  decasecond(TimeFactors.secondsPerDecasecond, 'das'),

  /// Hectosecond (hs), equal to 100 seconds.
  hectosecond(TimeFactors.secondsPerHectosecond, 'hs'),

  /// Kilosecond (ks), equal to 1000 seconds.
  kilosecond(TimeFactors.secondsPerKilosecond, 'ks'),

  /// Megasecond (Ms), equal to 1e6 seconds.
  megasecond(TimeFactors.secondsPerMegasecond, 'Ms'),

  /// Gigasecond (Gs), equal to 1e9 seconds.
  gigasecond(TimeFactors.secondsPerGigasecond, 'Gs'),

  /// Minute (min), equal to 60 seconds.
  minute(TimeFactors.secondsPerMinute, 'min'),

  /// Hour (h), equal to 3600 seconds.
  hour(TimeFactors.secondsPerHour, 'h'),

  /// Day (d), equal to 86400 seconds.
  day(TimeFactors.secondsPerDay, 'd'),

  /// Week (wk), equal to 604800 seconds (7 days).
  week(TimeFactors.secondsPerWeek, 'wk'),

  /// Fortnight (fn), equal to 2 weeks or 14 days.
  fortnight(TimeFactors.secondsPerFortnight, 'fn'),

  /// Month (mo), equal to approximately 2629746 seconds.
  /// Based on average month length (365.25 days / 12).
  month(TimeFactors.secondsPerMonth, 'mo'),

  /// Year (yr), equal to 31557600 seconds.
  /// Based on Julian year (365.25 days).
  year(TimeFactors.secondsPerYear, 'yr'),

  /// Decade (dec), equal to 10 Julian years.
  decade(TimeFactors.secondsPerDecade, 'dec'),

  /// Century (c), equal to 100 Julian years.
  century(TimeFactors.secondsPerCentury, 'c');

  /// Constant constructor for enum members.
  ///
  /// [_toSecondFactor] is the factor to convert from this unit to the base unit (Second).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `TimeUnit`.
  const TimeUnit(this._toSecondFactor, this.symbol)
      : _factorToSecond = _toSecondFactor / 1.0, // Second's _toSecondFactor is 1.0
        _factorToMicrosecond = _toSecondFactor / TimeFactors.secondsPerMicrosecond,
        _factorToNanosecond = _toSecondFactor / TimeFactors.secondsPerNanosecond,
        _factorToPicosecond = _toSecondFactor / TimeFactors.secondsPerPicosecond,
        _factorToMillisecond = _toSecondFactor / TimeFactors.secondsPerMillisecond,
        _factorToCentisecond = _toSecondFactor / TimeFactors.secondsPerCentisecond,
        _factorToDecisecond = _toSecondFactor / TimeFactors.secondsPerDecisecond,
        _factorToDecasecond = _toSecondFactor / TimeFactors.secondsPerDecasecond,
        _factorToHectosecond = _toSecondFactor / TimeFactors.secondsPerHectosecond,
        _factorToKilosecond = _toSecondFactor / TimeFactors.secondsPerKilosecond,
        _factorToMegasecond = _toSecondFactor / TimeFactors.secondsPerMegasecond,
        _factorToGigasecond = _toSecondFactor / TimeFactors.secondsPerGigasecond,
        _factorToMinute = _toSecondFactor / TimeFactors.secondsPerMinute,
        _factorToHour = _toSecondFactor / TimeFactors.secondsPerHour,
        _factorToDay = _toSecondFactor / TimeFactors.secondsPerDay,
        _factorToWeek = _toSecondFactor / TimeFactors.secondsPerWeek,
        _factorToFortnight = _toSecondFactor / TimeFactors.secondsPerFortnight,
        _factorToMonth = _toSecondFactor / TimeFactors.secondsPerMonth,
        _factorToYear = _toSecondFactor / TimeFactors.secondsPerYear,
        _factorToDecade = _toSecondFactor / TimeFactors.secondsPerDecade,
        _factorToCentury = _toSecondFactor / TimeFactors.secondsPerCentury;

  /// The factor to convert a value from this unit to the base unit (Second).
  /// After constructor initialization, its value is primarily baked into
  /// the specific _factorToXxx fields for direct inter-unit conversions.
  /// It's generally not accessed directly by methods outside this enum's constructor
  /// but is crucial for deriving the pre-calculated factors.
  // ignore: unused_field
  final double _toSecondFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToSecond;
  final double _factorToMicrosecond;
  final double _factorToNanosecond;
  final double _factorToPicosecond;
  final double _factorToMillisecond;
  final double _factorToCentisecond;
  final double _factorToDecisecond;
  final double _factorToDecasecond;
  final double _factorToHectosecond;
  final double _factorToKilosecond;
  final double _factorToMegasecond;
  final double _factorToGigasecond;
  final double _factorToMinute;
  final double _factorToHour;
  final double _factorToDay;
  final double _factorToWeek;
  final double _factorToFortnight;
  final double _factorToMonth;
  final double _factorToYear;
  final double _factorToDecade;
  final double _factorToCentury;

  /// Returns the direct conversion factor to convert a value from this [TimeUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(TimeUnit targetUnit) {
    switch (targetUnit) {
      case TimeUnit.second:
        return _factorToSecond;
      case TimeUnit.microsecond:
        return _factorToMicrosecond;
      case TimeUnit.nanosecond:
        return _factorToNanosecond;
      case TimeUnit.picosecond:
        return _factorToPicosecond;
      case TimeUnit.millisecond:
        return _factorToMillisecond;
      case TimeUnit.centisecond:
        return _factorToCentisecond;
      case TimeUnit.decisecond:
        return _factorToDecisecond;
      case TimeUnit.decasecond:
        return _factorToDecasecond;
      case TimeUnit.hectosecond:
        return _factorToHectosecond;
      case TimeUnit.kilosecond:
        return _factorToKilosecond;
      case TimeUnit.megasecond:
        return _factorToMegasecond;
      case TimeUnit.gigasecond:
        return _factorToGigasecond;
      case TimeUnit.minute:
        return _factorToMinute;
      case TimeUnit.hour:
        return _factorToHour;
      case TimeUnit.day:
        return _factorToDay;
      case TimeUnit.week:
        return _factorToWeek;
      case TimeUnit.fortnight:
        return _factorToFortnight;
      case TimeUnit.month:
        return _factorToMonth;
      case TimeUnit.year:
        return _factorToYear;
      case TimeUnit.decade:
        return _factorToDecade;
      case TimeUnit.century:
        return _factorToCentury;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/time/time_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/volume/volume.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'volume_unit.dart';

/// Represents a quantity of volume.
///
/// Volume is a derived quantity representing the amount of three-dimensional
/// space occupied by a substance. The SI derived unit is the Cubic Meter (m³).
@immutable
class Volume extends Quantity<VolumeUnit> {
  /// Creates a new `Volume` quantity with the given numerical [value] and [unit].
  const Volume(super.value, super.unit);

  /// Converts this volume's value to the specified [targetUnit].
  @override
  double getValue(VolumeUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Volume] instance with the value converted to the [targetUnit].
  @override
  Volume convertTo(VolumeUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Volume(newValue, targetUnit);
  }

  /// Compares this [Volume] object to another [Quantity<VolumeUnit>].
  @override
  int compareTo(Quantity<VolumeUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this volume to another volume.
  Volume operator +(Volume other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Volume(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another volume from this volume.
  Volume operator -(Volume other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Volume(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this volume by a scalar value.
  Volume operator *(double scalar) {
    return Volume(value * scalar, unit);
  }

  /// Divides this volume by a scalar value.
  Volume operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Volume(value / scalar, unit);
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/volume/volume.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/volume/volume_extensions.dart -->
import 'volume.dart';
import 'volume_unit.dart';

/// Provides convenient access to [Volume] values in specific units
/// using getter properties.
extension VolumeValueGetters on Volume {
  // --- SI Cubic ---

  /// Returns the volume value in Cubic Meters (m³).
  double get inCubicMeters => getValue(VolumeUnit.cubicMeter);

  /// Returns the volume value in Cubic Decameters (dam³).
  double get inCubicDecameters => getValue(VolumeUnit.cubicDecameter);

  /// Returns the volume value in Cubic Hectometers (hm³).
  double get inCubicHectometers => getValue(VolumeUnit.cubicHectometer);

  /// Returns the volume value in Cubic Kilometers (km³).
  double get inCubicKilometers => getValue(VolumeUnit.cubicKilometer);

  /// Returns the volume value in Cubic Decimeters (dm³).
  double get inCubicDecimeters => getValue(VolumeUnit.cubicDecimeter);

  /// Returns the volume value in Cubic Centimeters (cm³).
  double get inCubicCentimeters => getValue(VolumeUnit.cubicCentimeter);

  /// Returns the volume value in Cubic Millimeters (mm³).
  double get inCubicMillimeters => getValue(VolumeUnit.cubicMillimeter);

  // --- Litre-based ---

  /// Returns the volume value in Kiloliters (kl).
  double get inKiloliters => getValue(VolumeUnit.kiloliter);

  /// Returns the volume value in Megaliters (Ml).
  double get inMegaliters => getValue(VolumeUnit.megaliter);

  /// Returns the volume value in Gigaliters (Gl).
  double get inGigaliters => getValue(VolumeUnit.gigaliter);

  /// Returns the volume value in Teraliters (Tl).
  double get inTeraliters => getValue(VolumeUnit.teraliter);

  /// Returns the volume value in Liters (L).
  double get inLiters => getValue(VolumeUnit.litre);

  /// Returns the volume value in Milliliters (mL).
  double get inMilliliters => getValue(VolumeUnit.milliliter);

  /// Returns the volume value in Microliters (µL).
  double get inMicroliters => getValue(VolumeUnit.microliter);

  // --- Imperial / US Customary Cubic ---

  /// Returns the volume value in Cubic Inches (in³).
  double get inCubicInches => getValue(VolumeUnit.cubicInch);

  /// Returns the volume value in Cubic Feet (ft³).
  double get inCubicFeet => getValue(VolumeUnit.cubicFoot);

  /// Returns the volume value in Cubic Miles (mi³).
  double get inCubicMiles => getValue(VolumeUnit.cubicMile);

  // --- US Customary Liquid ---

  /// Returns the volume value in US Gallons (gal).
  double get inGallons => getValue(VolumeUnit.gallon);

  /// Returns the volume value in US Quarts (qt).
  double get inQuarts => getValue(VolumeUnit.quart);

  /// Returns the volume value in US Pints (pt).
  double get inPints => getValue(VolumeUnit.pint);

  /// Returns the volume value in US Fluid Ounces (fl-oz).
  double get inFluidOunces => getValue(VolumeUnit.fluidOunce);

  // --- US Customary Cooking ---

  /// Returns the volume value in US Tablespoons (tbsp).
  double get inTablespoons => getValue(VolumeUnit.tablespoon);

  /// Returns the volume value in US Teaspoons (tsp).
  double get inTeaspoons => getValue(VolumeUnit.teaspoon);

  // --- "As" Getters for new Volume objects ---

  /// Returns a new [Volume] object representing this volume in Cubic Meters (m³).
  Volume get asCubicMeters => convertTo(VolumeUnit.cubicMeter);

  /// Returns a new [Volume] object representing this volume in Cubic Decameters (dam³).
  Volume get asCubicDecameters => convertTo(VolumeUnit.cubicDecameter);

  /// Returns a new [Volume] object representing this volume in Cubic Hectometers (hm³).
  Volume get asCubicHectometers => convertTo(VolumeUnit.cubicHectometer);

  /// Returns a new [Volume] object representing this volume in Cubic Kilometers (km³).
  Volume get asCubicKilometers => convertTo(VolumeUnit.cubicKilometer);

  /// Returns a new [Volume] object representing this volume in Cubic Decimeters (dm³).
  Volume get asCubicDecimeters => convertTo(VolumeUnit.cubicDecimeter);

  /// Returns a new [Volume] object representing this volume in Cubic Centimeters (cm³).
  Volume get asCubicCentimeters => convertTo(VolumeUnit.cubicCentimeter);

  /// Returns a new [Volume] object representing this volume in Cubic Millimeters (mm³).
  Volume get asCubicMillimeters => convertTo(VolumeUnit.cubicMillimeter);

  /// Returns a new [Volume] object representing this volume in Kiloliters (kl).
  Volume get asKiloliters => convertTo(VolumeUnit.kiloliter);

  /// Returns a new [Volume] object representing this volume in Megaliters (Ml).
  Volume get asMegaliters => convertTo(VolumeUnit.megaliter);

  /// Returns a new [Volume] object representing this volume in Gigaliters (Gl).
  Volume get asGigaliters => convertTo(VolumeUnit.gigaliter);

  /// Returns a new [Volume] object representing this volume in Teraliters (Tl).
  Volume get asTeraliters => convertTo(VolumeUnit.teraliter);

  /// Returns a new [Volume] object representing this volume in Liters (L).
  Volume get asLiters => convertTo(VolumeUnit.litre);

  /// Returns a new [Volume] object representing this volume in Milliliters (mL).
  Volume get asMilliliters => convertTo(VolumeUnit.milliliter);

  /// Returns a new [Volume] object representing this volume in Microliters (µL).
  Volume get asMicroliters => convertTo(VolumeUnit.microliter);

  /// Returns a new [Volume] object representing this volume in Cubic Inches (in³).
  Volume get asCubicInches => convertTo(VolumeUnit.cubicInch);

  /// Returns a new [Volume] object representing this volume in Cubic Feet (ft³).
  Volume get asCubicFeet => convertTo(VolumeUnit.cubicFoot);

  /// Returns a new [Volume] object representing this volume in Cubic Miles (mi³).
  Volume get asCubicMiles => convertTo(VolumeUnit.cubicMile);

  /// Returns a new [Volume] object representing this volume in US Gallons (gal).
  Volume get asGallons => convertTo(VolumeUnit.gallon);

  /// Returns a new [Volume] object representing this volume in US Quarts (qt).
  Volume get asQuarts => convertTo(VolumeUnit.quart);

  /// Returns a new [Volume] object representing this volume in US Pints (pt).
  Volume get asPints => convertTo(VolumeUnit.pint);

  /// Returns a new [Volume] object representing this volume in US Fluid Ounces (fl-oz).
  Volume get asFluidOunces => convertTo(VolumeUnit.fluidOunce);

  /// Returns a new [Volume] object representing this volume in US Tablespoons (tbsp).
  Volume get asTablespoons => convertTo(VolumeUnit.tablespoon);

  /// Returns a new [Volume] object representing this volume in US Teaspoons (tsp).
  Volume get asTeaspoons => convertTo(VolumeUnit.teaspoon);
}

/// Provides convenient factory methods for creating [Volume] instances from [num]
/// using getter properties named after common unit symbols or names.
extension VolumeCreation on num {
  // --- SI and Litre Aliases ---

  /// Creates a [Volume] instance from this value in Cubic Meters (m³).
  Volume get m3 => Volume(toDouble(), VolumeUnit.cubicMeter);

  /// Creates a [Volume] instance from this value in Kiloliters (kl).
  Volume get kl => Volume(toDouble(), VolumeUnit.kiloliter);

  /// Creates a [Volume] instance from this value in Cubic Decimeters (dm³).
  Volume get dm3 => Volume(toDouble(), VolumeUnit.cubicDecimeter);

  /// Creates a [Volume] instance from this value in Liters (L).
  Volume get l => Volume(toDouble(), VolumeUnit.litre);

  /// Creates a [Volume] instance from this value in Liters (L).
  /// Alias for `l`.
  Volume get liters => Volume(toDouble(), VolumeUnit.litre);

  /// Creates a [Volume] instance from this value in Cubic Centimeters (cm³).
  Volume get cm3 => Volume(toDouble(), VolumeUnit.cubicCentimeter);

  /// Creates a [Volume] instance from this value in Milliliters (mL).
  Volume get ml => Volume(toDouble(), VolumeUnit.milliliter);

  /// Creates a [Volume] instance from this value in Milliliters (mL).
  /// Alias for `ml`.
  Volume get milliliters => Volume(toDouble(), VolumeUnit.milliliter);

  /// Creates a [Volume] instance from this value in Cubic Millimeters (mm³).
  Volume get mm3 => Volume(toDouble(), VolumeUnit.cubicMillimeter);

  /// Creates a [Volume] instance from this value in Microliters (µL).
  Volume get ul => Volume(toDouble(), VolumeUnit.microliter);

  /// Creates a [Volume] instance from this value in Cubic Decameters (dam³).
  Volume get dam3 => Volume(toDouble(), VolumeUnit.cubicDecameter);

  /// Creates a [Volume] instance from this value in Megaliters (Ml).
  Volume get megaliter => Volume(toDouble(), VolumeUnit.megaliter);

  /// Creates a [Volume] instance from this value in Cubic Hectometers (hm³).
  Volume get hm3 => Volume(toDouble(), VolumeUnit.cubicHectometer);

  /// Creates a [Volume] instance from this value in Gigaliters (Gl).
  Volume get gigaliter => Volume(toDouble(), VolumeUnit.gigaliter);

  /// Creates a [Volume] instance from this value in Cubic Kilometers (km³).
  Volume get km3 => Volume(toDouble(), VolumeUnit.cubicKilometer);

  /// Creates a [Volume] instance from this value in Teraliters (Tl).
  Volume get teraliter => Volume(toDouble(), VolumeUnit.teraliter);

  // --- Imperial / US Customary ---

  /// Creates a [Volume] instance from this value in Cubic Inches (in³).
  Volume get in3 => Volume(toDouble(), VolumeUnit.cubicInch);

  /// Creates a [Volume] instance from this value in Cubic Feet (ft³).
  Volume get ft3 => Volume(toDouble(), VolumeUnit.cubicFoot);

  /// Creates a [Volume] instance from this value in Cubic Miles (mi³).
  Volume get mi3 => Volume(toDouble(), VolumeUnit.cubicMile);

  /// Creates a [Volume] instance from this value in US Gallons (gal).
  Volume get gal => Volume(toDouble(), VolumeUnit.gallon);

  /// Creates a [Volume] instance from this value in US Gallons (gal).
  /// Alias for `gal`.
  Volume get gallons => Volume(toDouble(), VolumeUnit.gallon);

  /// Creates a [Volume] instance from this value in US Quarts (qt).
  Volume get qt => Volume(toDouble(), VolumeUnit.quart);

  /// Creates a [Volume] instance from this value in US Quarts (qt).
  /// Alias for `qt`.
  Volume get quarts => Volume(toDouble(), VolumeUnit.quart);

  /// Creates a [Volume] instance from this value in US Pints (pt).
  Volume get pt => Volume(toDouble(), VolumeUnit.pint);

  /// Creates a [Volume] instance from this value in US Pints (pt).
  /// Alias for `pt`.
  Volume get pints => Volume(toDouble(), VolumeUnit.pint);

  /// Creates a [Volume] instance from this value in US Fluid Ounces (fl-oz).
  Volume get flOz => Volume(toDouble(), VolumeUnit.fluidOunce);

  /// Creates a [Volume] instance from this value in US Tablespoons (tbsp).
  Volume get tbsp => Volume(toDouble(), VolumeUnit.tablespoon);

  /// Creates a [Volume] instance from this value in US Tablespoons (tbsp).
  /// Alias for `tbsp`.
  Volume get tablespoons => Volume(toDouble(), VolumeUnit.tablespoon);

  /// Creates a [Volume] instance from this value in US Teaspoons (tsp).
  Volume get tsp => Volume(toDouble(), VolumeUnit.teaspoon);

  /// Creates a [Volume] instance from this value in US Teaspoons (tsp).
  /// Alias for `tsp`.
  Volume get teaspoons => Volume(toDouble(), VolumeUnit.teaspoon);
}

<!-- END FILE: [v0.12.0] lib/src/units/volume/volume_extensions.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/volume/volume_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various volume units relative to the
/// Cubic Millimeter (mm³), which is the chosen internal base unit for precision.
///
/// These constants represent: `1 [Unit] = Z [Cubic Millimeters]`.
/// By using the smallest SI unit as a base, all other SI units can be
/// represented as precise integers, avoiding floating-point division errors.
class VolumeFactors {
  // --- SI Cubic Units (relative to Cubic Millimeter) ---
  /// The base unit for precise internal calculations.
  static const double mm3 = 1.0;

  /// Cubic Millimeters per Cubic Centimeter (mL): 1 cm³ = 1000 mm³.
  static const double cm3 = mm3 * 1000.0;

  /// Cubic Millimeters per Cubic Decimeter (L): 1 dm³ = 1,000,000 mm³.
  static const double dm3 = cm3 * 1000.0;

  /// Cubic Millimeters per Cubic Meter (kl): 1 m³ = 1,000,000,000 mm³.
  static const double m3 = dm3 * 1000.0;

  /// Cubic Millimeters per Cubic Decameter (Ml).
  static const double dam3 = m3 * 1000.0;

  /// Cubic Millimeters per Cubic Hectometer (Gl).
  static const double hm3 = dam3 * 1000.0;

  /// Cubic Millimeters per Cubic Kilometer (Tl).
  static const double km3 = hm3 * 1000.0;

  // --- Imperial / US Customary Units (relative to Cubic Millimeter) ---
  // A single definition from a precise constant (25.4 mm in an inch).
  /// Cubic Millimeters per Cubic Inch: 1 in³ = (25.4)³ mm³.
  static const double in3 = 16387.064; // 25.4 * 25.4 * 25.4 is exact

  /// Cubic Millimeters per Cubic Foot: 1 ft³ = 1728 in³.
  static const double ft3 = in3 * 1728.0;

  /// Cubic Millimeters per Cubic Mile: 1 mi³ = (5280)³ ft³.
  static const double mi3 = ft3 * 147197952000.0;

  // --- US Customary Liquid Units (relative to Cubic Millimeter) ---
  /// Cubic Millimeters per US Liquid Gallon: 1 gal = 231 in³.
  static const double gal = in3 * 231.0;

  /// Cubic Millimeters per US Liquid Quart: 1 qt = 1/4 gal.
  static const double qt = gal / 4.0;

  /// Cubic Millimeters per US Liquid Pint: 1 pt = 1/2 qt.
  static const double pt = qt / 2.0;

  /// Cubic Millimeters per US Fluid Ounce: 1 fl-oz = 1/16 pt.
  static const double flOz = pt / 16.0;

  // --- US Customary Cooking Units (relative to Cubic Millimeter) ---
  /// Cubic Millimeters per US Tablespoon: 1 tbsp = 1/2 US fl-oz.
  static const double tbsp = flOz / 2.0;

  /// Cubic Millimeters per US Teaspoon: 1 tsp = 1/3 tbsp.
  static const double tsp = tbsp / 3.0;
}

<!-- END FILE: [v0.12.0] lib/src/units/volume/volume_factors.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/src/units/volume/volume_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'volume_factors.dart';

/// Represents units of volume.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each volume unit.
/// All conversion factors are pre-calculated in the constructor relative to
/// Cubic Millimeter (mm³) for maximum precision.
enum VolumeUnit implements Unit<VolumeUnit> {
  // --- SI Cubic ---
  /// Cubic Meter (m³), the SI derived unit of volume.
  cubicMeter(VolumeFactors.m3, 'm³'),

  /// Cubic Decameter (dam³). Also a Megalitre.
  cubicDecameter(VolumeFactors.dam3, 'dam³'),

  /// Cubic Hectometer (hm³). Also a Gigalitre.
  cubicHectometer(VolumeFactors.hm3, 'hm³'),

  /// Cubic Kilometer (km³). Also a Teralitre.
  cubicKilometer(VolumeFactors.km3, 'km³'),

  /// Cubic Decimeter (dm³). Also a Liter.
  cubicDecimeter(VolumeFactors.dm3, 'dm³'),

  /// Cubic Centimeter (cm³). Also a Milliliter.
  cubicCentimeter(VolumeFactors.cm3, 'cm³'),

  /// Cubic Millimeter (mm³). Also a Microliter.
  cubicMillimeter(VolumeFactors.mm3, 'mm³'),

  // --- Litre-based (aliases for cubic measures) ---
  /// Kilolitre (kl). Equivalent to a cubic meter.
  kiloliter(VolumeFactors.m3, 'kl'),

  /// Megalitre (Ml). Equivalent to a cubic decameter.
  megaliter(VolumeFactors.dam3, 'Ml'),

  /// Gigalitre (Gl). Equivalent to a cubic hectometer.
  gigaliter(VolumeFactors.hm3, 'Gl'),

  /// Teralitre (Tl). Equivalent to a cubic kilometer.
  teraliter(VolumeFactors.km3, 'Tl'),

  /// Litre (L). Equivalent to a cubic decimeter.
  litre(VolumeFactors.dm3, 'L'),

  /// Millilitre (mL). Equivalent to a cubic centimeter.
  milliliter(VolumeFactors.cm3, 'mL'),

  /// Microlitre (µL). Equivalent to a cubic millimeter.
  microliter(VolumeFactors.mm3, 'µL'),

  // --- Imperial / US Customary Cubic ---
  /// Cubic Inch (in³).
  cubicInch(VolumeFactors.in3, 'in³'),

  /// Cubic Foot (ft³).
  cubicFoot(VolumeFactors.ft3, 'ft³'),

  /// Cubic Mile (mi³).
  cubicMile(VolumeFactors.mi3, 'mi³'),

  // --- US Customary Liquid ---
  /// US Liquid Gallon (gal).
  gallon(VolumeFactors.gal, 'gal'),

  /// US Liquid Quart (qt).
  quart(VolumeFactors.qt, 'qt'),

  /// US Liquid Pint (pt).
  pint(VolumeFactors.pt, 'pt'),

  /// US Fluid Ounce (fl-oz).
  fluidOunce(VolumeFactors.flOz, 'fl-oz'),

  // --- US Customary Cooking ---
  /// Tablespoon (tbsp).
  tablespoon(VolumeFactors.tbsp, 'tbsp'),

  /// Teaspoon (tsp).
  teaspoon(VolumeFactors.tsp, 'tsp');

  /// Constant constructor for enum members.
  const VolumeUnit(double toCubicMillimeterFactor, this.symbol)
      : _toCubicMillimeterFactor = toCubicMillimeterFactor,
        _factorToCubicMeter = toCubicMillimeterFactor / VolumeFactors.m3,
        _factorToCubicDecameter = toCubicMillimeterFactor / VolumeFactors.dam3,
        _factorToCubicHectometer = toCubicMillimeterFactor / VolumeFactors.hm3,
        _factorToCubicKilometer = toCubicMillimeterFactor / VolumeFactors.km3,
        _factorToCubicDecimeter = toCubicMillimeterFactor / VolumeFactors.dm3,
        _factorToCubicCentimeter = toCubicMillimeterFactor / VolumeFactors.cm3,
        _factorToCubicMillimeter = toCubicMillimeterFactor / VolumeFactors.mm3,
        _factorToKiloliter = toCubicMillimeterFactor / VolumeFactors.m3,
        _factorToMegaliter = toCubicMillimeterFactor / VolumeFactors.dam3,
        _factorToGigaliter = toCubicMillimeterFactor / VolumeFactors.hm3,
        _factorToTeraliter = toCubicMillimeterFactor / VolumeFactors.km3,
        _factorToLitre = toCubicMillimeterFactor / VolumeFactors.dm3,
        _factorToMilliliter = toCubicMillimeterFactor / VolumeFactors.cm3,
        _factorToMicroliter = toCubicMillimeterFactor / VolumeFactors.mm3,
        _factorToCubicInch = toCubicMillimeterFactor / VolumeFactors.in3,
        _factorToCubicFoot = toCubicMillimeterFactor / VolumeFactors.ft3,
        _factorToCubicMile = toCubicMillimeterFactor / VolumeFactors.mi3,
        _factorToGallon = toCubicMillimeterFactor / VolumeFactors.gal,
        _factorToQuart = toCubicMillimeterFactor / VolumeFactors.qt,
        _factorToPint = toCubicMillimeterFactor / VolumeFactors.pt,
        _factorToFluidOunce = toCubicMillimeterFactor / VolumeFactors.flOz,
        _factorToTablespoon = toCubicMillimeterFactor / VolumeFactors.tbsp,
        _factorToTeaspoon = toCubicMillimeterFactor / VolumeFactors.tsp;

  // ignore: unused_field // Conversion factor to Cubic Meter
  final double _toCubicMillimeterFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors ---
  final double _factorToCubicMeter;
  final double _factorToCubicDecameter;
  final double _factorToCubicHectometer;
  final double _factorToCubicKilometer;
  final double _factorToCubicDecimeter;
  final double _factorToCubicCentimeter;
  final double _factorToCubicMillimeter;
  final double _factorToKiloliter;
  final double _factorToMegaliter;
  final double _factorToGigaliter;
  final double _factorToTeraliter;
  final double _factorToLitre;
  final double _factorToMilliliter;
  final double _factorToMicroliter;
  final double _factorToCubicInch;
  final double _factorToCubicFoot;
  final double _factorToCubicMile;
  final double _factorToGallon;
  final double _factorToQuart;
  final double _factorToPint;
  final double _factorToFluidOunce;
  final double _factorToTablespoon;
  final double _factorToTeaspoon;

  @override
  @internal
  double factorTo(VolumeUnit targetUnit) {
    switch (targetUnit) {
      case VolumeUnit.cubicMeter:
        return _factorToCubicMeter;
      case VolumeUnit.cubicDecameter:
        return _factorToCubicDecameter;
      case VolumeUnit.cubicHectometer:
        return _factorToCubicHectometer;
      case VolumeUnit.cubicKilometer:
        return _factorToCubicKilometer;
      case VolumeUnit.cubicDecimeter:
        return _factorToCubicDecimeter;
      case VolumeUnit.cubicCentimeter:
        return _factorToCubicCentimeter;
      case VolumeUnit.cubicMillimeter:
        return _factorToCubicMillimeter;
      case VolumeUnit.kiloliter:
        return _factorToKiloliter;
      case VolumeUnit.megaliter:
        return _factorToMegaliter;
      case VolumeUnit.gigaliter:
        return _factorToGigaliter;
      case VolumeUnit.teraliter:
        return _factorToTeraliter;
      case VolumeUnit.litre:
        return _factorToLitre;
      case VolumeUnit.milliliter:
        return _factorToMilliliter;
      case VolumeUnit.microliter:
        return _factorToMicroliter;
      case VolumeUnit.cubicInch:
        return _factorToCubicInch;
      case VolumeUnit.cubicFoot:
        return _factorToCubicFoot;
      case VolumeUnit.cubicMile:
        return _factorToCubicMile;
      case VolumeUnit.gallon:
        return _factorToGallon;
      case VolumeUnit.quart:
        return _factorToQuart;
      case VolumeUnit.pint:
        return _factorToPint;
      case VolumeUnit.fluidOunce:
        return _factorToFluidOunce;
      case VolumeUnit.tablespoon:
        return _factorToTablespoon;
      case VolumeUnit.teaspoon:
        return _factorToTeaspoon;
    }
  }
}

<!-- END FILE: [v0.12.0] lib/src/units/volume/volume_unit.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/temperature.dart -->
/// Provides type-safe units for Temperature.
///
/// Import this file to use Temperature quantities and their extensions on `num`
/// (like `25.celsius`, `300.kelvin`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/temperature/temperature.dart';
export 'src/units/temperature/temperature_extensions.dart';
export 'src/units/temperature/temperature_unit.dart';

<!-- END FILE: [v0.12.0] lib/temperature.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/time.dart -->
/// Provides type-safe units for Time.
///
/// Import this file to use Time quantities and their extensions on `num`
/// (like `60.s`, `1.5.h`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/time/time.dart';
export 'src/units/time/time_extensions.dart';
export 'src/units/time/time_unit.dart';

<!-- END FILE: [v0.12.0] lib/time.dart -->

<!-- BEGIN FILE: [v0.12.0] lib/volume.dart -->
/// Provides type-safe units for Volume.
///
/// Import this file to use Volume quantities and their extensions on `num`
/// (like `1.5.l`, `2.m3`, `8.fl_oz`).
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
export 'src/units/volume/volume.dart';
export 'src/units/volume/volume_extensions.dart';
export 'src/units/volume/volume_unit.dart';

<!-- END FILE: [v0.12.0] lib/volume.dart -->

<!-- BEGIN FILE: [v0.12.0] example/analysis_options.yaml -->
include: package:very_good_analysis/analysis_options.yaml

formatter:
  page_width: 100
#  trailing_commas: preserve

analyzer:
  errors:
    unused_import: warning
    todo: ignore

linter:
  rules:
    # Allow relative imports for files within the same package
    always_use_package_imports: false
    # Prefer using relative imports within the same package
    prefer_relative_imports: true
    # Allow lines to exceed 80 characters
    lines_longer_than_80_chars: false
    # Prefer using const constructors where possible
    prefer_const_constructors: true
    # Prefer declaring local variables as final if they are not reassigned
    prefer_final_locals: true
    # Allow mutable literal lists/maps/sets even if they could be const
    prefer_const_literals_to_create_immutables: false
    # Allow explicitly typing closure parameters
    avoid_types_on_closure_parameters: false
    # Use trailing commas for all parameter lists and argument lists.
    require_trailing_commas: true
    # Use enums rather than classes that behave like enums.
    use_enums: true
    # Allow using print() for debugging purposes
    avoid_print: false
<!-- END FILE: [v0.12.0] example/analysis_options.yaml -->

<!-- BEGIN FILE: [v0.12.0] example/lib/constants_example.dart -->
/// A comprehensive example demonstrating the use of the `quantify` constants library.
///
/// This file showcases how to access and use the type-safe physical,
/// astronomical, and engineering constants for practical, type-safe calculations,
/// and how to format the output elegantly.
library;

import 'package:quantify/constants.dart';
import 'package:quantify/quantify.dart';

void main() {
  print('--- Quantify Constants and Formatting Showcase ---');

  // --- 1. Basic Usage: Accessing Type-Safe Constants ---
  print('\n--- 1. Basic Usage ---');

  // Constants are pre-defined, type-safe Quantity objects.
  const speedOfLight = PhysicalConstants.speedOfLight;
  const earthMass = AstronomicalConstants.earthMass;

  // The built-in toString() method provides sensible defaults.
  print('Speed of Light: $speedOfLight'); // A Speed object
  print('Mass of the Earth: $earthMass'); // A Mass object

  // --- 2. Type Safety in Action ---
  print('\n--- 2. Type Safety Showcase ---');

  // CORRECT: The Force.from() constructor requires Mass and Acceleration.
  // Using constants ensures you provide the correct physical quantities.
  final weightOfElectron = Force.from(
    PhysicalConstants.electronMass,
    AstronomicalConstants.standardGravity,
  );
  print('Weight of an electron on Earth: $weightOfElectron');

  // INCORRECT: The compiler prevents mistakes like adding a speed to a mass.
  // final compileError = PhysicalConstants.speedOfLight + PhysicalConstants.electronMass;
  print('✅ Type safety prevents dimensionally incorrect operations at compile-time.');

  // --- 3. Practical Calculations & Formatting ---
  print('\n--- 3. Practical Calculations & Formatting ---');

  // Example A: Calculate the energy of a red light photon (~650 nm).
  final redLightWavelength = 650.nm;
  final photonEnergy = PhysicalConstants.photonEnergy(redLightWavelength);
  print(
    'Energy of a 650 nm photon: ${photonEnergy.toString(targetUnit: EnergyUnit.electronvolt, fractionDigits: 2)}',
  );

  // Example B: Calculate the escape velocity from the Moon's surface.
  final moonEscapeVelocity = AstronomicalConstants.escapeVelocity(
    AstronomicalConstants.moonMass,
    AstronomicalConstants.moonRadius,
  );
  print(
    'Escape velocity from the Moon: ${moonEscapeVelocity.asKilometersPerSecond.toString(fractionDigits: 2)}',
  );

  // Example C: Compare material strengths.
  final steelStrength = EngineeringConstants.steelTensileStrength.asMegaPascals;
  final aluminumModulus = EngineeringConstants.aluminumYoungsModulus.asAtm;
  final isSteelStronger = steelStrength > aluminumModulus;

  print(
    "Is steel's tensile strength (${steelStrength.toString(fractionDigits: 0)})"
    " greater than aluminum's stiffness (${aluminumModulus.toString(fractionDigits: 0)})?",
  );
  print('Answer: $isSteelStronger');

  // Example D: How many times more massive is the Sun than the Earth?
  const sunMass = AstronomicalConstants.solarMass;
  // To get a ratio, convert both quantities to the same unit and divide their double values.
  final massRatio = sunMass.inKilograms / earthMass.inKilograms;
  print(
    'The Sun is ${massRatio.toStringAsFixed(0)} times more massive than the Earth.',
  );

  // --- 4. Advanced Formatting with Locales ---
  print('\n--- 4. Advanced Formatting with Locales (requires intl package) ---');

  // Let's calculate a large distance, like the nearest star system.
  final alphaCentauriDistance = 4.37.ly;

  // Default US-style formatting with thousands separators.
  print(
    'Distance to Alpha Centauri: ${alphaCentauriDistance.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 0, locale: 'en_US')}',
  );

}

<!-- END FILE: [v0.12.0] example/lib/constants_example.dart -->

<!-- BEGIN FILE: [v0.12.0] example/lib/example.dart -->
// quantify v0.9.0
import 'dart:math' as math;

import 'package:quantify/quantify.dart';

void main() {
  // Define our pizza diameters
  final Length diam18 = 18.inch;
  final Length diam12 = 12.inch;

  // Calculate the area of each (Area = π * r²)
  final Area pizza18 = (math.pi * math.pow(diam18.inInch / 2, 2)).in2;
  final Area pizza12 = (math.pi * math.pow(diam12.inInch / 2, 2)).in2;

  print('One 18-inch pizza: ${pizza18.toString(fractionDigits: 0)}');
  print('Two 12-inch pizzas: ${(pizza12 * 2).toString(fractionDigits: 0)}');

  if (pizza18 > pizza12 * 2) {
    print(
      'The 18-inch pizza is MORE pizza! '
      '(By ${(pizza18 - pizza12 * 2).toString(fractionDigits: 0)})',
    );
  }

  // Output:
  // One 18-inch pizza: 254 in²
  // Two 12-inch pizzas: 226 in²
  // The 18-inch pizza is MORE pizza! (By 28 in²)
}

<!-- END FILE: [v0.12.0] example/lib/example.dart -->

<!-- BEGIN FILE: [v0.12.0] example/lib/main.dart -->
import 'package:intl/intl.dart'; // For locale-specific number formatting
import 'package:quantify/quantify.dart';

void main() {
  print('--- Quantify CLI Example ---');

  // 1. Create and convert lengths
  print('\n--- Length ---');
  final pathA = 1500.m; // Using .m as requested
  final pathB = 2.5.km;

  print('Path A: $pathA'); // Default toString
  print('Path A in Kilometers: ${pathA.inKm} km');
  print(
    'Path A (formatted): ${pathA.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 1)}',
  );
  print(
    'Path B in Miles: ${pathB.toString(targetUnit: LengthUnit.mile, fractionDigits: 2)}',
  );

  // 2. Arithmetic with lengths
  final totalDistance = pathA + pathB; // pathB is automatically converted to meters
  print('Total Distance: ${totalDistance.toString(fractionDigits: 0)}');
  print(
    'Total Distance in Yards: ${totalDistance.toString(targetUnit: LengthUnit.yard, fractionDigits: 0, unitSymbolSeparator: '\u00A0')}',
  );

  final scaledDistance = pathA * 3;
  print('Path A scaled by 3: $scaledDistance');

  // 3. Times
  print('\n--- Time ---');
  final duration1 = 90.minutes;
  final duration2 = 0.5.hours;

  print('Duration 1: $duration1');
  print('Duration 1 in Hours: ${duration1.inHours} h');
  print('Duration 2: ${duration2.toString(targetUnit: TimeUnit.minute)}');

  final totalTime = duration1 + duration2; // 90 min + 30 min = 120 min
  print('Total Time: ${totalTime.toString(targetUnit: TimeUnit.hour)}'); // "2.0 h"

  // 4. Temperatures
  print('\n--- Temperature ---');
  final roomTempC = 20.celsius;
  print('Room Temperature: $roomTempC');
  print('Room Temperature in Fahrenheit: ${roomTempC.inFahrenheit} °F');
  print(
    'Room Temperature in Kelvin: ${roomTempC.convertTo(TemperatureUnit.kelvin)}',
  );

  final boilingPoint = 100.celsius;
  final freezingPoint = 0.celsius;
  final tempDifference = boilingPoint - freezingPoint; // Returns a double
  print('Difference between boiling and freezing point of water: $tempDifference C°');

  // Caution with temperature division (consider physical meaning)
  try {
    final tempRatio = 200.kelvin / 100.kelvin; // Meaningful
    print('Ratio 200K / 100K: $tempRatio');
    // final problematicRatio = 20.celsius / 10.celsius; // Mathematically 2.0, but often not directly interpretable physically
    // print('Ratio 20°C / 10°C: $problematicRatio');
  } on Exception catch (e) {
    print('Error during temperature division: $e');
  }

  // 5. Pressures
  print('\n--- Pressure ---');
  final pAtm = 1.atm; // Standard atmosphere
  print('Standard Atmosphere: $pAtm');
  print('Standard Atmosphere in Pascals: ${pAtm.inPa} Pa');
  print('Standard Atmosphere in PSI: ${pAtm.asPsi.toString(fractionDigits: 2)}');
  print(
    'Standard Atmosphere in bar: ${pAtm.toString(targetUnit: PressureUnit.bar, fractionDigits: 3)}',
  );

  final tirePressure = 32.psi;
  print('Tire Pressure: ${tirePressure.toString(targetUnit: PressureUnit.bar, fractionDigits: 2)}');

  // 6. Comparisons
  print('\n--- Comparisons ---');
  final oneKm = 1.km;
  final oneMile = 1.mi;
  final thousandMeters = 1000.m; // Using .m

  print(
    '1 km == 1000 m (value & unit): ${oneKm == thousandMeters}',
  ); // false (same value, but km vs m unit)
  print('1 km.compareTo(1000 m): ${oneKm.compareTo(thousandMeters)}'); // 0 (same magnitude)
  print('1 km > 1 mile: ${oneKm.compareTo(oneMile) > 0}'); // false
  // print('1 mile > 1 km: ${oneMile > oneKm}'); // true (syntactic sugar for compareTo)

  final lengths = [10.m, 500.cm, 0.002.km, 1.ft];
  print(
    'Unsorted lengths: ${lengths.map((l) => l.toString(targetUnit: LengthUnit.meter)).toList()}',
  );
  lengths.sort();
  print('Sorted lengths: ${lengths.map((l) => l.toString(targetUnit: LengthUnit.meter)).toList()}');

  // 7. Locale-specific Formatting (requires 'intl' package)
  print('\n--- Locale-specific Formatting ---');
  final distanceDE = 1234.567.m; // Using .m
  // Standard (US-like locale from Dart, usually '.')
  print(
    'Distance DE (default locale): ${distanceDE.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2)}',
  );

  // German (de_DE)
  // To use NumberFormat for a specific locale, it needs to be initialized.
  // Usually, this is done globally with `Intl.defaultLocale = 'de_DE';`
  // or it's passed directly to `NumberFormat`.
  // quantify's toString() uses NumberFormat.decimalPatternDigits if locale and fractionDigits are given.
  print(
    'Distance DE (de_DE locale): ${distanceDE.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2, locale: 'de_DE')}',
  );
  // Output: "1,23 km" (with comma as decimal separator)

  // With a custom NumberFormat for decimal pattern
  final valueOnlyFormat = NumberFormat.decimalPatternDigits(locale: 'fr_FR', decimalDigits: 3);
  print(
    'Distance (fr_FR locale, custom NumberFormat, value only): ${distanceDE.toString(numberFormat: valueOnlyFormat, showUnitSymbol: false, targetUnit: LengthUnit.kilometer)}',
  );
  // Output: "1,235" (with comma as decimal separator and 3 decimal places)

  print('\n--- End of Example ---');
}

<!-- END FILE: [v0.12.0] example/lib/main.dart -->

<!-- BEGIN FILE: [v0.12.0] example/pubspec.yaml -->
name: quantify_example
description: A command-line example for the quantify package.
version: 1.0.0
publish_to: "none"

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  intl: ^0.19.0
  quantify: ^0.12.0


dev_dependencies:
  test: ^1.26.0
  very_good_analysis: ^8.0.0

<!-- END FILE: [v0.12.0] example/pubspec.yaml -->

<!-- BEGIN FILE: [v0.12.0] test/units/acceleration_test.dart -->
import 'package:quantify/acceleration.dart';
import 'package:quantify/speed.dart';
import 'package:quantify/time.dart';
import 'package:test/test.dart';

void main() {
  group('Acceleration', () {
    const tolerance = 1e-12;

    group('Constructors and Getters', () {
      test('should create from num extensions and retrieve values', () {
        final gravity = 1.gravity;
        expect(gravity.value, 1.0);
        expect(gravity.unit, AccelerationUnit.standardGravity);
        expect(gravity.inMetersPerSecondSquared, closeTo(9.80665, tolerance));
      });
    });

    group('Conversions', () {
      test('Standard Gravity to m/s²', () {
        final gravity = 2.gravity;
        expect(gravity.inMetersPerSecondSquared, closeTo(2 * 9.80665, tolerance));
      });

      test('m/s² to other units', () {
        final acc = 9.80665.mpsSquared;
        expect(acc.inStandardGravity, closeTo(1.0, tolerance));
        expect(acc.inFeetPerSecondSquared, closeTo(32.1740, 1e-4));
      });

      test('Automotive performance units', () {
        // A car accelerating at 10 (km/h)/s
        final carAcc = 10.kmhPerS;
        const expectedMpss = 10 * 1000 / 3600; // ~2.77 m/s²
        expect(carAcc.inMetersPerSecondSquared, closeTo(expectedMpss, tolerance));
        // Check how many 'g's this is
        expect(carAcc.inStandardGravity, closeTo(expectedMpss / 9.80665, tolerance));
      });

      test('Centimeter per second squared (Galileo)', () {
        // 1 m/s² = 100 cm/s²
        final acc = 1.mpsSquared;
        expect(acc.inCentimetersPerSecondSquared, closeTo(100.0, 1e-12));

        final galileo = 500.gal;
        expect(galileo.inMetersPerSecondSquared, closeTo(5.0, 1e-12));
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final a1 = 9.80665.mpsSquared;
        final a2 = 1.gravity;
        final a3 = 10.0.mpsSquared;

        expect(a1.compareTo(a2), 0);
        expect(a3.compareTo(a1), greaterThan(0));
        expect(a1.compareTo(a3), lessThan(0));
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction', () {
        final sum = 1.gravity + 0.19335.mpsSquared; // 9.80665 + 0.19335 = 10.0
        expect(sum.inMetersPerSecondSquared, closeTo(10.0, tolerance));
        expect(sum.unit, AccelerationUnit.standardGravity);
      });

      test('should perform scalar multiplication and division', () {
        final acc = 0.5.gravity;
        expect((acc * 2.0).inStandardGravity, closeTo(1.0, tolerance));
        expect((acc / 2.0).inStandardGravity, closeTo(0.25, tolerance));
        expect(() => acc / 0, throwsArgumentError);
      });
    });

    group('Dimensional Analysis', () {
      test('Speed / Time = Acceleration', () {
        final speedChange = 100.kmh;
        final time = 10.s;
        final acc = Acceleration.from(speedChange, time);

        expect(acc, isA<Acceleration>());
        // 100 km/h is ~27.77 m/s. Over 10s, this is ~2.77 m/s²
        expect(acc.inMetersPerSecondSquared, closeTo(2.777, 1e-3));

        expect(() => Acceleration.from(100.kmh, 0.s), throwsArgumentError);
      });

      test('Acceleration * Time = Speed', () {
        final acc = 2.gravity; // ~19.6 m/s²
        final time = 2.s;
        final speed = acc.speedGainedOver(time);

        expect(speed, isA<Speed>());
        expect(speed.inMps, closeTo(2 * 9.80665 * 2, tolerance));
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in AccelerationUnit.values) {
        test('Round trip ${unit.symbol} <-> m/s²', () {
          const initialValue = 12.345;
          final acc = Acceleration(initialValue, unit);
          final roundTripAcc = acc.asMetersPerSecondSquared.convertTo(unit);
          expect(roundTripAcc.value, closeTo(initialValue, 1e-9));
        });
      }
    });

    group('Practical Examples', () {
      test('Free fall calculation', () {
        final gravity = 1.gravity;
        final fallTime = 5.s;
        // v = a * t
        final finalSpeed = gravity.speedGainedOver(fallTime);

        expect(finalSpeed.inMps, closeTo(9.80665 * 5, tolerance));
        expect(finalSpeed.inKmh, closeTo(9.80665 * 5 * 3.6, tolerance));
      });

      test('Car performance (0 to 100 km/h)', () {
        // A sports car goes from 0 to 100 km/h in 3.5 seconds
        final speedChange = 100.kmh;
        final timeTaken = 3.5.s;
        final averageAcceleration = Acceleration.from(speedChange, timeTaken);

        // Express acceleration in 'g's
        expect(averageAcceleration.inStandardGravity, closeTo(0.8, 0.01));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/acceleration_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/angle_test.dart -->
// test/units/angle_test.dart
import 'dart:math' as math;

import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('Angle', () {
    const tolerance = 1e-12; // High precision for angular conversions

    // Helper for round trip tests
    void testRoundTrip(
      AngleUnit initialUnit,
      AngleUnit intermediateUnit,
      double initialValue,
    ) {
      final a1 = Angle(initialValue, initialUnit);
      final a2 = a1.convertTo(intermediateUnit);
      final a3 = a2.convertTo(initialUnit);
      expect(
        a3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Angle from num extensions and retrieve values', () {
        final angleDeg = 90.0.degrees;
        expect(angleDeg.value, 90.0);
        expect(angleDeg.unit, AngleUnit.degree);
        expect(angleDeg.inRadians, closeTo(math.pi / 2, tolerance));

        final angleRad = math.pi.radians;
        expect(angleRad.value, math.pi);
        expect(angleRad.unit, AngleUnit.radian);
        expect(angleRad.inDegrees, closeTo(180.0, tolerance));
      });
    });

    group('Conversions', () {
      test('Degree to Radian and Gradian', () {
        final angle = 180.0.degrees;
        expect(angle.inRadians, closeTo(math.pi, tolerance));
        expect(angle.inGradians, closeTo(200.0, tolerance));
        expect(angle.inRevolutions, closeTo(0.5, tolerance));
      });

      test('Radian to Degree and Revolution', () {
        final angle = (2 * math.pi).radians;
        expect(angle.inDegrees, closeTo(360.0, tolerance));
        expect(angle.inRevolutions, closeTo(1.0, tolerance));
      });

      test('Gradian to Degree', () {
        final angle = 100.0.gradians;
        expect(angle.inDegrees, closeTo(90.0, tolerance));
      });

      test('Revolution to other units', () {
        final angle = 0.25.rev; // 90 degrees
        expect(angle.inDegrees, closeTo(90.0, tolerance));
        expect(angle.inRadians, closeTo(math.pi / 2, tolerance));
      });

      test('Arcminute and Arcsecond conversions', () {
        final oneDegree = 1.0.degrees;
        expect(oneDegree.inArcminutes, closeTo(60.0, tolerance));
        expect(oneDegree.inArcseconds, closeTo(3600.0, tolerance));

        final oneArcminute = 1.0.arcminutes;
        expect(oneArcminute.inDegrees, closeTo(1 / 60, tolerance));
      });

      test('Milliradian conversions', () {
        final oneRadian = 1.0.radians;
        expect(oneRadian.inMilliradians, closeTo(1000.0, tolerance));
        final tenMrad = 10.mrad;
        expect(tenMrad.inRadians, closeTo(0.01, tolerance));
      });
    });

    group('Comparison (compareTo)', () {
      test('should correctly compare angles of different units', () {
        final a1 = 90.0.degrees;
        final a2 = (math.pi / 2).radians;
        final a3 = 100.0.gradians;
        final a4 = 89.0.degrees;

        // Diese Vergleiche werden nun alle korrekt sein.
        expect(
          a1.compareTo(a3),
          0,
          reason: '90 degrees should be exactly equal to 100 gradians',
        );

        // Dieser Vergleich kann immer noch eine winzige Abweichung haben,
        // da math.pi/2 selbst eine Annäherung ist.
        // Es ist besser, ihn so zu lassen oder einen closeTo Vergleich zu machen.
        // compareTo(a2) sollte aber auch 0 sein, da die internen Faktoren nun konsistenter sind.
        expect(a1.compareTo(a2), 0);

        expect(a1.compareTo(a4), greaterThan(0));
        expect(a4.compareTo(a1), lessThan(0));
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const a1 = Angle(45, AngleUnit.degree);
        const a2 = Angle(45, AngleUnit.degree);
        expect(a1 == a2, isTrue);
        expect(a1.hashCode == a2.hashCode, isTrue);
      });

      test('should not be equal for different value or unit', () {
        final a1 = 45.0.degrees;
        final a2 = (math.pi / 4).radians;
        expect(a1 == a2, isFalse); // Different units
        expect(a1.compareTo(a2), 0); // Same magnitude
      });
    });

    group('Arithmetic Operators', () {
      test('should perform addition and subtraction correctly', () {
        final result = 90.degrees + (math.pi / 4).radians; // 90 + 45 = 135
        expect(result.inDegrees, closeTo(135.0, tolerance));
        expect(result.unit, AngleUnit.degree); // Left operand's unit

        final result2 = result - 45.degrees;
        expect(result2.inDegrees, closeTo(90.0, tolerance));
      });

      test('should perform multiplication and division correctly', () {
        final angle = 30.0.degrees;
        expect((angle * 3.0).inDegrees, closeTo(90.0, tolerance));
        expect((angle / 2.0).inDegrees, closeTo(15.0, tolerance));
        expect(() => angle / 0.0, throwsArgumentError);
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in AngleUnit.values) {
        test('Round trip ${unit.symbol} <-> rad', () {
          testRoundTrip(unit, AngleUnit.radian, 123.456);
        });
      }
      test('Round trip deg <-> grad', () {
        testRoundTrip(AngleUnit.degree, AngleUnit.gradian, 90);
      });
    });

    group('Practical Examples', () {
      test('Trigonometry using dart:math', () {
        final angle = 30.0.degrees;
        // dart:math functions require radians
        final sinValue = math.sin(angle.inRadians);
        expect(sinValue, closeTo(0.5, tolerance));

        final angle45 = (math.pi / 4).radians;
        final cosValue = math.cos(angle45.inRadians);
        final sinValue45 = math.sin(angle45.inRadians);
        expect(cosValue, closeTo(sinValue45, tolerance));
      });

      test('Geometry: sum of angles in a triangle', () {
        final a1 = 60.degrees;
        final a2 = 60.degrees;
        final a3 = 60.degrees;
        final sum = a1 + a2 + a3;
        expect(sum.inDegrees, closeTo(180.0, tolerance));
        expect(sum.inRadians, closeTo(math.pi, tolerance));
      });

      test('Rotational mechanics', () {
        // A wheel turns 3.5 revolutions
        final rotation = 3.5.revolutions;
        expect(rotation.inDegrees, closeTo(3.5 * 360, tolerance));
        // Find angle in a standard coordinate system (modulo 360)
        final finalAngle = rotation.inDegrees % 360;
        expect(finalAngle, closeTo(180.0, tolerance));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/angle_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/angular_velocity_test.dart -->
// test/units/angular_velocity_test.dart
import 'dart:math' as math;

import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('AngularVelocity', () {
    const tolerance = 1e-12;

    group('Constructors and Getters', () {
      test('should create from num extensions and retrieve values', () {
        final speed = 3000.0.rpm;
        expect(speed.value, 3000.0);
        expect(speed.unit, AngularVelocityUnit.revolutionPerMinute);
        const expectedRadPerSec = 3000.0 * (2 * math.pi) / 60.0;
        expect(speed.inRadiansPerSecond, closeTo(expectedRadPerSec, tolerance));
      });
    });

    group('Conversions', () {
      test('RPM to RPS and Rad/s', () {
        final speed = 60.0.rpm;
        expect(speed.inRps, closeTo(1.0, tolerance));
        expect(speed.inRadiansPerSecond, closeTo(2 * math.pi, tolerance));
      });

      test('Rad/s to others', () {
        final speed = math.pi.radiansPerSecond; // 180°/s or 0.5 rps
        expect(speed.inDegreesPerSecond, closeTo(180.0, tolerance));
        expect(speed.inRps, closeTo(0.5, tolerance));
        expect(speed.inRpm, closeTo(30.0, tolerance));
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final s1 = 60.0.rpm;
        final s2 = 1.0.rps;
        final s3 = 59.0.rpm;

        expect(s1.compareTo(s2), 0);
        expect(s1.compareTo(s3), greaterThan(0));
        expect(s3.compareTo(s1), lessThan(0));
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction', () {
        final sum = 10.rps + 60.rpm; // 10 rps + 1 rps = 11 rps
        expect(sum.inRps, closeTo(11.0, tolerance));
        expect(sum.unit, AngularVelocityUnit.revolutionPerSecond);
      });

      test('should perform scalar multiplication and division', () {
        final speed = 100.0.rpm;
        expect((speed * 2.0).inRpm, closeTo(200.0, tolerance));
        expect((speed / 4.0).inRpm, closeTo(25.0, tolerance));
      });
    });

    group('Dimensional Analysis (Interaction with other Quantities)', () {
      test('AngularVelocity * Time = Angle', () {
        final speed = 3000.0.rpm;
        final duration = 2.0.seconds;
        final totalAngle = speed.totalAngleOver(duration);

        expect(totalAngle, isA<Angle>());
        // 3000 rev/min = 50 rev/sec. Over 2 seconds -> 100 revolutions.
        expect(totalAngle.inRevolutions, closeTo(100.0, tolerance));
        expect(totalAngle.inDegrees, closeTo(100.0 * 360, tolerance));
      });

      test('A full rotation check', () {
        final speed = 360.0.degreesPerSecond;
        final duration = 1.0.seconds;
        final angle = speed.totalAngleOver(duration);

        expect(angle.inRevolutions, closeTo(1.0, tolerance));
      });
    });

    group('Practical Examples', () {
      test('Car Engine', () {
        // An engine idles at 800 rpm and has a redline at 7000 rpm.
        final idleSpeed = 800.rpm;
        final redline = 7000.rpm;

        expect(idleSpeed.compareTo(redline), lessThan(0));
        expect(redline.inRps, closeTo(7000.0 / 60.0, tolerance));

        // How many full rotations in 100 milliseconds at redline?
        final angleTurned = redline.totalAngleOver(100.milliseconds);
        expect(angleTurned.inRevolutions, closeTo(7000.0 / 60.0 * 0.1, tolerance));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/angular_velocity_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/area_test.dart -->
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons
  const highTolerance = 1e-6; // For conversions involving many decimal places

  group('Area', () {
    // Helper for round trip tests
    void testRoundTrip(
      AreaUnit initialUnit,
      AreaUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final a1 = Area(initialValue, initialUnit);
      final a2 = a1.convertTo(intermediateUnit);
      final a3 = a2.convertTo(initialUnit);
      expect(
        a3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Area from num extensions and retrieve values', () {
        final a1 = 100.0.m2;
        expect(a1.value, 100.0);
        expect(a1.unit, AreaUnit.squareMeter);
        expect(a1.inSquareKilometers, closeTo(0.0001, tolerance));

        final a2 = 5.0.ft2;
        expect(a2.value, 5.0);
        expect(a2.unit, AreaUnit.squareFoot);
        expect(a2.inSquareInches, closeTo(720.0, tolerance)); // 5 * 144

        final a3 = 1.ha;
        expect(a3.value, 1.0);
        expect(a3.unit, AreaUnit.hectare);
        expect(a3.inSquareMeters, closeTo(10000.0, tolerance));

        final a4 = 1.0.squareMegameter;
        expect(a4.value, 1.0);
        expect(a4.unit, AreaUnit.squareMegameter);
        expect(a4.inSquareKilometers, closeTo(1000000.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const a = Area(25, AreaUnit.squareCentimeter);
        expect(a.getValue(AreaUnit.squareCentimeter), 25.0);
      });

      test('getValue for all units from Square Meter base', () {
        final a = 10000.0.m2; // 1 hectare
        expect(a.inSquareMeters, 10000.0);
        expect(a.inHectares, closeTo(1.0, tolerance));
        expect(a.inSquareCentimeters, closeTo(10000 * 10000, tolerance));
        expect(a.inSquareMillimeters, closeTo(10000 * 1000000, tolerance));
        expect(a.inSquareInches, closeTo(10000 / 0.00064516, highTolerance));
        expect(a.inSquareFeet, closeTo(10000 / 0.09290304, highTolerance));
        expect(a.inAcres, closeTo(10000 / 4046.8564224, highTolerance));
        expect(a.inSquareMegameters, closeTo(10000 / 1e12, highTolerance));
      });
    });

    group('Conversions', () {
      final oneSquareMeter = 1.0.m2;

      test('1 square meter to various units', () {
        expect(oneSquareMeter.inSquareKilometers, closeTo(1e-6, tolerance));
        expect(oneSquareMeter.inSquareCentimeters, closeTo(10000.0, tolerance));
        expect(oneSquareMeter.inSquareMillimeters, closeTo(1000000.0, tolerance));
        expect(oneSquareMeter.inSquareInches, closeTo(1 / 0.00064516, highTolerance));
        expect(oneSquareMeter.inSquareFeet, closeTo(1 / 0.09290304, highTolerance));
        expect(oneSquareMeter.inAcres, closeTo(1 / 4046.8564224, highTolerance));
        expect(oneSquareMeter.inSquareMegameters, closeTo(1 / 1e12, highTolerance));
      });

      final oneAcre = 1.0.ac;
      test('1 acre to various units', () {
        expect(oneAcre.inSquareMeters, closeTo(4046.8564224, tolerance));
        expect(oneAcre.inHectares, closeTo(0.40468564224, tolerance));
        expect(oneAcre.inSquareFeet, closeTo(43560.0, tolerance));
        expect(oneAcre.inSquareMiles, closeTo(1 / 640.0, tolerance));
      });

      final oneSquareMile = 1.0.mi2;
      test('1 square mile to various units', () {
        expect(oneSquareMile.inSquareMeters, closeTo(2589988.110336, tolerance));
        expect(oneSquareMile.inAcres, closeTo(640.0, tolerance));
        expect(oneSquareMile.inSquareKilometers, closeTo(2.589988110336, tolerance));
      });

      test('1 square megameter to various units', () {
        final oneSquareMegameter = 1.0.squareMegameter;
        expect(oneSquareMegameter.inSquareMeters, closeTo(1e12, tolerance));
        expect(oneSquareMegameter.inSquareKilometers, closeTo(1e6, tolerance));
      });

      final oneSquareYard = 1.0.yd2;
      test('1 square yard to various units', () {
        expect(oneSquareYard.inSquareMeters, closeTo(0.83612736, tolerance));
        expect(oneSquareYard.inSquareFeet, closeTo(9.0, tolerance));
        expect(oneSquareYard.inSquareInches, closeTo(1296.0, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Area object with converted value and unit', () {
        final aMeters = 10.0.m2;
        final aFeet = aMeters.convertTo(AreaUnit.squareFoot);
        expect(aFeet.unit, AreaUnit.squareFoot);
        expect(aFeet.value, closeTo(aMeters.inSquareFeet, tolerance));
        expect(aMeters.unit, AreaUnit.squareMeter); // Original should be unchanged
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final a1 = 10.0.m2;
        final a2 = a1.convertTo(AreaUnit.squareMeter);
        expect(identical(a1, a2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final aMeter = 1.0.m2;
      final aSlightlyLessCm = 9999.0.cm2; // 0.9999 m2
      final aSlightlyMoreCm = 10001.0.cm2; // 1.0001 m2
      final aFoot = 10.0.ft2; // ~0.929 m2

      test('should correctly compare areas of different units', () {
        expect(aMeter.compareTo(aSlightlyLessCm), greaterThan(0));
        expect(aSlightlyLessCm.compareTo(aMeter), lessThan(0));
        expect(aMeter.compareTo(aSlightlyMoreCm), lessThan(0));
        expect(aMeter.compareTo(aFoot), greaterThan(0)); // 1m2 > 10ft2
      });

      test('should return 0 for equal areas in different units', () {
        final aCm = 10000.0.cm2; // 1 m2
        final aInches = (1.0 / 0.00064516).in2; // 1 m2 in inches
        expect(aMeter.compareTo(aCm), 0);
        expect(aCm.compareTo(aMeter), 0);
        expect(aMeter.compareTo(aInches), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const a1 = Area(10, AreaUnit.squareMeter);
        const a2 = Area(10, AreaUnit.squareMeter);
        expect(a1 == a2, isTrue);
        expect(a1.hashCode == a2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const a1 = Area(10, AreaUnit.squareMeter);
        const a2 = Area(10.1, AreaUnit.squareMeter);
        const a3 = Area(10, AreaUnit.squareFoot);
        expect(a1 == a2, isFalse);
        expect(a1 == a3, isFalse);
        expect(a1.hashCode == a2.hashCode, isFalse);
        expect(a1.hashCode == a3.hashCode, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(10.5.m2.toString(), '10.5 m²');
        expect(12.0.in2.toString(), '12.0 in²');
        expect(1.6.km2.toString(), '1.6 km²');
        expect(1.ha.toString(), '1.0 ha');
        expect(10.5.yd2.toString(), '10.5 yd²');
        expect(1.0.squareMegameter.toString(), '1.0 Mm²');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 789.123;

      for (final unit in AreaUnit.values) {
        test('Round trip ${unit.symbol} <-> m²', () {
          testRoundTrip(
            unit,
            AreaUnit.squareMeter,
            testValue,
            tolerance: (unit == AreaUnit.squareMeter) ? tolerance : highTolerance,
          );
        });
      }

      test('Round trip ac <-> km²', () {
        testRoundTrip(AreaUnit.acre, AreaUnit.squareKilometer, 500, tolerance: highTolerance);
      });
      test('Round trip cm² <-> mm²', () {
        testRoundTrip(AreaUnit.squareCentimeter, AreaUnit.squareMillimeter, 250000);
      });

      test('Round trip Mm² <-> km²', () {
        testRoundTrip(
          AreaUnit.squareMegameter,
          AreaUnit.squareKilometer,
          testValue,
          tolerance: highTolerance,
        );
      });

      test('Round trip yd² <-> ft²', () {
        testRoundTrip(AreaUnit.squareYard, AreaUnit.squareFoot, 5);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final aZero = 0.0.m2;
        for (final unit in AreaUnit.values) {
          expect(aZero.getValue(unit), 0.0, reason: '0 m² to ${unit.symbol} should be 0');
        }
      });

      test('Division by zero', () {
        final a = 10.m2;
        expect(() => a / 0.0, throwsArgumentError);
      });
    });

    group('Arithmetic Operators for Area', () {
      final a1Meter = 1.0.m2;
      final a2Meters = 2.0.m2;
      final a5000Cm = 5000.cm2; // 0.5 m2

      // Operator +
      test('operator + combines areas', () {
        final sum1 = a2Meters + a1Meter;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, AreaUnit.squareMeter);

        final sum2 = a1Meter + a5000Cm; // 1m2 + 0.5m2 = 1.5m2
        expect(sum2.value, closeTo(1.5, tolerance));
        expect(sum2.unit, AreaUnit.squareMeter);

        final sum3 = a5000Cm + a1Meter; // 5000cm2 + 10000cm2 = 15000cm2
        expect(sum3.value, closeTo(15000.0, tolerance));
        expect(sum3.unit, AreaUnit.squareCentimeter);
      });

      // Operator -
      test('operator - subtracts areas', () {
        final diff1 = a2Meters - a1Meter;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, AreaUnit.squareMeter);

        final diff2 = a1Meter - a5000Cm; // 1m2 - 0.5m2 = 0.5m2
        expect(diff2.value, closeTo(0.5, tolerance));
        expect(diff2.unit, AreaUnit.squareMeter);

        final diff3 = a2Meters - a5000Cm.convertTo(AreaUnit.squareMeter); // 2m2 - 0.5m2 = 1.5m2
        expect(diff3.value, closeTo(1.5, tolerance));
        expect(diff3.unit, AreaUnit.squareMeter);
      });

      // Operator * (scalar)
      test('operator * scales area by a scalar', () {
        final scaled = a2Meters * 3.0;
        expect(scaled.value, closeTo(6.0, tolerance));
        expect(scaled.unit, AreaUnit.squareMeter);

        final scaledCm = a5000Cm * 2.5;
        expect(scaledCm.value, closeTo(12500.0, tolerance));
        expect(scaledCm.unit, AreaUnit.squareCentimeter);
      });

      // Operator / (scalar)
      test('operator / scales area by a scalar', () {
        final scaled = a2Meters / 2.0;
        expect(scaled.value, closeTo(1.0, tolerance));
        expect(scaled.unit, AreaUnit.squareMeter);

        expect(() => a1Meter / 0.0, throwsArgumentError);
      });

      test('operator chaining preserves immutability', () {
        final initialArea = 10.m2;
        final a1 = initialArea + 5.m2; // 15m2
        final a2 = a1 * 2.0; // 30m2
        final a3 = a2 - 10000.cm2; // 30m2 - 1m2 = 29m2

        expect(initialArea.value, 10.0); // Original unchanged
        expect(a1.value, closeTo(15.0, tolerance));
        expect(a2.value, closeTo(30.0, tolerance));
        expect(a3.value, closeTo(29.0, tolerance));
        expect(a3.unit, AreaUnit.squareMeter);
      });

      test('operator arithmetic with square yards', () {
        final carpetArea = 10.yd2; // about 8.36 m²
        final roomArea = 12.m2;

        // Addition
        final totalArea = roomArea + carpetArea; // 12 m² + ~8.36 m²
        expect(totalArea.unit, AreaUnit.squareMeter);
        expect(totalArea.inSquareMeters, closeTo(12.0 + 0.83612736 * 10, tolerance));

        // Subtraction
        final remainingArea = roomArea - carpetArea;
        expect(remainingArea.inSquareMeters, closeTo(12.0 - 0.83612736 * 10, tolerance));

        // Comparison
        expect(roomArea.compareTo(carpetArea), greaterThan(0));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/area_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/constants_test.dart -->
import 'package:quantify/constants.dart';
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('Physical Constants', () {
    const tolerance = 1e-12;
    const highTolerance = 1e-9;

    test('fundamental constants have correct values', () {
      // Speed of light is now a Speed object
      expect(PhysicalConstants.speedOfLight.inMetersPerSecond, 299792458.0);

      // Elementary charge is now an ElectricCharge object
      expect(PhysicalConstants.elementaryCharge.inCoulombs, closeTo(1.602176634e-19, 1e-28));

      // Planck and Avogadro constants remain doubles
      expect(PhysicalConstants.planckConstant, 6.62607015e-34);
      expect(PhysicalConstants.avogadroConstant, 6.02214076e23);
    });

    test('particle masses are correct', () {
      expect(PhysicalConstants.electronMass.inKilograms, closeTo(9.1093837015e-31, tolerance));
      expect(PhysicalConstants.protonMass.inKilograms, closeTo(1.67262192369e-27, tolerance));
      expect(
        PhysicalConstants.atomicMassConstant.inKilograms,
        closeTo(1.66053906660e-27, tolerance),
      );
    });

    test('energy constants are correct', () {
      expect(PhysicalConstants.electronVolt.inJoules, closeTo(1.602176634e-19, 1e-28));
      expect(PhysicalConstants.rydbergEnergy.inJoules, closeTo(2.1798723611035e-18, tolerance));
      expect(PhysicalConstants.electronRestEnergy.inJoules, closeTo(8.1871057769e-14, tolerance));
    });

    test('convenience methods return correct Quantity types and values', () {
      // lightSpeedDistance
      final lightDistance = PhysicalConstants.lightSpeedDistance(1.0.s);
      expect(lightDistance, isA<Length>());
      expect(lightDistance.inM, closeTo(299792458.0, tolerance));

      // massEnergyEquivalence
      final energy = PhysicalConstants.massEnergyEquivalence(1.0.kg);
      const expectedEnergy = 299792458.0 * 299792458.0; // c²
      expect(energy, isA<Energy>());
      expect(energy.inJoules, closeTo(expectedEnergy, highTolerance));

      // photonEnergy
      final photonEnergy = PhysicalConstants.photonEnergy(500.0.nm);
      final expectedPhotonEnergy = PhysicalConstants.planckConstant *
          PhysicalConstants.speedOfLight.inMetersPerSecond /
          500e-9;
      expect(photonEnergy, isA<Energy>());
      expect(photonEnergy.inJoules, closeTo(expectedPhotonEnergy, highTolerance));

      // gravitationalForce
      final force = PhysicalConstants.gravitationalForce(1.kg, 1.kg, 1.m);
      expect(force, isA<Force>());
      expect(force.inNewtons, closeTo(PhysicalConstants.gravitationalConstant, tolerance));
    });
  });

  group('Astronomical Constants', () {
    const highTolerance = 1e20; // For measured values like planetary masses

    test('solar system constants are correct Quantity types', () {
      expect(AstronomicalConstants.solarMass, isA<Mass>());
      expect(AstronomicalConstants.solarLuminosity, isA<Power>());
      expect(AstronomicalConstants.earthMass, isA<Mass>());
      expect(AstronomicalConstants.earthRadius, isA<Length>());
      expect(AstronomicalConstants.standardGravity, isA<Acceleration>());
      expect(AstronomicalConstants.earthEscapeVelocity, isA<Speed>());
    });

    test('solar system masses and sizes are correct', () {
      expect(AstronomicalConstants.solarMass.inKilograms, closeTo(1.98847e30, 1e25));
      expect(AstronomicalConstants.earthMass.inKilograms, closeTo(5.9722e24, highTolerance));
      expect(AstronomicalConstants.earthRadius.inKilometers, closeTo(6378.14, 10));
      final jupiterToEarthRatio = AstronomicalConstants.jupiterMass.inKilograms /
          AstronomicalConstants.earthMass.inKilograms;
      expect(jupiterToEarthRatio, greaterThan(317));
      expect(jupiterToEarthRatio, lessThan(319));
    });

    test('other astronomical constants are correct', () {
      expect(AstronomicalConstants.solarLuminosity.inWatts, closeTo(3.828e26, 1e22));
      expect(AstronomicalConstants.standardGravity.inMetersPerSecondSquared, 9.80665);
      expect(AstronomicalConstants.earthEscapeVelocity.inMetersPerSecond, closeTo(11190, 10));
      expect(AstronomicalConstants.hubbleConstant.inHertz, closeTo(2.18e-18, 1e-20));
    });

    test('convenience calculations return correct Quantity types and values', () {
      // surfaceGravity
      final g = AstronomicalConstants.surfaceGravity(
        AstronomicalConstants.earthMass,
        AstronomicalConstants.earthRadius,
      );
      expect(g, isA<Acceleration>());
      expect(g.inMetersPerSecondSquared, closeTo(9.8, 0.2)); // ~9.8 m/s²

      // escapeVelocity
      final vEscape = AstronomicalConstants.escapeVelocity(
        AstronomicalConstants.earthMass,
        AstronomicalConstants.earthRadius,
      );
      expect(vEscape, isA<Speed>());
      expect(vEscape.inKilometersPerSecond, closeTo(11.2, 0.2)); // ~11.2 km/s

      // schwarzschildRadius
      final rs = AstronomicalConstants.schwarzschildRadius(AstronomicalConstants.solarMass);
      expect(rs, isA<Length>());
      expect(rs.inKilometers, closeTo(2.95, 0.1)); // ~3 km
    });
  });

  group('Engineering Constants', () {
    const tolerance = 1e-9;

    test('standard conditions are correct Quantity types', () {
      expect(EngineeringConstants.standardTemperature, isA<Temperature>());
      expect(EngineeringConstants.standardPressure, isA<Pressure>());
      expect(EngineeringConstants.standardAtmosphere, isA<Pressure>());
    });

    test('material properties are correct Quantity types', () {
      expect(EngineeringConstants.soundSpeedAir20C, isA<Speed>());
      expect(EngineeringConstants.soundSpeedWater25C, isA<Speed>());
      expect(EngineeringConstants.steelYoungsModulus, isA<Pressure>());
      expect(EngineeringConstants.aluminumYoungsModulus, isA<Pressure>());
      expect(EngineeringConstants.steelTensileStrength, isA<Pressure>());
      expect(EngineeringConstants.nuclearBindingEnergyPerNucleon, isA<Energy>());
    });

    test('values of constants are correct', () {
      expect(EngineeringConstants.standardTemperature.inCelsius, closeTo(0.0, tolerance));
      expect(EngineeringConstants.standardPressure.inBar, closeTo(1.0, tolerance));
      expect(EngineeringConstants.standardAtmosphere.inPa, 101325.0);
      expect(EngineeringConstants.soundSpeedAir20C.inMetersPerSecond, closeTo(343.2, 1));
      expect(EngineeringConstants.steelYoungsModulus.inMegaPascals, closeTo(200000, 10000));
    });

    test('convenience calculations return correct Quantity types and values', () {
      // mechanicalStress
      final stress = EngineeringConstants.mechanicalStress(1000.N, 0.01.m2);
      expect(stress, isA<Pressure>());
      expect(stress.inKiloPascals, closeTo(100.0, tolerance));

      // mechanicalStrain
      final strain = EngineeringConstants.mechanicalStrain(
        200.megaPascals,
        EngineeringConstants.steelYoungsModulus,
      );
      expect(strain, isA<double>());
      expect(strain, closeTo(0.001, tolerance)); // 200e6 Pa / 200e9 Pa = 0.001

      // conductiveHeatTransfer
      final heatRate = EngineeringConstants.conductiveHeatTransfer(
        0.5,
        1.m2,
        0.1.m,
        const Temperature(10, TemperatureUnit.kelvin),
      );
      expect(heatRate, isA<Power>());
      expect(heatRate.inWatts, closeTo(50.0, tolerance)); // 0.5 * 1 * 10 / 0.1 = 50.0
    });
  });

  group('Cross-library consistency', () {
    test('standard gravity constants are consistent', () {
      // Compare the Acceleration object from AstronomicalConstants with the one from the num extension
      final gFromAcc = 1.gravity;
      expect(AstronomicalConstants.standardGravity.compareTo(gFromAcc), 0);
    });

    test('unit conversions work with constants', () {
      // Bohr radius in angstroms
      final bohrInAngstrom = PhysicalConstants.bohrRadius.inAngstrom;
      expect(bohrInAngstrom, closeTo(0.529, 0.001));

      // Solar luminosity in megawatts
      final solarLuminosityMW = AstronomicalConstants.solarLuminosity.inMegawatts;
      expect(solarLuminosityMW, closeTo(3.828e20, 1e16));
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/constants_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/current_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming Current and CurrentUnit are exported
import 'package:test/test.dart';

void main() {
  group('Current', () {
    const strictTolerance = 1e-12; // For "exact" conversions or small scales
    const defaultTolerance = 1e-9; // General purpose
    const looseTolerance = 1e-6; // For conversions over many orders of magnitude

    // Helper for round trip tests
    void testRoundTrip(
      CurrentUnit initialUnit,
      CurrentUnit intermediateUnit,
      double initialValue, {
      double tol = defaultTolerance,
    }) {
      final c1 = Current(initialValue, initialUnit);
      final c2 = c1.convertTo(intermediateUnit);
      final c3 = c2.convertTo(initialUnit);
      expect(
        c3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${c3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create Current from num extensions and retrieve values correctly', () {
        final curA = 1.5.A; // Using symbol extension
        expect(curA.value, 1.5);
        expect(curA.unit, CurrentUnit.ampere);
        expect(curA.inMilliamperes, closeTo(1500.0, strictTolerance));
        expect(curA.asMilliamperes.value, closeTo(1500.0, strictTolerance));
        expect(curA.asMilliamperes.unit, CurrentUnit.milliampere);

        final curMA = 250.0.milliamperes; // Using alias
        expect(curMA.value, 250.0);
        expect(curMA.unit, CurrentUnit.milliampere);
        expect(curMA.inAmperes, closeTo(0.25, strictTolerance));

        final curUA = 123.0.uA;
        expect(curUA.value, 123.0);
        expect(curUA.unit, CurrentUnit.microampere);
        expect(curUA.inAmperes, closeTo(0.000123, strictTolerance));
        expect(curUA.inNanoamperes, closeTo(123000.0, defaultTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const current = Current(0.01, CurrentUnit.ampere);
        expect(current.getValue(CurrentUnit.ampere), 0.01);
      });
    });

    group('Conversions between various current units', () {
      final oneAmpere = 1.0.A;
      test('1 Ampere to other units', () {
        expect(oneAmpere.inKiloamperes, closeTo(0.001, strictTolerance));
        expect(oneAmpere.inMilliamperes, closeTo(1000.0, strictTolerance));
        expect(oneAmpere.inMicroamperes, closeTo(1.0e6, strictTolerance));
        expect(oneAmpere.inNanoamperes, closeTo(1.0e9, looseTolerance)); // Larger scale
      });

      final oneKiloampere = 1.0.kA;
      test('1 Kiloampere to amperes', () {
        expect(oneKiloampere.inAmperes, closeTo(1000.0, strictTolerance));
      });

      final oneMilliampere = 1.0.mA;
      test('1 Milliampere to microamperes and amperes', () {
        expect(oneMilliampere.inMicroamperes, closeTo(1000.0, strictTolerance));
        expect(oneMilliampere.inAmperes, closeTo(0.001, strictTolerance));
      });

      final fiftyMicroamperes = 50.0.uA;
      test('50 Microamperes to nanoamperes and milliamperes', () {
        expect(fiftyMicroamperes.inNanoamperes, closeTo(50000.0, defaultTolerance));
        expect(fiftyMicroamperes.inMilliamperes, closeTo(0.05, strictTolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Current object with converted value and unit', () {
        final curMA = 1250.0.mA;
        final curA = curMA.convertTo(CurrentUnit.ampere);

        expect(curA.unit, CurrentUnit.ampere);
        expect(curA.value, closeTo(1.25, strictTolerance));
        expect(curMA.unit, CurrentUnit.milliampere); // Original should be unchanged
        expect(curMA.value, 1250.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final c1 = 0.1.A;
        final c2 = c1.convertTo(CurrentUnit.ampere);
        expect(identical(c1, c2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final c1A = 1.0.A;
      final c1000mA = 1000.0.mA;
      final c999mA = 999.0.mA;
      final c0_01kA = 0.01.kA; // 10 A
      final c0_0001kA = 0.0001.kA; // 0.1 A

      test('should correctly compare currents of different units', () {
        expect(c1A.compareTo(c999mA), greaterThan(0)); // 1A > 999mA
        expect(c999mA.compareTo(c1A), lessThan(0)); // 999mA < 1A
        expect(c1A.compareTo(c1000mA), 0); // 1A == 1000mA

        expect(c1A.compareTo(c0_01kA), lessThan(0)); // 1A < 10A
        expect(c1A.compareTo(c0_0001kA), greaterThan(0)); // 1A > 0.1A
      });

      test('should return 0 for equal currents in different units', () {
        final cInUA = 1000000.0.uA; // 1 A in microamperes
        expect(c1A.compareTo(cInUA), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const c1 = Current(0.05, CurrentUnit.ampere);
        const c2 = Current(0.05, CurrentUnit.ampere);
        expect(c1 == c2, isTrue);
        expect(c1.hashCode == c2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const c1 = Current(0.05, CurrentUnit.ampere);
        const c2Diffval = Current(0.051, CurrentUnit.ampere);
        const c3Diffunit = Current(0.05, CurrentUnit.milliampere);

        expect(c1 == c2Diffval, isFalse);
        expect(c1 == c3Diffunit, isFalse);

        expect(c1.hashCode == c2Diffval.hashCode, isFalse);
        expect(c1.hashCode == c3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.A is not equal to 1000.mA', () {
        final oneAmp = 1.A;
        final thousandMilliamp = 1000.mA;
        expect(oneAmp == thousandMilliamp, isFalse);
        expect(oneAmp.compareTo(thousandMilliamp), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(2.5.A.toString(), '2.5\u00A0A');
        expect(15.mA.toString(), '15.0\u00A0mA');
        expect(123.microamperes.toString(), '123.0\u00A0µA'); // Note µ symbol
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 0.0123456789;

      for (final unit in CurrentUnit.values) {
        test('Round trip ${unit.symbol} <-> A', () {
          testRoundTrip(
            unit,
            CurrentUnit.ampere,
            testValue,
            tol: (unit == CurrentUnit.ampere ||
                    unit == CurrentUnit.milliampere ||
                    unit == CurrentUnit.kiloampere)
                ? strictTolerance
                : looseTolerance,
          );
        });
      }

      test('Round trip mA <-> µA', () {
        testRoundTrip(CurrentUnit.milliampere, CurrentUnit.microampere, 0.5, tol: strictTolerance);
      });
      test('Round trip µA <-> nA', () {
        testRoundTrip(CurrentUnit.microampere, CurrentUnit.nanoampere, 0.005, tol: strictTolerance);
      });
      test('Round trip A <-> kA', () {
        testRoundTrip(CurrentUnit.ampere, CurrentUnit.kiloampere, 2500.0, tol: strictTolerance);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final cZeroA = 0.0.A;
        for (final unit in CurrentUnit.values) {
          expect(cZeroA.getValue(unit), 0.0, reason: '0 A to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with very small and large values', () {
        final verySmall = 1.0e-10.A; // picoampere range if unit existed
        expect(verySmall.inNanoamperes, closeTo(0.1, strictTolerance));

        final veryLarge = 1.0e4.A; // 10 kA
        expect(veryLarge.inKiloamperes, closeTo(10.0, strictTolerance));
      });
    });

    group('Arithmetic Operators for Current', () {
      final c1A = 1.0.A;
      final c2A = 2.0.A;
      final c500mA = 500.mA; // 0.5 A
      final c100uA = 100.uA; // 0.0001 A

      // Operator +
      test('operator + combines currents, result in unit of left operand', () {
        final sum1 = c2A + c1A;
        expect(sum1.value, closeTo(3.0, defaultTolerance));
        expect(sum1.unit, CurrentUnit.ampere);

        final sum2 = c1A + c500mA; // 1A + 0.5A = 1.5A
        expect(sum2.value, closeTo(1.5, defaultTolerance));
        expect(sum2.unit, CurrentUnit.ampere);

        final sum3 = c500mA + c1A; // 500mA + 1000mA = 1500mA
        expect(sum3.value, closeTo(1500.0, defaultTolerance));
        expect(sum3.unit, CurrentUnit.milliampere);

        final sum4 = c1A + c100uA; // 1A + 0.0001A
        expect(sum4.value, closeTo(1.0 + 0.0001, strictTolerance));
        expect(sum4.unit, CurrentUnit.ampere);
      });

      // Operator -
      test('operator - subtracts currents, result in unit of left operand', () {
        final diff1 = c2A - c1A;
        expect(diff1.value, closeTo(1.0, defaultTolerance));
        expect(diff1.unit, CurrentUnit.ampere);

        final diff2 = c1A - c500mA; // 1A - 0.5A = 0.5A
        expect(diff2.value, closeTo(0.5, defaultTolerance));
        expect(diff2.unit, CurrentUnit.ampere);

        final diff3 = c1A - c100uA; // 1A - 0.0001A
        expect(diff3.value, closeTo(1.0 - 0.0001, strictTolerance));
        expect(diff3.unit, CurrentUnit.ampere);
      });

      // Operator * (scalar)
      test('operator * scales current by a scalar', () {
        final scaled1 = c2A * 1.5;
        expect(scaled1.value, closeTo(3.0, defaultTolerance));
        expect(scaled1.unit, CurrentUnit.ampere);

        final scaled2 = c500mA * 0.2;
        expect(scaled2.value, closeTo(100.0, defaultTolerance));
        expect(scaled2.unit, CurrentUnit.milliampere);
      });

      // Operator / (scalar)
      test('operator / scales current by a scalar', () {
        final scaled1 = c2A / 5.0;
        expect(scaled1.value, closeTo(0.4, defaultTolerance));
        expect(scaled1.unit, CurrentUnit.ampere);

        final scaled2 = c1A / 0.02;
        expect(scaled2.value, closeTo(50.0, defaultTolerance));
        expect(scaled2.unit, CurrentUnit.ampere);

        expect(() => c1A / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialCurrent = 0.5.A;
        final cAdd = initialCurrent + 200.mA; // 0.5A + 0.2A = 0.7A
        final cMul = cAdd * 3.0; // 0.7A * 3 = 2.1A
        final cSub = cMul - 10000.uA; // 2.1A - 0.01A = 2.09A

        expect(initialCurrent.value, 0.5); // Original unchanged
        expect(initialCurrent.unit, CurrentUnit.ampere);

        expect(cAdd.value, closeTo(0.7, defaultTolerance));
        expect(cAdd.unit, CurrentUnit.ampere);

        expect(cMul.value, closeTo(2.1, defaultTolerance));
        expect(cMul.unit, CurrentUnit.ampere);

        final expectedCSubVal = 2.1 - 10000.0.uA.getValue(CurrentUnit.ampere);
        expect(cSub.value, closeTo(expectedCSubVal, strictTolerance));
        expect(cSub.unit, CurrentUnit.ampere);
      });
    });

    group('CGS and Historical Units', () {
      const tolerance = 1e-12;

      test('abampere (biot) conversions', () {
        // Use the new explicit extension `abA`
        final oneAbampere = 1.0.abA;
        expect(oneAbampere.inAmperes, closeTo(10.0, tolerance));

        // Test creation with `Bi` alias
        final oneBiot = 1.0.bi;
        expect(oneBiot.compareTo(oneAbampere), 0);

        // Test conversion from SI
        final fiftyAmperes = 50.0.A;
        expect(fiftyAmperes.inAbamperes, closeTo(5.0, tolerance));
      });

      test('statampere conversions', () {
        // Use the new explicit extension `statA`
        final oneAmpere = 1.0.A;
        const expectedStatA = 1.0 / 3.3356409519815204e-10;
        expect(oneAmpere.inStatamperes, closeTo(expectedStatA, 1e-3));

        // Test creation and conversion back
        final oneStatampere = 1.0.statA;
        expect(oneStatampere.inAmperes, closeTo(3.3356409519815204e-10, tolerance));
      });

      test('comparison between CGS and SI units', () {
        final oneAbampere = 1.0.abA; // 10 A
        final oneAmpere = 1.0.A;
        final oneStatampere = 1.0.statA; // tiny current

        expect(oneAbampere.compareTo(oneAmpere), greaterThan(0));
        expect(oneAmpere.compareTo(oneStatampere), greaterThan(0));
      });

      test('round trip conversions for CGS units', () {
        const testValue = 123.456;

        // Test round trip via amperes
        final originalAbA = testValue.abA;
        final roundTripAbA = originalAbA.asAmperes.asAbamperes;
        expect(roundTripAbA.value, closeTo(testValue, tolerance));

        final originalStatA = testValue.statA;
        final roundTripStatA = originalStatA.asAmperes.asStatamperes;
        expect(
          roundTripStatA.value,
          closeTo(testValue, 1e-3),
        ); // Lower precision due to large factor
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/current_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/electric_charge_test.dart -->
// test/units/electric_charge_test.dart
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('ElectricCharge', () {
    const tolerance = 1e-12;
    const highTolerance = 1e-9; // For very large scale differences
    const atomicTolerance = 1e-24; // For elementary charge conversions

    // Helper for round trip tests
    void testRoundTrip(
      ElectricChargeUnit initialUnit,
      ElectricChargeUnit intermediateUnit,
      double initialValue, {
      double tol = highTolerance,
    }) {
      final q1 = ElectricCharge(initialValue, initialUnit);
      final q2 = q1.convertTo(intermediateUnit);
      final q3 = q2.convertTo(initialUnit);
      expect(
        q3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create from num extensions and retrieve values', () {
        final charge = 1.5.coulombs;
        expect(charge.value, 1.5);
        expect(charge.unit, ElectricChargeUnit.coulomb);
        expect(charge.inMillicoulombs, closeTo(1500.0, tolerance));

        final battery = 5.0.ah; // 5 Ampere-hours
        expect(battery.value, 5.0);
        expect(battery.unit, ElectricChargeUnit.ampereHour);
        expect(battery.inCoulombs, closeTo(5.0 * 3600.0, tolerance));
      });
    });

    group('Conversions', () {
      test('Coulomb to other units', () {
        final oneCoulomb = 1.0.C;
        expect(oneCoulomb.inAmpereHours, closeTo(1.0 / 3600.0, tolerance));
        expect(oneCoulomb.inMillicoulombs, closeTo(1000.0, tolerance));
        expect(
          oneCoulomb.inElementaryCharges,
          closeTo(1.0 / 1.602176634e-19, highTolerance),
        );
      });

      test('Ampere-hour to Coulombs', () {
        final phoneBattery = 4.5.ah; // 4500 mAh
        expect(phoneBattery.inCoulombs, closeTo(4.5 * 3600, tolerance));
      });

      test('Elementary Charge to Coulombs', () {
        // One mole of electrons (Faraday constant)
        final oneMoleElectrons = 6.02214076e23.e;
        const faradayConstant = 96485.33212; // C/mol
        expect(oneMoleElectrons.inCoulombs, closeTo(faradayConstant, 1e-4));
      });

      test('mAh and CGS units conversions', () {
        // 1 Ah = 1000 mAh
        final oneAh = 1.0.ah;
        expect(oneAh.inMilliampereHours, closeTo(1000.0, 1e-12));

        // 1 abcoulomb = 10 coulombs
        final oneAbc = 1.0.abC;
        expect(oneAbc.inCoulombs, closeTo(10.0, 1e-12));

        // 1 coulomb to statcoulombs
        final oneCoulomb = 1.0.C;
        const expectedStatC = 1.0 / 3.3356409519815204e-10;
        expect(oneCoulomb.inStatcoulombs, closeTo(expectedStatC, 1e-3));
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final q1 = 1.ah; // 3600 C
        final q2 = 3500.C;
        final q3 = 3700.C;

        expect(q1.compareTo(q2), greaterThan(0));
        expect(q1.compareTo(q3), lessThan(0));
        expect(q1.compareTo(3600.C), 0);
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction', () {
        final sum = 1.ah + 400.C; // 3600 C + 400 C = 4000 C
        expect(sum.inCoulombs, closeTo(4000.0, tolerance));
        expect(sum.unit, ElectricChargeUnit.ampereHour); // Left operand's unit
      });

      test('should perform scalar multiplication and division', () {
        final charge = 2.5.ah;
        expect((charge * 2.0).inAmpereHours, closeTo(5.0, tolerance));
        expect((charge / 5.0).inAmpereHours, closeTo(0.5, tolerance));
        expect(() => charge / 0, throwsArgumentError);
      });
    });

    group('Dimensional Analysis (Current/Time Interop)', () {
      test('ElectricCharge.from(Current, Time) creates correct charge', () {
        final charge = ElectricCharge.from(2.A, 1.h);
        expect(charge.inAmpereHours, closeTo(2.0, tolerance));
        expect(charge.inCoulombs, closeTo(7200.0, tolerance));

        final smallCharge = ElectricCharge.from(10.mA, 5.s); // 10e-3 A * 5 s = 0.05 C
        expect(smallCharge.inCoulombs, closeTo(0.05, tolerance));
        expect(smallCharge.inMillicoulombs, closeTo(50.0, tolerance));
      });

      test('charge.currentOver(Time) calculates correct current', () {
        final battery = 5.ah;
        // Discharge over 10 hours -> 0.5 A
        final current = battery.currentOver(10.h);
        expect(current.inAmperes, closeTo(0.5, tolerance));

        // Discharge over 1 minute
        final fastDischarge = 360.C.currentOver(1.min); // 360 C / 60 s = 6 A
        expect(fastDischarge.inAmperes, closeTo(6.0, tolerance));

        expect(() => 1.C.currentOver(0.s), throwsArgumentError);
      });

      test('charge.timeFor(Current) calculates correct time', () {
        final battery = 4.5.ah;
        // Time to discharge at 500 mA (0.5 A) -> 9 hours
        final time = battery.timeFor(500.mA);
        expect(time.inHours, closeTo(9.0, tolerance));

        // Time to transfer 1 Coulomb at 1 Ampere -> 1 second
        final time2 = 1.C.timeFor(1.A);
        expect(time2.inSeconds, closeTo(1.0, tolerance));

        expect(() => 1.C.timeFor(0.A), throwsArgumentError);
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in ElectricChargeUnit.values) {
        test('Round trip ${unit.symbol} <-> C', () {
          testRoundTrip(
            unit,
            ElectricChargeUnit.coulomb,
            123.456,
            tol: unit == ElectricChargeUnit.elementaryCharge ? atomicTolerance : highTolerance,
          );
        });
      }
    });

    group('Practical Examples', () {
      test('Battery Capacity', () {
        // A typical phone battery has a capacity of 4500 mAh.
        // This is equivalent to 4.5 Ah.
        final phoneBattery = 4.5.ah;

        // Verify its value in Coulombs
        expect(phoneBattery.inCoulombs, closeTo(16200, tolerance));

        // How long can it power a device drawing 150 mA?
        // t = Q / I = 4.5 Ah / 0.15 A = 30 h
        final deviceCurrent = 150.mA;
        final runtime = phoneBattery.timeFor(deviceCurrent);
        expect(runtime.inHours, closeTo(30.0, tolerance));
      });

      test('Number of Electrons', () {
        // How many electrons in -1 Coulomb of charge?
        final oneCoulomb = (-1.0).C;
        expect(
          oneCoulomb.inElementaryCharges,
          closeTo(-1.0 / 1.602176634e-19, highTolerance),
        );
        expect(
          oneCoulomb.inElementaryCharges,
          closeTo(-6.241509e18, 1e13),
        );
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/electric_charge_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/energy_test.dart -->
import 'package:quantify/energy.dart';
import 'package:test/test.dart';

void main() {
  group('Energy', () {
    const strictTolerance = 1e-12; // For "exact" conversions or small scales
    const defaultTolerance = 1e-9; // General purpose
    const highTolerance = 1e-6; // For conversions involving many decimal places

    // Helper for round trip tests
    void testRoundTrip(
      EnergyUnit initialUnit,
      EnergyUnit intermediateUnit,
      double initialValue, {
      double tol = defaultTolerance,
    }) {
      final e1 = Energy(initialValue, initialUnit);
      final e2 = e1.convertTo(intermediateUnit);
      final e3 = e2.convertTo(initialUnit);
      expect(
        e3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${e3.value}',
      );
    }

    group('Constructors and Getters', () {
      test('should create Energy from num extensions and retrieve values correctly', () {
        final eKcal = 250.0.kcal;
        expect(eKcal.value, 250.0);
        expect(eKcal.unit, EnergyUnit.kilocalorie);
        expect(eKcal.inJoules, closeTo(250.0 * 4184.0, defaultTolerance));
        expect(eKcal.asJoules.value, closeTo(250.0 * 4184.0, defaultTolerance));
        expect(eKcal.asJoules.unit, EnergyUnit.joule);

        final eKwh = 1.2.kWh;
        expect(eKwh.value, 1.2);
        expect(eKwh.unit, EnergyUnit.kilowattHour);
        expect(eKwh.inJoules, closeTo(1.2 * 3600000.0, defaultTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const energy = Energy(100, EnergyUnit.joule);
        expect(energy.getValue(EnergyUnit.joule), 100.0);
      });
    });

    group('Conversions between various energy units', () {
      final oneKwh = 1.0.kWh; // 3,600,000 Joules

      test('1 Kilowatt-hour to other units', () {
        expect(oneKwh.inJoules, closeTo(3600000.0, strictTolerance));
        expect(oneKwh.inKilojoules, closeTo(3600.0, strictTolerance));
        expect(oneKwh.inKilocalories, closeTo(3600000.0 / 4184.0, highTolerance)); // ~860.4 kcal
        expect(oneKwh.inBtu, closeTo(3600000.0 / 1055.056, highTolerance)); // ~3412 Btu
      });

      final oneKcal = 1.0.kilocalories; // 4184 Joules
      test('1 Kilocalorie to other units', () {
        expect(oneKcal.inJoules, closeTo(4184.0, strictTolerance));
        expect(oneKcal.inCalories, closeTo(1000.0, strictTolerance));
        expect(oneKcal.inBtu, closeTo(4184.0 / 1055.056, highTolerance)); // ~3.96 Btu
      });

      final oneElectronvolt = 1.0.eV;
      test('1 Electronvolt to Joules', () {
        expect(oneElectronvolt.inJoules, closeTo(1.602176634e-19, 1e-28));
      });
    });

    group('Comparison (compareTo)', () {
      final e1 = 1.0.kWh; // 3.6 MJ
      final e2 = 3600.0.kJ; // 3.6 MJ
      final e3 = 860.0.kcal; // ~3.597 MJ
      final e4 = 861.0.kcal; // ~3.601 MJ

      test('should correctly compare energies of different units', () {
        expect(e1.compareTo(e2), 0);
        expect(e1.compareTo(e3), greaterThan(0));
        expect(e1.compareTo(e4), lessThan(0));
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('equality is strict, 1.kWh is not equal to 3600.kJ', () {
        final oneKwh = 1.kWh;
        final threeThousandSixHundredKj = 3600.kJ;
        expect(oneKwh == threeThousandSixHundredKj, isFalse);
        expect(oneKwh.compareTo(threeThousandSixHundredKj), 0);
      });
    });

    group('Arithmetic Operators for Energy', () {
      final e1 = 1.0.kWh;
      final e2 = 200.0.kcal;
      final e3 = 500.0.kJ;

      test('operator + combines energies', () {
        final sum = e1 + e3; // 3600 kJ + 500 kJ = 4100 kJ
        expect(sum.inKilojoules, closeTo(4100.0, defaultTolerance));
        expect(sum.unit, EnergyUnit.kilowattHour); // Left-hand operand's unit
      });

      test('operator - subtracts energies', () {
        final diff = e1 - e2; // 3600 kJ - (200 * 4.184) kJ
        const expected = 3600.0 - (200.0 * 4.184);
        expect(diff.inKilojoules, closeTo(expected, highTolerance));
      });

      test('operator * and / scale energy by a scalar', () {
        final scaledUp = e3 * 4.0;
        expect(scaledUp.inKilojoules, closeTo(2000.0, defaultTolerance));

        final scaledDown = e1 / 2.0;
        expect(scaledDown.inKilowattHours, closeTo(0.5, defaultTolerance));

        expect(() => e1 / 0.0, throwsArgumentError);
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 123.456;

      for (final unit in EnergyUnit.values) {
        test('Round trip ${unit.symbol} <-> J', () {
          testRoundTrip(
            unit,
            EnergyUnit.joule,
            testValue,
            tol: (unit == EnergyUnit.electronvolt) ? 1e-5 : highTolerance,
          );
        });
      }
    });

    group('Practical Examples', () {
      test('Nutritional energy calculation', () {
        // A snack bar has 150 kcal.
        final snackBar = 150.0.kcal;
        // How much is this in kJ? (Common on food labels outside the US)
        expect(snackBar.inKilojoules, closeTo(627.6, defaultTolerance)); // 150 * 4.184
      });

      test('Household electricity consumption', () {
        // A 100W light bulb running for 24 hours.
        // Energy = Power * Time = 0.1 kW * 24 h = 2.4 kWh
        final bulbEnergy = 2.4.kWh;
        expect(bulbEnergy.inJoules, closeTo(2.4 * 3.6e6, defaultTolerance));
        expect(bulbEnergy.inMegajoules, closeTo(8.64, defaultTolerance));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/energy_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/force_test.dart -->
import 'package:quantify/acceleration.dart';
import 'package:quantify/force.dart';
import 'package:quantify/mass.dart';
import 'package:test/test.dart';

void main() {
  group('Force', () {
    const tolerance = 1e-12;
    const highTolerance = 1e-9;

    group('Constructors and Getters', () {
      test('should create from num extensions and retrieve values', () {
        final force = 100.N;
        expect(force.value, 100.0);
        expect(force.unit, ForceUnit.newton);
        expect(force.inKilonewtons, closeTo(0.1, tolerance));
      });
    });

    group('Conversions', () {
      test('Newton to other units', () {
        final force = 10.N;
        expect(force.inDynes, closeTo(1e6, highTolerance));
        expect(force.inPoundsForce, closeTo(2.24809, 1e-5));
        expect(force.inKilogramsForce, closeTo(1.01972, 1e-5));
      });

      test('Pound-force to Newtons', () {
        final force = 1.lbf;
        expect(force.inNewtons, closeTo(4.4482216152605, tolerance));
      });

      test('Kilogram-force to Newtons', () {
        final force = 1.kgf;
        expect(force.inNewtons, closeTo(9.80665, tolerance));
      });

      test('Gram-force and Poundal conversions', () {
        // 1 kgf should be 1000 gf
        final oneKgf = 1.kgf;
        expect(oneKgf.inGramsForce, closeTo(1000.0, 1e-12));

        // 1 lbf should be ~32.174 pdl (g_std in ft/s^2)
        final oneLbf = 1.lbf;
        expect(oneLbf.inPoundals, closeTo(32.174048556, 1e-8));

        // Test the base definition of poundal
        final onePdl = 1.pdl;
        expect(onePdl.inNewtons, closeTo(0.138254954376, 1e-12));
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final f1 = 10.N;
        final f2 = 1.kgf; // ~9.8 N
        final f3 = 3.lbf; // ~13.3 N

        expect(f1.compareTo(f2), greaterThan(0));
        expect(f1.compareTo(f3), lessThan(0));
        expect(f2.compareTo(f3), lessThan(0));
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction', () {
        final sum = 10.N + 1.kgf; // 10 N + ~9.8 N
        expect(sum.inNewtons, closeTo(19.80665, tolerance));
        expect(sum.unit, ForceUnit.newton);
      });

      test('should perform scalar multiplication and division', () {
        final force = 20.N;
        expect((force * 2.5).inNewtons, closeTo(50.0, tolerance));
        expect((force / 4.0).inNewtons, closeTo(5.0, tolerance));
        expect(() => force / 0, throwsArgumentError);
      });
    });

    group('Dimensional Analysis', () {
      test('Mass * Acceleration = Force', () {
        final mass = 10.kg;
        final acc = 9.80665.mpsSquared; // 1 g
        final force = Force.from(mass, acc);

        expect(force, isA<Force>());
        expect(force.inNewtons, closeTo(98.0665, tolerance));
        expect(force.inKilogramsForce, closeTo(10.0, 1e-5));
      });

      test('Force / Mass = Acceleration', () {
        final force = 100.N;
        final mass = 20.kg;
        final acc = force.accelerationOf(mass);

        expect(acc, isA<Acceleration>());
        expect(acc.inMetersPerSecondSquared, closeTo(5.0, tolerance));
        expect(() => 100.N.accelerationOf(0.kg), throwsArgumentError);
      });

      test('Force / Acceleration = Mass', () {
        final force = 50.N;
        final acc = 10.mpsSquared;
        final mass = force.massFrom(acc);

        expect(mass, isA<Mass>());
        expect(mass.inKilograms, closeTo(5.0, tolerance));
        expect(() => 50.N.massFrom(0.mpsSquared), throwsArgumentError);
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in ForceUnit.values) {
        test('Round trip ${unit.symbol} <-> N', () {
          const initialValue = 123.456;
          final force = Force(initialValue, unit);
          final roundTripForce = force.asNewtons.convertTo(unit);
          expect(roundTripForce.value, closeTo(initialValue, 1e-9));
        });
      }
    });

    group('Practical Examples', () {
      test('Weight on Earth', () {
        final personMass = 75.kg;
        final gravity = 1.gravity; // Use the specific extension for gravity
        // F = m * a
        final personWeight = Force.from(personMass, gravity);

        expect(personWeight.inNewtons, closeTo(735.5, 1e-1));
        expect(personWeight.inKilogramsForce, closeTo(75.0, 1e-5));
        expect(personWeight.inPoundsForce, closeTo(165.3, 1e-1));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/force_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/frequency_interop_test.dart -->
// test/units/frequency_interop_test.dart

import 'dart:math' as math;

import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('Frequency and AngularVelocity Interoperability', () {
    const tolerance = 1e-12;

    group('AngularVelocity to Frequency (.asFrequency)', () {
      test('should convert rpm correctly', () {
        final angularSpeed = 3000.rpm;
        final frequency = angularSpeed.asFrequency;
        expect(frequency, isA<Frequency>());
        expect(frequency.value, 3000.0);
        expect(frequency.unit, FrequencyUnit.revolutionsPerMinute);
        expect(frequency.inHertz, closeTo(50.0, tolerance));
      });

      test('should convert rad/s correctly', () {
        final angularSpeed = (20 * math.pi).radiansPerSecond;
        final frequency = angularSpeed.asFrequency;
        expect(frequency, isA<Frequency>());
        expect(frequency.value, angularSpeed.value);
        expect(frequency.unit, FrequencyUnit.radianPerSecond);
        expect(frequency.inHertz, closeTo(10.0, tolerance));
      });

      test('should convert rps correctly to Hz', () {
        // rps in AngularVelocity is 1-to-1 with Hertz in Frequency
        final angularSpeed = 10.rps;
        final frequency = angularSpeed.asFrequency;
        expect(frequency, isA<Frequency>());
        expect(frequency.value, 10.0);
        expect(frequency.unit, FrequencyUnit.hertz);
      });
    });

    group('Frequency to AngularVelocity (.asAngularVelocity)', () {
      test('should convert compatible rotational units correctly', () {
        const freqRpm = Frequency(60, FrequencyUnit.revolutionsPerMinute);
        final avRpm = freqRpm.asAngularVelocity;
        expect(avRpm, isA<AngularVelocity>());
        expect(avRpm.value, 60.0);
        expect(avRpm.unit, AngularVelocityUnit.revolutionPerMinute);
        expect(avRpm.inRps, closeTo(1.0, tolerance));

        final freqHz = 50.hz; // Represents 50 cycles/revolutions per second
        final avRps = freqHz.asAngularVelocity;
        expect(avRps, isA<AngularVelocity>());
        expect(avRps.value, 50.0);
        expect(avRps.unit, AngularVelocityUnit.revolutionPerSecond);
        expect(avRps.inRpm, closeTo(3000.0, tolerance));
      });

      test('should throw UnsupportedError for non-rotational units', () {
        final heartRate = 120.bpm;
        final radioWave = 88.5.mhz;
        final cpuClock = 4.2.ghz;

        expect(
          () => heartRate.asAngularVelocity,
          throwsA(isA<UnsupportedError>()),
          reason: 'BPM should not be convertible to AngularVelocity.',
        );
        expect(
          () => radioWave.asAngularVelocity,
          throwsA(isA<UnsupportedError>()),
          reason: 'MHz should not be convertible to AngularVelocity.',
        );
        expect(
          () => cpuClock.asAngularVelocity,
          throwsA(isA<UnsupportedError>()),
          reason: 'GHz should not be convertible to AngularVelocity.',
        );
      });

      test('error message should be informative', () {
        try {
          120.bpm.asAngularVelocity;
          fail('Should have thrown an error.');
          // ignore: avoid_catches_without_on_clauses // Catching all exceptions to check the type
        } catch (e) {
          expect(e, isA<UnsupportedError>());
          expect(
            (e as UnsupportedError).message,
            contains('unit "bpm" to an AngularVelocity'),
          );
        }
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/frequency_interop_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/frequency_test.dart -->
// test/units/frequency_test.dart
import 'package:quantify/frequency.dart';
import 'package:quantify/time.dart';
import 'package:test/test.dart';

void main() {
  group('Frequency', () {
    const tolerance = 1e-12;

    // Helper for round trip tests
    void testRoundTrip(
      FrequencyUnit initialUnit,
      FrequencyUnit intermediateUnit,
      double initialValue, {
      double tol = tolerance,
    }) {
      final f1 = Frequency(initialValue, initialUnit);
      final f2 = f1.convertTo(intermediateUnit);
      final f3 = f2.convertTo(initialUnit);
      expect(
        f3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create from num extensions and retrieve values', () {
        final freq = 100.mhz;
        expect(freq.value, 100.0);
        expect(freq.unit, FrequencyUnit.megahertz);
        expect(freq.inHertz, closeTo(1e8, tolerance));
        expect(freq.inGigahertz, closeTo(0.1, tolerance));
      });

      test('RPM and BPM should be constructible', () {
        final engineSpeed = 3000.rpm;
        expect(engineSpeed.inHertz, closeTo(50.0, tolerance)); // 3000/60

        final heartRate = 120.bpm;
        expect(heartRate.inHertz, closeTo(2.0, tolerance)); // 120/60
      });
    });

    group('Conversions', () {
      test('Hertz to other units', () {
        final oneHertz = 1.0.hz;
        expect(oneHertz.inKilohertz, closeTo(0.001, tolerance));
        expect(oneHertz.inMegahertz, closeTo(1e-6, tolerance));
        expect(oneHertz.inGigahertz, closeTo(1e-9, tolerance));
        expect(oneHertz.inRevolutionsPerMinute, closeTo(60.0, tolerance));
        expect(oneHertz.inBeatsPerMinute, closeTo(60.0, tolerance));
      });

      test('Terahertz to other SI units', () {
        final opticalFreq = 1.5.thz;
        expect(opticalFreq.inGigahertz, closeTo(1500.0, tolerance));
        expect(opticalFreq.inHertz, closeTo(1.5e12, tolerance));
      });

      test('Kilohertz to Hertz', () {
        final radioFreq = 88.5.khz;
        expect(radioFreq.inHertz, closeTo(88500.0, tolerance));
      });

      test('RPM to Hertz', () {
        final idle = 600.rpm;
        expect(idle.inHertz, closeTo(10.0, tolerance));
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final f1 = 100.mhz;
        final f2 = 0.1.ghz;
        final f3 = 99.mhz;

        expect(f1.compareTo(f2), 0);
        expect(f1.compareTo(f3), greaterThan(0));
        expect(f3.compareTo(f1), lessThan(0));
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction', () {
        final sum = 1.ghz + 200.mhz; // 1000 MHz + 200 MHz = 1200 MHz
        expect(sum.inGigahertz, closeTo(1.2, tolerance));
        expect(sum.unit, FrequencyUnit.gigahertz); // Left operand's unit

        final diff = 100.hz - 3000.rpm; // 100 Hz - 50 Hz = 50 Hz
        expect(diff.inHertz, closeTo(50.0, tolerance));
      });

      test('should perform scalar multiplication and division', () {
        final freq = 50.hz;
        expect((freq * 2.5).inHertz, closeTo(125.0, tolerance));
        expect((freq / 2.0).inHertz, closeTo(25.0, tolerance));
        expect(() => freq / 0, throwsArgumentError);
      });
    });

    group('Dimensional Analysis (Time Interop)', () {
      test('Frequency.from(Time) creates correct frequency', () {
        // Period of 20 ms -> 50 Hz
        final period = 20.ms;
        final freq = Frequency.from(period);
        expect(freq.inHertz, closeTo(50.0, tolerance));

        // Period of 1 second -> 1 Hz
        final freq2 = Frequency.from(1.s);
        expect(freq2.inHertz, closeTo(1.0, tolerance));

        expect(() => Frequency.from(0.s), throwsArgumentError);
      });

      test('frequency.period calculates correct time duration', () {
        // 50 Hz -> 20 ms period
        final freq = 50.hz;
        final period = freq.period;
        expect(period.inMilliseconds, closeTo(20.0, tolerance));

        // 4.2 GHz CPU -> ~0.238 ns period
        final cpuFreq = 4.2.ghz;
        final cycleTime = cpuFreq.period;
        expect(cycleTime.inNanoseconds, closeTo(1 / 4.2, tolerance));
        expect(cycleTime.unit, TimeUnit.second); // Always returns in base unit

        expect(() => 0.hz.period, throwsUnsupportedError);
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in FrequencyUnit.values) {
        test('Round trip ${unit.symbol} <-> Hz', () {
          testRoundTrip(unit, FrequencyUnit.hertz, 123.456);
        });
      }
    });

    group('Practical Examples', () {
      test('AC Power Frequency', () {
        final usPower = 60.hz;
        final euPower = 50.hz;
        expect(usPower.compareTo(euPower), greaterThan(0));
        expect(usPower.period.inMilliseconds, closeTo(16.666, 1e-3));
        expect(euPower.period.inMilliseconds, closeTo(20.0, tolerance));
      });

      test('Music Tempo', () {
        // A common tempo is 120 bpm
        final tempo = 120.bpm;
        // Each beat takes 0.5 seconds
        expect(tempo.period.inSeconds, closeTo(0.5, tolerance));
        expect(tempo.inHertz, closeTo(2.0, tolerance));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/frequency_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/length_test.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:quantify/quantify.dart';
import 'package:quantify/src/units/length/length_factors.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons
  const highTolerance = 1e-6; // For very large/small conversions
  const astronomicalTolerance = 1e-4; // For astronomical distances

  group('Length', () {
    // Helper for round trip tests
    void testRoundTrip(
      LengthUnit initialUnit,
      LengthUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final l1 = Length(initialValue, initialUnit);
      final l2 = l1.convertTo(intermediateUnit);
      final l3 = l2.convertTo(initialUnit);
      expect(
        l3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Length from num extensions and retrieve values', () {
        final l1 = 100.0.m;
        expect(l1.value, 100.0);
        expect(l1.unit, LengthUnit.meter);
        expect(l1.inKm, closeTo(0.1, tolerance));

        final l2 = 5.0.ft;
        expect(l2.value, 5.0);
        expect(l2.unit, LengthUnit.foot);
        expect(l2.inInch, closeTo(60.0, tolerance));

        final l3 = 12.inch;
        expect(l3.inFt, closeTo(1.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const l = Length(25.0, LengthUnit.centimeter);
        expect(l.getValue(LengthUnit.centimeter), 25.0);
      });

      test('getValue for all units from Meter base', () {
        final l = 1000.0.m; // 1 km
        expect(l.inM, 1000.0);
        expect(l.inKm, closeTo(1.0, tolerance));
        expect(l.inCm, closeTo(100000.0, tolerance));
        expect(l.inMm, closeTo(1000000.0, tolerance));
        expect(l.inInch, closeTo(1000.0 / 0.0254, 1e-7));
        expect(l.inFt, closeTo(1000.0 / 0.3048, 1e-7));
        expect(l.inYd, closeTo(1000.0 / 0.9144, 1e-7));
        expect(l.inMi, closeTo(1000.0 / 1609.344, 1e-7));
        expect(l.inNmi, closeTo(1000.0 / 1852.0, 1e-7));
      });
    });

    group('Conversions', () {
      final oneMeter = 1.0.m;

      test('1 meter to various units', () {
        expect(oneMeter.inKm, closeTo(0.001, tolerance));
        expect(oneMeter.inCm, closeTo(100.0, tolerance));
        expect(oneMeter.inMm, closeTo(1000.0, tolerance));
        expect(oneMeter.inInch, closeTo(1 / 0.0254, 1e-7)); // 39.3700787...
        expect(oneMeter.inFt, closeTo(1 / 0.3048, 1e-7)); // 3.2808398...
        expect(oneMeter.inYd, closeTo(1 / 0.9144, 1e-7)); // 1.0936132...
      });

      final oneFoot = 1.0.ft;
      test('1 foot to various units', () {
        expect(oneFoot.inM, closeTo(0.3048, tolerance));
        expect(oneFoot.inInch, closeTo(12.0, tolerance));
        expect(oneFoot.inYd, closeTo(1.0 / 3.0, tolerance));
      });

      final oneMile = 1.0.mi;
      test('1 mile to various units', () {
        expect(oneMile.inM, closeTo(1609.344, tolerance));
        expect(oneMile.inFt, closeTo(5280.0, tolerance));
        expect(oneMile.inYd, closeTo(1760.0, tolerance));
        expect(oneMile.inKm, closeTo(1.609344, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Length object with converted value and unit', () {
        final lMeters = 10.0.m;
        final lFeet = lMeters.convertTo(LengthUnit.foot);
        expect(lFeet.unit, LengthUnit.foot);
        expect(lFeet.value, closeTo(lMeters.inFt, tolerance));
        expect(lMeters.unit, LengthUnit.meter); // Original should be unchanged
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final l1 = 10.0.m;
        final l2 = l1.convertTo(LengthUnit.meter);
        expect(identical(l1, l2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final lMeter = 1.0.m;
      final lSlightlyLessCm = 99.0.cm;
      final lSlightlyMoreCm = 101.0.cm;
      final lFoot = 3.0.ft; // 0.9144 meters

      test('should correctly compare lengths of different units', () {
        expect(lMeter.compareTo(lSlightlyLessCm), greaterThan(0));
        expect(lSlightlyLessCm.compareTo(lMeter), lessThan(0));
        expect(lMeter.compareTo(lSlightlyMoreCm), lessThan(0));
        expect(lMeter.compareTo(lFoot), greaterThan(0)); // 1m > 3ft
      });

      test('should return 0 for equal lengths in different units', () {
        final lCm = 100.0.cm;
        final lInches = (1.0 / 0.0254).inch; // 1 meter in inches
        expect(lMeter.compareTo(lCm), 0);
        expect(lCm.compareTo(lMeter), 0);
        expect(lMeter.compareTo(lInches), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const l1 = Length(10.0, LengthUnit.meter);
        const l2 = Length(10.0, LengthUnit.meter);
        expect(l1 == l2, isTrue);
        expect(l1.hashCode == l2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const l1 = Length(10.0, LengthUnit.meter);
        const l2 = Length(10.1, LengthUnit.meter);
        const l3 = Length(10.0, LengthUnit.foot);
        expect(l1 == l2, isFalse);
        expect(l1 == l3, isFalse);
        expect(l1.hashCode == l2.hashCode, isFalse);
        expect(l1.hashCode == l3.hashCode, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(10.5.m.toString(), '10.5 m');
        expect(12.0.inch.toString(), '12.0 in');
        expect(1.6.km.toString(), '1.6 km');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 789.123;
      const highTolerance = 1e-7; // For chains of conversions

      for (final unit in LengthUnit.values) {
        test('Round trip ${unit.symbol} <-> m', () {
          testRoundTrip(
            unit,
            LengthUnit.meter,
            testValue,
            tolerance: (unit == LengthUnit.meter) ? tolerance : highTolerance,
          );
        });
      }

      test('Round trip ft <-> in', () {
        testRoundTrip(LengthUnit.foot, LengthUnit.inch, testValue);
      });
      test('Round trip yd <-> mi', () {
        testRoundTrip(LengthUnit.yard, LengthUnit.mile, 5000.0, tolerance: highTolerance);
      });
      test('Round trip cm <-> km', () {
        testRoundTrip(
          LengthUnit.centimeter,
          LengthUnit.kilometer,
          250000.0,
          tolerance: highTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final lZero = 0.0.m;
        for (final unit in LengthUnit.values) {
          expect(lZero.getValue(unit), 0.0, reason: '0 m to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for Length', () {
      final l1Meter = 1.0.m;
      final l2Meters = 2.0.m;
      final l50Cm = 50.cm; // 0.5 meters

      // Operator +
      test('operator + combines lengths', () {
        final sum1 = l2Meters + l1Meter;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, LengthUnit.meter);

        final sum2 = l1Meter + l50Cm; // 1m + 0.5m = 1.5m
        expect(sum2.value, closeTo(1.5, tolerance));
        expect(sum2.unit, LengthUnit.meter);

        final sum3 = l50Cm + l1Meter; // 50cm + 100cm = 150cm
        expect(sum3.value, closeTo(150.0, tolerance));
        expect(sum3.unit, LengthUnit.centimeter);
      });

      // Operator -
      test('operator - subtracts lengths', () {
        final diff1 = l2Meters - l1Meter;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, LengthUnit.meter);

        final diff2 = l1Meter - l50Cm; // 1m - 0.5m = 0.5m
        expect(diff2.value, closeTo(0.5, tolerance));
        expect(diff2.unit, LengthUnit.meter);

        final diff3 = l2Meters - l50Cm.convertTo(LengthUnit.meter); // 2m - 0.5m = 1.5m
        expect(diff3.value, closeTo(1.5, tolerance));
        expect(diff3.unit, LengthUnit.meter);
      });

      // Operator * (scalar)
      test('operator * scales length by a scalar', () {
        final scaled = l2Meters * 3.0;
        expect(scaled.value, closeTo(6.0, tolerance));
        expect(scaled.unit, LengthUnit.meter);

        final scaledCm = l50Cm * 2.5;
        expect(scaledCm.value, closeTo(125.0, tolerance));
        expect(scaledCm.unit, LengthUnit.centimeter);
      });

      // Operator / (scalar)
      test('operator / scales length by a scalar', () {
        final scaled = l2Meters / 2.0;
        expect(scaled.value, closeTo(1.0, tolerance));
        expect(scaled.unit, LengthUnit.meter);

        expect(() => l1Meter / 0.0, throwsArgumentError);
      });

      test('operator chaining preserves immutability', () {
        final initialLength = 10.m;
        final l1 = initialLength + 5.m; // 15m
        final l2 = l1 * 2.0; // 30m
        final l3 = l2 - 100.cm; // 30m - 1m = 29m

        expect(initialLength.value, 10.0); // Original unchanged
        expect(l1.value, closeTo(15.0, tolerance));
        expect(l2.value, closeTo(30.0, tolerance));
        expect(l3.value, closeTo(29.0, tolerance));
        expect(l3.unit, LengthUnit.meter);
      });
    });
  });

  group('Extended Length Units', () {
    group('SI Prefix Units', () {
      test('hectometer conversions', () {
        final oneHectometer = 1.0.hm;
        expect(oneHectometer.inM, closeTo(100.0, tolerance));
        expect(oneHectometer.inKm, closeTo(0.1, tolerance));
        expect(oneHectometer.inCm, closeTo(10000.0, tolerance));
      });

      test('decameter conversions', () {
        final oneDecameter = 1.0.dam;
        expect(oneDecameter.inM, closeTo(10.0, tolerance));
        expect(oneDecameter.inHm, closeTo(0.1, tolerance));
        expect(oneDecameter.inDm, closeTo(100.0, tolerance));
      });

      test('decimeter conversions', () {
        final oneDecimeter = 1.0.dm;
        expect(oneDecimeter.inM, closeTo(0.1, tolerance));
        expect(oneDecimeter.inCm, closeTo(10.0, tolerance));
        expect(oneDecimeter.inMm, closeTo(100.0, tolerance));
      });

      test('micrometer conversions', () {
        final oneMicrometer = 1.0.um;
        expect(oneMicrometer.inM, closeTo(1e-6, tolerance));
        expect(oneMicrometer.inMm, closeTo(0.001, tolerance));
        expect(oneMicrometer.inNm, closeTo(1000.0, tolerance));
      });

      test('nanometer conversions', () {
        final oneNanometer = 1.0.nm;
        expect(oneNanometer.inM, closeTo(1e-9, tolerance));
        expect(oneNanometer.inUm, closeTo(0.001, tolerance));
        expect(oneNanometer.inPm, closeTo(1000.0, tolerance));
      });

      test('picometer conversions', () {
        final onePicometer = 1.0.pm;
        expect(onePicometer.inM, closeTo(1e-12, tolerance));
        expect(onePicometer.inNm, closeTo(0.001, tolerance));
        expect(onePicometer.inFm, closeTo(1000.0, tolerance));
      });

      test('femtometer conversions', () {
        final oneFemtometer = 1.0.fm;
        expect(oneFemtometer.inM, closeTo(1e-15, tolerance));
        expect(oneFemtometer.inPm, closeTo(0.001, tolerance));
      });
    });

    group('Astronomical Units', () {
      test('astronomical unit conversions', () {
        final oneAU = 1.0.AU;
        expect(oneAU.inM, closeTo(149597870700.0, tolerance));
        expect(oneAU.inKm, closeTo(149597870.7, highTolerance));

        // Test practical astronomy example
        final marsDistance = 1.5.AU; // Mars at average distance
        expect(marsDistance.inKm, closeTo(224396806.05, highTolerance));
      });

      test('light year conversions', () {
        final oneLightYear = 1.0.ly;
        // Expected value calculated using the library's own factors
        const expectedAUperLY =
            LengthFactors.metersPerLightYear / LengthFactors.metersPerAstronomicalUnit;

        expect(oneLightYear.inAU, closeTo(expectedAUperLY, astronomicalTolerance));

        // Test nearby star distance
        final proximaCentauri = 4.24.ly;
        const expectedProximaInAU = 4.24 * expectedAUperLY; // Calculate expected value
        expect(proximaCentauri.inAU, closeTo(expectedProximaInAU, astronomicalTolerance));
      });

      test('parsec conversions', () {
        final oneParsec = 1.0.pc;
        const expectedAUperPC =
            LengthFactors.metersPerParsec / LengthFactors.metersPerAstronomicalUnit;

        expect(oneParsec.inLy, closeTo(3.26156, astronomicalTolerance));
        expect(oneParsec.inAU, closeTo(expectedAUperPC, astronomicalTolerance));
        expect(oneParsec.inM, closeTo(3.0856775814913673e16, astronomicalTolerance));
      });

      test('astronomical distance relationships', () {
        // Test the relationship: 1 pc ≈ 3.26 ly
        final oneParsec = 1.0.pc;
        final equivalentLy = oneParsec.inLy;
        expect(equivalentLy, closeTo(3.26156, astronomicalTolerance));

        // Test parallax relationship: distance in parsecs = 1 / parallax in arcseconds
        // For a star with 0.1 arcsecond parallax, distance should be 10 parsecs
        final starDistance = 10.0.pc;
        expect(starDistance.inLy, closeTo(32.6156, astronomicalTolerance));
      });
    });

    group('Ångström conversions', () {
      test('ångström basic conversions', () {
        final oneAngstrom = 1.0.angstrom;
        expect(oneAngstrom.inM, closeTo(1e-10, tolerance));
        expect(oneAngstrom.inNm, closeTo(0.1, tolerance));
        expect(oneAngstrom.inPm, closeTo(100.0, tolerance));
      });

      test('atomic scale measurements', () {
        // Hydrogen atom radius ≈ 0.529 Å (Bohr radius)
        final hydrogenRadius = 0.529.angstrom;
        expect(hydrogenRadius.inPm, closeTo(52.9, tolerance));
        expect(hydrogenRadius.inNm, closeTo(0.0529, tolerance));

        // X-ray wavelength ≈ 1-10 Å
        final xrayWavelength = 1.54.angstrom; // Cu Kα radiation
        expect(xrayWavelength.inNm, closeTo(0.154, tolerance));
      });
    });

    group('Mixed unit arithmetic and comparisons', () {
      test('very different scales addition', () {
        final bigDistance = 1.0.ly;
        final smallDistance = 1.0.m;
        final combined = bigDistance + smallDistance;

        // The meter should be insignificant compared to light year
        expect(combined.inLy, closeTo(1.0, astronomicalTolerance));
        expect(combined.unit, LengthUnit.lightYear);
      });

      test('practical scientific measurements', () {
        // DNA double helix diameter ≈ 20 Å
        final dnaDiameter = 20.0.angstrom;
        expect(dnaDiameter.inNm, closeTo(2.0, tolerance));

        // Wavelength of visible light: 400-700 nm
        final blueLight = 450.0.nm;
        final redLight = 650.0.nm;
        expect(blueLight.inAngstrom, closeTo(4500.0, tolerance));
        expect(redLight.inAngstrom, closeTo(6500.0, tolerance));

        // Compare with X-ray
        final xray = 1.0.angstrom;
        expect(blueLight.compareTo(xray), greaterThan(0)); // Visible light has longer wavelength
      });

      test('sorting astronomical distances', () {
        final distances = [
          1.pc, // ~3.26 ly
          10.ly, // 10 ly
          1000.AU, // ~0.016 ly
          1.ly, // 1 ly
          100000.AU, // ~1.58 ly
        ];

        // ignore: cascade_invocations // Sort by magnitude
        distances.sort();

        // Should be sorted by magnitude: 1000 AU < 100000 AU < 1 ly < 1 pc < 10 ly
        expect(distances[0].unit, LengthUnit.astronomicalUnit);
        expect(distances[0].value, 1000.0);
        expect(distances[4].value, 10.0);
        expect(distances[4].unit, LengthUnit.lightYear);
      });
    });

    group('Round trip conversions for new units', () {
      const testValue = 123.456;

      test('SI prefix round trips', () {
        final units = [
          LengthUnit.hectometer,
          LengthUnit.decameter,
          LengthUnit.decimeter,
          LengthUnit.micrometer,
          LengthUnit.nanometer,
          LengthUnit.picometer,
          LengthUnit.femtometer,
        ];

        for (final unit in units) {
          final original = Length(testValue, unit);
          final converted = original.convertTo(LengthUnit.meter).convertTo(unit);
          expect(
            converted.value,
            closeTo(testValue, highTolerance),
            reason: 'Round trip failed for ${unit.symbol}',
          );
        }
      });

      test('astronomical unit round trips', () {
        final astronomicalUnits = [
          LengthUnit.astronomicalUnit,
          LengthUnit.lightYear,
          LengthUnit.parsec,
        ];

        for (final unit in astronomicalUnits) {
          final original = Length(testValue, unit);
          final converted = original.convertTo(LengthUnit.meter).convertTo(unit);
          expect(
            converted.value,
            closeTo(testValue, astronomicalTolerance),
            reason: 'Round trip failed for ${unit.symbol}',
          );
        }
      });

      test('ångström round trip', () {
        const original = Length(testValue, LengthUnit.angstrom);
        final converted = original.convertTo(LengthUnit.meter).convertTo(LengthUnit.angstrom);
        expect(converted.value, closeTo(testValue, tolerance));
      });
    });

    group('toString formatting for new units', () {
      test('should display correct symbols', () {
        expect(1.0.hm.toString(), '1.0\u00A0hm');
        expect(1.0.dam.toString(), '1.0\u00A0dam');
        expect(1.0.dm.toString(), '1.0\u00A0dm');
        expect(1.0.um.toString(), '1.0\u00A0μm');
        expect(1.0.nm.toString(), '1.0\u00A0nm');
        expect(1.0.pm.toString(), '1.0\u00A0pm');
        expect(1.0.fm.toString(), '1.0\u00A0fm');
        expect(1.0.AU.toString(), '1.0\u00A0AU');
        expect(1.0.ly.toString(), '1.0\u00A0ly');
        expect(1.0.pc.toString(), '1.0\u00A0pc');
        expect(1.0.angstrom.toString(), '1.0\u00A0Å');
      });
    });
    group('Mega and Giga Units', () {
      const tolerance = 1e-9;

      test('megameter conversions', () {
        final oneMegameter = 1.0.megaM;
        expect(oneMegameter.inM, closeTo(1e6, tolerance));
        expect(oneMegameter.inKm, closeTo(1000.0, tolerance));
        expect(oneMegameter.inGigaM, closeTo(0.001, tolerance));
      });

      test('gigameter conversions', () {
        final oneGigameter = 1.0.gigaM;
        expect(oneGigameter.inM, closeTo(1e9, tolerance));
        expect(oneGigameter.inKm, closeTo(1e6, tolerance));
        expect(oneGigameter.inMegaM, closeTo(1000.0, tolerance));
      });

      test('astronomical scale examples', () {
        // Earth's diameter is about 12.742 Mm
        final earthDiameter = 12.742.megaM;
        expect(earthDiameter.inKm, closeTo(12742.0, tolerance));

        // Sun's diameter is about 1.3927 Gm
        final sunDiameter = 1.3927.gigaM;
        expect(sunDiameter.inMegaM, closeTo(1392.7, tolerance));
        expect(sunDiameter.inKm, closeTo(1392700.0, tolerance));

        // Compare Earth and Sun
        expect(sunDiameter.compareTo(earthDiameter), greaterThan(0));
      });
    });
  });

  group('Quantity Comparison Operators for Length', () {
    // --- Test Fixtures ---
    final oneMeter = 1.m;
    final oneMeterAgain = 1.m; // Different instance, same value/unit
    final twoMeters = 2.m;
    final hundredCm = 100.cm; // Equivalent to 1 meter
    final ninetyNineCm = 99.cm; // Less than 1 meter
    final oneHundredOneCm = 101.cm; // More than 1 meter
    final oneFoot = 1.ft; // Different unit, different magnitude

    group('Strict Equality (operator ==)', () {
      test('should return true for identical value and unit', () {
        expect(oneMeter == oneMeterAgain, isTrue);
      });

      test('should return false for different values, even with same unit', () {
        expect(oneMeter == twoMeters, isFalse);
      });

      test('should return false for different units, even with same magnitude', () {
        // This is the core distinction: == checks for strict, not magnitude, equality.
        expect(oneMeter == hundredCm, isFalse);
      });

      test('should return false for different units and different magnitudes', () {
        expect(oneMeter == oneFoot, isFalse);
      });

      test('should have consistent hashCode with strict equality', () {
        expect(oneMeter.hashCode, equals(oneMeterAgain.hashCode));
        expect(oneMeter.hashCode, isNot(equals(twoMeters.hashCode)));
        expect(oneMeter.hashCode, isNot(equals(hundredCm.hashCode)));
      });
    });

    group('Magnitude Equality (isEquivalentTo)', () {
      test('should return true for different units with the same magnitude', () {
        expect(oneMeter.isEquivalentTo(hundredCm), isTrue);
      });

      test('should return true for identical value and unit', () {
        expect(oneMeter.isEquivalentTo(oneMeterAgain), isTrue);
      });

      test('should return false for different magnitudes', () {
        expect(oneMeter.isEquivalentTo(ninetyNineCm), isFalse);
        expect(oneMeter.isEquivalentTo(twoMeters), isFalse);
      });

      test('floating point inaccuracy showcase', () {
        // As documented, direct float arithmetic can lead to non-equivalence.
        final l1 = 0.1.m;
        final l2 = 0.2.m;
        final sum = l1 + l2; // Internally, this is 0.1 + 0.2
        final l3 = 0.3.m;

        // 0.1 + 0.2 is famously not exactly 0.3 in binary floating point.
        expect(sum.value, isNot(equals(0.3)));
        expect(sum.isEquivalentTo(l3), isFalse);
      });
    });

    group('Relational Operators (>, <, >=, <=)', () {
      // --- Operator > (Greater Than) ---
      test('operator > should be true when left operand is larger', () {
        expect(twoMeters > oneMeter, isTrue);
        expect(oneMeter > ninetyNineCm, isTrue);
        expect(1.mi > 1.km, isTrue); // 1 mile > 1 kilometer
      });

      test('operator > should be false when left operand is smaller', () {
        expect(oneMeter > twoMeters, isFalse);
        expect(ninetyNineCm > oneMeter, isFalse);
      });

      test('operator > should be false for equivalent magnitudes', () {
        expect(oneMeter > hundredCm, isFalse);
      });

      // --- Operator < (Less Than) ---
      test('operator < should be true when left operand is smaller', () {
        expect(oneMeter < twoMeters, isTrue);
        expect(ninetyNineCm < oneMeter, isTrue);
        expect(1.km < 1.mi, isTrue);
      });

      test('operator < should be false when left operand is larger', () {
        expect(twoMeters < oneMeter, isFalse);
        expect(oneMeter < ninetyNineCm, isFalse);
      });

      test('operator < should be false for equivalent magnitudes', () {
        expect(oneMeter < hundredCm, isFalse);
      });

      // --- Operator >= (Greater Than or Equal) ---
      test('operator >= should be true for equivalent magnitudes', () {
        expect(oneMeter >= hundredCm, isTrue);
        expect(hundredCm >= oneMeter, isTrue);
      });

      test('operator >= should be true when left operand is larger', () {
        expect(twoMeters >= oneMeter, isTrue);
        expect(oneMeter >= ninetyNineCm, isTrue);
      });

      test('operator >= should be false when left operand is smaller', () {
        expect(oneMeter >= twoMeters, isFalse);
        expect(ninetyNineCm >= oneMeter, isFalse);
      });

      // --- Operator <= (Less Than or Equal) ---
      test('operator <= should be true for equivalent magnitudes', () {
        expect(oneMeter <= hundredCm, isTrue);
        expect(hundredCm <= oneMeter, isTrue);
      });

      test('operator <= should be true when left operand is smaller', () {
        expect(oneMeter <= twoMeters, isTrue);
        expect(ninetyNineCm <= oneMeter, isTrue);
      });

      test('operator <= should be false when left operand is larger', () {
        expect(twoMeters <= oneMeter, isFalse);
        expect(oneMeter <= ninetyNineCm, isFalse);
      });
    });

    group('Consistency between compareTo, isEquivalentTo, and operators', () {
      test('isEquivalentTo(b) should be consistent with a.compareTo(b) == 0', () {
        expect(oneMeter.isEquivalentTo(hundredCm), equals(oneMeter.compareTo(hundredCm) == 0));
        expect(
          oneMeter.isEquivalentTo(ninetyNineCm),
          equals(oneMeter.compareTo(ninetyNineCm) == 0),
        );
      });

      test('a > b should be consistent with a.compareTo(b) > 0', () {
        expect(oneMeter > ninetyNineCm, equals(oneMeter.compareTo(ninetyNineCm) > 0));
        expect(ninetyNineCm > oneMeter, equals(ninetyNineCm.compareTo(oneMeter) > 0));
      });

      test('a < b should be consistent with a.compareTo(b) < 0', () {
        expect(oneMeter < oneHundredOneCm, equals(oneMeter.compareTo(oneHundredOneCm) < 0));
        expect(oneHundredOneCm < oneMeter, equals(oneHundredOneCm.compareTo(oneMeter) < 0));
      });

      test('a >= b should be consistent with a.compareTo(b) >= 0', () {
        expect(oneMeter >= hundredCm, equals(oneMeter.compareTo(hundredCm) >= 0));
        expect(oneMeter >= ninetyNineCm, equals(oneMeter.compareTo(ninetyNineCm) >= 0));
        expect(ninetyNineCm >= oneMeter, equals(ninetyNineCm.compareTo(oneMeter) >= 0));
      });

      test('a <= b should be consistent with a.compareTo(b) <= 0', () {
        expect(oneMeter <= hundredCm, equals(oneMeter.compareTo(hundredCm) <= 0));
        expect(oneMeter <= oneHundredOneCm, equals(oneMeter.compareTo(oneHundredOneCm) <= 0));
        expect(oneHundredOneCm <= oneMeter, equals(oneHundredOneCm.compareTo(oneMeter) <= 0));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/length_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/luminous_intensity_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming LuminousIntensity and Unit are exported
import 'package:test/test.dart';

void main() {
  group('LuminousIntensity', () {
    const strictTolerance = 1e-12; // For "exact" conversions
    const defaultTolerance = 1e-9; // General purpose

    // Helper for round trip tests
    void testRoundTrip(
      LuminousIntensityUnit initialUnit,
      LuminousIntensityUnit intermediateUnit,
      double initialValue, {
      double tol = defaultTolerance,
    }) {
      final li1 = LuminousIntensity(initialValue, initialUnit);
      final li2 = li1.convertTo(intermediateUnit);
      final li3 = li2.convertTo(initialUnit);
      expect(
        li3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${li3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create LuminousIntensity from num extensions and retrieve values', () {
        final liCd = 100.0.cd;
        expect(liCd.value, 100.0);
        expect(liCd.unit, LuminousIntensityUnit.candela);
        expect(liCd.inMillicandelas, closeTo(100000.0, strictTolerance));
        expect(liCd.asMillicandelas.value, closeTo(100000.0, strictTolerance));
        expect(liCd.asMillicandelas.unit, LuminousIntensityUnit.millicandela);

        final liMcd = 250.0.millicandelas; // Using alias
        expect(liMcd.value, 250.0);
        expect(liMcd.unit, LuminousIntensityUnit.millicandela);
        expect(liMcd.inCandelas, closeTo(0.25, strictTolerance));

        final liKcd = 0.5.kcd;
        expect(liKcd.value, 0.5);
        expect(liKcd.unit, LuminousIntensityUnit.kilocandela);
        expect(liKcd.inCandelas, closeTo(500.0, strictTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const intensity = LuminousIntensity(15.0, LuminousIntensityUnit.candela);
        expect(intensity.getValue(LuminousIntensityUnit.candela), 15.0);
      });
    });

    group('Conversions between various luminous intensity units', () {
      final oneCandela = 1.0.cd;
      test('1 Candela to other units', () {
        expect(oneCandela.inMillicandelas, closeTo(1000.0, strictTolerance));
        expect(oneCandela.inKilocandelas, closeTo(0.001, strictTolerance));
      });

      final oneKilocandela = 1.0.kcd;
      test('1 Kilocandela to candelas and millicandelas', () {
        expect(oneKilocandela.inCandelas, closeTo(1000.0, strictTolerance));
        expect(oneKilocandela.inMillicandelas, closeTo(1000000.0, strictTolerance));
      });

      final oneMillicandela = 1.0.mcd;
      test('1 Millicandela to candelas', () {
        expect(oneMillicandela.inCandelas, closeTo(0.001, strictTolerance));
      });
    });

    group('convertTo method', () {
      test('should return new LuminousIntensity object with converted value and unit', () {
        final liMcd = 12500.0.mcd;
        final liCd = liMcd.convertTo(LuminousIntensityUnit.candela);

        expect(liCd.unit, LuminousIntensityUnit.candela);
        expect(liCd.value, closeTo(12.5, strictTolerance));
        expect(liMcd.unit, LuminousIntensityUnit.millicandela); // Original unchanged
        expect(liMcd.value, 12500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final li1 = 10.0.cd;
        final li2 = li1.convertTo(LuminousIntensityUnit.candela);
        expect(identical(li1, li2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final li1Cd = 1.0.cd;
      final li1000Mcd = 1000.0.mcd;
      final li999Mcd = 999.0.mcd;
      final li0_002Kcd = 0.002.kcd; // 2 cd
      final li0_0005Kcd = 0.0005.kcd; // 0.5 cd

      test('should correctly compare luminous intensities of different units', () {
        expect(li1Cd.compareTo(li999Mcd), greaterThan(0)); // 1cd > 999mcd
        expect(li999Mcd.compareTo(li1Cd), lessThan(0)); // 999mcd < 1cd
        expect(li1Cd.compareTo(li1000Mcd), 0); // 1cd == 1000mcd

        expect(li1Cd.compareTo(li0_002Kcd), lessThan(0)); // 1cd < 2cd
        expect(li1Cd.compareTo(li0_0005Kcd), greaterThan(0)); // 1cd > 0.5cd
      });

      test('should return 0 for equal luminous intensities in different units', () {
        final liInKcd = 0.001.kcd; // 1 cd in kilocandelas
        expect(li1Cd.compareTo(liInKcd), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const li1 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        const li2 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        expect(li1 == li2, isTrue);
        expect(li1.hashCode == li2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const li1 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        const li2Diffval = LuminousIntensity(50.1, LuminousIntensityUnit.candela);
        const li3Diffunit = LuminousIntensity(50.0, LuminousIntensityUnit.millicandela);

        expect(li1 == li2Diffval, isFalse);
        expect(li1 == li3Diffunit, isFalse);

        expect(li1.hashCode == li2Diffval.hashCode, isFalse);
        expect(li1.hashCode == li3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.cd is not equal to 1000.mcd', () {
        final oneCd = 1.cd;
        final thousandMcd = 1000.mcd;
        expect(oneCd == thousandMcd, isFalse);
        expect(oneCd.compareTo(thousandMcd), 0);
      });
    });

    group('toString() (basic check)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(75.5.cd.toString(), '75.5\u00A0cd');
        expect(120.mcd.toString(), '120.0\u00A0mcd');
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 123.456;

      for (final unit in LuminousIntensityUnit.values) {
        test('Round trip ${unit.symbol} <-> cd', () {
          testRoundTrip(
            unit,
            LuminousIntensityUnit.candela,
            testValue,
            tol: strictTolerance, // Factors are exact powers of 10
          );
        });
      }

      test('Round trip mcd <-> kcd', () {
        // Test with a value that doesn't become too small/large after conversion
        testRoundTrip(
          LuminousIntensityUnit.millicandela,
          LuminousIntensityUnit.kilocandela,
          500000.0,
          tol: strictTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final liZeroCd = 0.0.cd;
        for (final unit in LuminousIntensityUnit.values) {
          expect(liZeroCd.getValue(unit), 0.0, reason: '0 cd to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for LuminousIntensity', () {
      final li100cd = 100.0.cd;
      final li200cd = 200.0.cd;
      final li50000mcd = 50000.0.mcd; // 50 cd

      // Operator +
      test('operator + combines luminous intensities', () {
        final sum1 = li200cd + li100cd;
        expect(sum1.value, closeTo(300.0, defaultTolerance));
        expect(sum1.unit, LuminousIntensityUnit.candela);

        final sum2 = li100cd + li50000mcd; // 100cd + 50cd = 150cd
        expect(sum2.value, closeTo(150.0, defaultTolerance));
        expect(sum2.unit, LuminousIntensityUnit.candela);

        final sum3 = li50000mcd + li100cd; // 50000mcd + 100000mcd = 150000mcd
        expect(sum3.value, closeTo(150000.0, defaultTolerance));
        expect(sum3.unit, LuminousIntensityUnit.millicandela);
      });

      // Operator -
      test('operator - subtracts luminous intensities', () {
        final diff1 = li200cd - li100cd;
        expect(diff1.value, closeTo(100.0, defaultTolerance));
        expect(diff1.unit, LuminousIntensityUnit.candela);

        final diff2 = li100cd - li50000mcd; // 100cd - 50cd = 50cd
        expect(diff2.value, closeTo(50.0, defaultTolerance));
        expect(diff2.unit, LuminousIntensityUnit.candela);
      });

      // Operator * (scalar)
      test('operator * scales luminous intensity by a scalar', () {
        final scaled1 = li100cd * 2.5;
        expect(scaled1.value, closeTo(250.0, defaultTolerance));
        expect(scaled1.unit, LuminousIntensityUnit.candela);
      });

      // Operator / (scalar)
      test('operator / scales luminous intensity by a scalar', () {
        final scaled1 = li200cd / 4.0;
        expect(scaled1.value, closeTo(50.0, defaultTolerance));
        expect(scaled1.unit, LuminousIntensityUnit.candela);

        expect(() => li100cd / 0.0, throwsArgumentError);
      });

      test('operator chaining preserves immutability', () {
        final initialIntensity = 50.cd;
        final liAdd = initialIntensity + 10000.mcd; // 50cd + 10cd = 60cd
        final liMul = liAdd * 2.0; // 60cd * 2 = 120cd
        final liSub = liMul - 0.01.kcd; // 120cd - 10cd = 110cd

        expect(initialIntensity.value, 50.0);
        expect(initialIntensity.unit, LuminousIntensityUnit.candela);

        expect(liAdd.value, closeTo(60.0, defaultTolerance));
        expect(liAdd.unit, LuminousIntensityUnit.candela);

        expect(liMul.value, closeTo(120.0, defaultTolerance));
        expect(liMul.unit, LuminousIntensityUnit.candela);

        final expectedLiSubVal = 120.0 - 0.01.kcd.getValue(LuminousIntensityUnit.candela);
        expect(liSub.value, closeTo(expectedLiSubVal, defaultTolerance));
        expect(liSub.unit, LuminousIntensityUnit.candela);
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/luminous_intensity_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/mass_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming Mass and MassUnit are exported via quantify.dart
import 'package:quantify/src/units/mass/mass_factors.dart';
import 'package:test/test.dart';

void main() {
  const highPrecisiontolerance = 1e-12; // High precision for mass
  const highTolerance = 1e-7; // Higher tolerance for chained conversions or inexact factors
  const tolerance = 1e-9; // Tolerance for double comparisons
  const atomicTolerance = 1e-30; // For atomic mass units

  group('Mass', () {
    // Helper for round trip tests
    void testRoundTrip(
      MassUnit initialUnit,
      MassUnit intermediateUnit,
      double initialValue, {
      double tol = highTolerance, // Use highTolerance as default for round trips
    }) {
      final m1 = Mass(initialValue, initialUnit);
      final m2 = m1.convertTo(intermediateUnit);
      final m3 = m2.convertTo(initialUnit);
      expect(
        m3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${m3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create Mass from num extensions and retrieve values correctly', () {
        final mKg = 10.0.kg;
        expect(mKg.value, 10.0);
        expect(mKg.unit, MassUnit.kilogram);
        expect(mKg.inGrams, closeTo(10000.0, tolerance));
        expect(mKg.asGrams.value, closeTo(10000.0, tolerance));
        expect(mKg.asGrams.unit, MassUnit.gram);

        final mGrams = 500.0.grams; // Using alias
        expect(mGrams.value, 500.0);
        expect(mGrams.unit, MassUnit.gram);
        expect(mGrams.inKilograms, closeTo(0.5, tolerance));

        final mLbs = 2.0.pounds; // Using alias
        expect(mLbs.value, 2.0);
        expect(mLbs.unit, MassUnit.pound);
        // 2 lb * 0.45359237 kg/lb = 0.90718474 kg
        expect(mLbs.inKilograms, closeTo(0.90718474, highTolerance));

        final mOz = 16.0.oz; // 1 pound
        expect(mOz.value, 16.0);
        expect(mOz.unit, MassUnit.ounce);
        expect(mOz.inPounds, closeTo(1.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const mass = Mass(25.0, MassUnit.gram);
        expect(mass.getValue(MassUnit.gram), 25.0);
      });
    });

    group('Conversions between various units', () {
      final oneKg = 1.0.kg;
      test('1 Kilogram to other units', () {
        expect(oneKg.inGrams, closeTo(1000.0, tolerance));
        expect(oneKg.inMilligrams, closeTo(1000000.0, tolerance));
        expect(oneKg.inTonnes, closeTo(0.001, tolerance));
        expect(oneKg.inPounds, closeTo(1.0 / 0.45359237, highTolerance)); // ~2.20462 lbs
        expect(oneKg.inOunces, closeTo(16.0 / 0.45359237, highTolerance)); // ~35.27396 oz
        expect(oneKg.inStones, closeTo(1.0 / (14.0 * 0.45359237), highTolerance)); // ~0.15747 st
        expect(oneKg.inSlugs, closeTo(1.0 / 14.5939029372, highTolerance)); // ~0.06852 slugs
      });

      final onePound = 1.0.lb;
      test('1 Pound to other units', () {
        expect(onePound.inKilograms, closeTo(0.45359237, tolerance));
        expect(onePound.inGrams, closeTo(453.59237, tolerance));
        expect(onePound.inOunces, closeTo(16.0, tolerance));
        expect(onePound.inStones, closeTo(1.0 / 14.0, highTolerance));
      });

      final oneOunce = 1.0.oz;
      test('1 Ounce to grams', () {
        expect(oneOunce.inGrams, closeTo(0.45359237 * 1000.0 / 16.0, highTolerance)); // ~28.3495 g
      });

      final oneTonne = 1.0.t;
      test('1 Tonne to kilograms and pounds', () {
        expect(oneTonne.inKilograms, closeTo(1000.0, tolerance));
        expect(oneTonne.inPounds, closeTo(1000.0 / 0.45359237, highTolerance));
      });

      final oneSlug = 1.0.slugs;
      test('1 Slug to kilograms and pounds', () {
        expect(oneSlug.inKilograms, closeTo(14.5939029372, tolerance));
        expect(oneSlug.inPounds, closeTo(14.5939029372 / 0.45359237, highTolerance)); // ~32.174 lbs
      });
    });

    group('convertTo method', () {
      test('should return new Mass object with converted value and unit', () {
        final massGrams = 1500.0.g;
        final massKilograms = massGrams.convertTo(MassUnit.kilogram);

        expect(massKilograms.unit, MassUnit.kilogram);
        expect(massKilograms.value, closeTo(1.5, tolerance));
        expect(massGrams.unit, MassUnit.gram); // Original should be unchanged
        expect(massGrams.value, 1500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final m1 = 10.0.kg;
        final m2 = m1.convertTo(MassUnit.kilogram);
        expect(identical(m1, m2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final m1Kg = 1.0.kg;
      final m1000g = 1000.0.g;
      final m999g = 999.0.g;
      final m2lb = 2.0.lb; // approx 0.907 kg
      final m3lb = 3.0.lb; // approx 1.360 kg

      test('should correctly compare masses of different units', () {
        expect(m1Kg.compareTo(m999g), greaterThan(0)); // 1kg > 999g
        expect(m999g.compareTo(m1Kg), lessThan(0)); // 999g < 1kg
        expect(m1Kg.compareTo(m1000g), 0); // 1kg == 1000g

        expect(m1Kg.compareTo(m2lb), greaterThan(0)); // 1kg > 2lb
        expect(m1Kg.compareTo(m3lb), lessThan(0)); // 1kg < 3lb
      });

      test('should return 0 for equal masses in different units', () {
        final mInLbs = (1.0 / 0.45359237).pounds; // 1 kg in pounds
        expect(m1Kg.compareTo(mInLbs), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const m1 = Mass(10.0, MassUnit.kilogram);
        const m2 = Mass(10.0, MassUnit.kilogram);
        expect(m1 == m2, isTrue);
        expect(m1.hashCode == m2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const m1 = Mass(10.0, MassUnit.kilogram);
        const m2Diffval = Mass(10.1, MassUnit.kilogram);
        const m3Diffunit = Mass(10.0, MassUnit.gram);
        const m4Diffvalandunit = Mass(1.0, MassUnit.pound);

        expect(m1 == m2Diffval, isFalse);
        expect(m1 == m3Diffunit, isFalse);
        expect(m1 == m4Diffvalandunit, isFalse);

        expect(m1.hashCode == m2Diffval.hashCode, isFalse);
        // Hash collisions are possible but unlikely for these simple diffs
        expect(m1.hashCode == m3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.kg is not equal to 1000.g', () {
        // This confirms that `==` checks unit, not just magnitude.
        // For magnitude, `compareTo` is used.
        final oneKg = 1.kg;
        final thousandGrams = 1000.g;
        expect(oneKg == thousandGrams, isFalse);
        expect(oneKg.compareTo(thousandGrams), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(10.5.kg.toString(), '10.5\u00A0kg'); // \u00A0 is non-breaking space
        expect(500.grams.toString(), '500.0\u00A0g');
        expect(2.2.pounds.toString(), '2.2\u00A0lb');
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 123.456;

      // Test all units via Kilogram (the base for MassUnit)
      for (final unit in MassUnit.values) {
        test('Round trip ${unit.symbol} <-> kg', () {
          testRoundTrip(
            unit,
            MassUnit.kilogram,
            testValue,
            tol: (unit == MassUnit.kilogram) ? tolerance : highTolerance,
          );
        });
      }

      // Test some other common pairs
      test('Round trip g <-> mg', () {
        testRoundTrip(MassUnit.gram, MassUnit.milligram, testValue);
      });
      test('Round trip lb <-> oz', () {
        testRoundTrip(MassUnit.pound, MassUnit.ounce, testValue);
      });
      test('Round trip lb <-> st', () {
        testRoundTrip(
          MassUnit.pound,
          MassUnit.stone,
          28.0,
        ); // Test with a value that easily converts
      });
      test('Round trip kg <-> tonne', () {
        testRoundTrip(MassUnit.kilogram, MassUnit.tonne, 5000.0);
      });
      test('Round trip kg <-> slug', () {
        testRoundTrip(MassUnit.kilogram, MassUnit.slug, testValue);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final mZeroKg = 0.0.kg;
        for (final unit in MassUnit.values) {
          expect(mZeroKg.getValue(unit), 0.0, reason: '0 kg to ${unit.symbol} should be 0');
        }

        final mZeroLb = 0.0.lb;
        for (final unit in MassUnit.values) {
          expect(mZeroLb.getValue(unit), 0.0, reason: '0 lb to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with negative value (mass is typically positive, but math should work)', () {
        final mNegativeKg = (-10.0).kg;
        expect(mNegativeKg.inGrams, closeTo(-10000.0, tolerance));
        expect(mNegativeKg.inPounds, closeTo(-10.0 / 0.45359237, highTolerance));
      });
    });

    group('Arithmetic Operators for Mass', () {
      final m1kg = 1.0.kg;
      final m2kg = 2.0.kg;
      final m500g = 500.g; // 0.5 kg
      final m1lb = 1.lb; // 0.45359237 kg

      // Operator +
      test('operator + combines masses, result in unit of left operand', () {
        final sum1 = m2kg + m1kg;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, MassUnit.kilogram);

        final sum2 = m1kg + m500g; // 1kg + 0.5kg = 1.5kg
        expect(sum2.value, closeTo(1.5, tolerance));
        expect(sum2.unit, MassUnit.kilogram);

        final sum3 = m500g + m1kg; // 500g + 1000g = 1500g
        expect(sum3.value, closeTo(1500.0, tolerance));
        expect(sum3.unit, MassUnit.gram);

        final sum4 = m1kg + m1lb; // 1kg + 0.45359237kg
        expect(sum4.value, closeTo(1.0 + 0.45359237, highTolerance));
        expect(sum4.unit, MassUnit.kilogram);
      });

      // Operator -
      test('operator - subtracts masses, result in unit of left operand', () {
        final diff1 = m2kg - m1kg;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, MassUnit.kilogram);

        final diff2 = m1kg - m500g; // 1kg - 0.5kg = 0.5kg
        expect(diff2.value, closeTo(0.5, tolerance));
        expect(diff2.unit, MassUnit.kilogram);

        final diff3 = m1kg - m1lb; // 1kg - 0.45359237kg
        expect(diff3.value, closeTo(1.0 - 0.45359237, highTolerance));
        expect(diff3.unit, MassUnit.kilogram);
      });

      // Operator * (scalar)
      test('operator * scales mass by a scalar', () {
        final scaled1 = m2kg * 3.5;
        expect(scaled1.value, closeTo(7.0, tolerance));
        expect(scaled1.unit, MassUnit.kilogram);

        final scaled2 = m500g * 0.5;
        expect(scaled2.value, closeTo(250.0, tolerance));
        expect(scaled2.unit, MassUnit.gram);
      });

      // Operator / (scalar)
      test('operator / scales mass by a scalar', () {
        final scaled1 = m2kg / 4.0;
        expect(scaled1.value, closeTo(0.5, tolerance));
        expect(scaled1.unit, MassUnit.kilogram);

        final scaled2 = m1kg / 0.1;
        expect(scaled2.value, closeTo(10.0, tolerance));
        expect(scaled2.unit, MassUnit.kilogram);

        expect(() => m1kg / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialMass = 10.kg;
        final mAdd = initialMass + 500.g; // 10kg + 0.5kg = 10.5kg
        final mMul = mAdd * 2.0; // 10.5kg * 2 = 21kg
        final mSub = mMul - 1.lb; // 21kg - ~0.45kg

        expect(initialMass.value, 10.0); // Original unchanged
        expect(initialMass.unit, MassUnit.kilogram);

        expect(mAdd.value, closeTo(10.5, tolerance));
        expect(mAdd.unit, MassUnit.kilogram);

        expect(mMul.value, closeTo(21.0, tolerance));
        expect(mMul.unit, MassUnit.kilogram);

        final expectedMSubVal = 21.0 - 1.0.lb.getValue(MassUnit.kilogram);
        expect(mSub.value, closeTo(expectedMSubVal, highTolerance));
        expect(mSub.unit, MassUnit.kilogram);
      });
    });
  });

  group('Extended Mass Units', () {
    group('SI Prefix Units', () {
      test('hectogram conversions', () {
        final oneHectogram = 1.0.hg;
        expect(oneHectogram.inKilograms, closeTo(0.1, highPrecisiontolerance));
        expect(oneHectogram.inGrams, closeTo(100.0, highPrecisiontolerance));
        expect(oneHectogram.inDecagrams, closeTo(10.0, highPrecisiontolerance));
      });

      test('decagram conversions', () {
        final oneDecagram = 1.0.dag;
        expect(oneDecagram.inKilograms, closeTo(0.01, highPrecisiontolerance));
        expect(oneDecagram.inGrams, closeTo(10.0, highPrecisiontolerance));
        expect(oneDecagram.inHectograms, closeTo(0.1, highPrecisiontolerance));
      });

      test('decigram conversions', () {
        final oneDecigram = 1.0.dg;
        expect(oneDecigram.inGrams, closeTo(0.1, highPrecisiontolerance));
        expect(oneDecigram.inCentigrams, closeTo(10.0, highPrecisiontolerance));
        expect(oneDecigram.inMilligrams, closeTo(100.0, highPrecisiontolerance));
      });

      test('centigram conversions', () {
        final oneCentigram = 1.0.cg;
        expect(oneCentigram.inGrams, closeTo(0.01, highPrecisiontolerance));
        expect(oneCentigram.inDecigrams, closeTo(0.1, highPrecisiontolerance));
        expect(oneCentigram.inMilligrams, closeTo(10.0, highPrecisiontolerance));
      });

      test('microgram conversions', () {
        final oneMicrogram = 1.0.ug;
        expect(oneMicrogram.inGrams, closeTo(1e-6, highPrecisiontolerance));
        expect(oneMicrogram.inMilligrams, closeTo(0.001, highPrecisiontolerance));
        expect(oneMicrogram.inNanograms, closeTo(1000.0, highPrecisiontolerance));
      });

      test('nanogram conversions', () {
        final oneNanogram = 1.0.ng;
        expect(oneNanogram.inGrams, closeTo(1e-9, highPrecisiontolerance));
        expect(oneNanogram.inMicrograms, closeTo(0.001, highPrecisiontolerance));
        expect(oneNanogram.inKilograms, closeTo(1e-12, highPrecisiontolerance));
      });
    });

    group('Imperial Ton Units', () {
      test('short ton (US) conversions', () {
        final oneShortTon = 1.0.shortTons;
        expect(oneShortTon.inPounds, closeTo(2000.0, highPrecisiontolerance));
        expect(oneShortTon.inKilograms, closeTo(907.18474, tolerance));
        expect(oneShortTon.inTonnes, closeTo(0.90718474, tolerance));
      });

      test('long ton (UK) conversions', () {
        final oneLongTon = 1.0.longTons;
        expect(oneLongTon.inPounds, closeTo(2240.0, highPrecisiontolerance));
        expect(oneLongTon.inKilograms, closeTo(1016.0469088, tolerance));
        expect(oneLongTon.inTonnes, closeTo(1.0160469088, tolerance));
      });

      test('ton comparisons', () {
        final shortTon = 1.0.shortTons;
        final longTon = 1.0.longTons;
        final metricTon = 1.0.tonnes;

        // Long ton > Metric ton > Short ton
        expect(longTon.compareTo(metricTon), greaterThan(0));
        expect(metricTon.compareTo(shortTon), greaterThan(0));
        expect(longTon.compareTo(shortTon), greaterThan(0));
      });
    });

    group('Special Units', () {
      test('atomic mass unit conversions', () {
        final oneAMU = 1.0.u;
        expect(oneAMU.inKilograms, closeTo(1.66053906660e-27, atomicTolerance));
        expect(oneAMU.inGrams, closeTo(1.66053906660e-24, atomicTolerance));

        // Carbon-12 has exactly 12 u
        final carbon12 = 12.0.u;
        expect(carbon12.inKilograms, closeTo(12.0 * 1.66053906660e-27, atomicTolerance));

        // Test Avogadro's number relationship
        // 1 mole of carbon-12 = 12 g = 12 u × N_A
        const avogadroNumber = 6.02214076e23;
        const oneMoleCarbon12InKg = 0.012; // 12 g
        final oneAtomCarbon12InKg = carbon12.inKilograms;
        final calculatedAvogadro = oneMoleCarbon12InKg / oneAtomCarbon12InKg;
        expect(calculatedAvogadro, closeTo(avogadroNumber, avogadroNumber * 1e-6));
      });

      test('carat conversions', () {
        final oneCarat = 1.0.ct;
        expect(oneCarat.inGrams, closeTo(0.2, highPrecisiontolerance));
        expect(oneCarat.inKilograms, closeTo(0.0002, highPrecisiontolerance));
        expect(oneCarat.inMilligrams, closeTo(200.0, highPrecisiontolerance));

        // Typical diamond weights
        final halfCarat = 0.5.ct;
        final twoCarats = 2.0.ct;
        expect(halfCarat.inGrams, closeTo(0.1, highPrecisiontolerance));
        expect(twoCarats.inGrams, closeTo(0.4, highPrecisiontolerance));
      });

      test('atomic scale examples', () {
        // Hydrogen atom mass ≈ 1.008 u
        final hydrogenMass = 1.008.u;
        const expectedHydrogenInKg = 1.008 * MassFactors.kilogramsPerAtomicMassUnit;
        expect(hydrogenMass.inKilograms, closeTo(expectedHydrogenInKg, 1e-30));

        // Electron mass ≈ 0.000549 u
        final electronMassInU = 0.000549.u;
        const expectedElectronInKg = 0.000549 * MassFactors.kilogramsPerAtomicMassUnit;
        // Test the conversion, not the standard value of electron mass in kg
        expect(electronMassInU.inKilograms, closeTo(expectedElectronInKg, 1e-34));

        // Compare electron to proton (≈ 1.007 u)
        final protonMass = 1.007.u;
        expect(protonMass.compareTo(electronMassInU), greaterThan(0));
      });

      group('Practical measurement examples', () {
        test('pharmaceutical dosages', () {
          // Common drug dosages are in milligrams
          final aspirinTablet = 325.mg;
          final vitaminC = 1000.mg;

          expect(aspirinTablet.inGrams, closeTo(0.325, highPrecisiontolerance));
          expect(vitaminC.inGrams, closeTo(1.0, highPrecisiontolerance));

          // Microgram dosages for potent drugs
          final folicAcid = 400.ug;
          expect(folicAcid.inMilligrams, closeTo(0.4, highPrecisiontolerance));
        });

        test('jewelry and precious materials', () {
          // Gold jewelry - typical weights
          final goldRing = 3.5.g;
          final goldNecklace = 15.2.g;

          expect(goldRing.inOunces, closeTo(0.1235, 1e-4));
          expect(goldNecklace.inOunces, closeTo(0.53616, 1e-4));

          // Diamond weights in carats
          final engagementRing = 1.5.ct;
          final earrings = 0.75.ct; // Total for both

          expect(engagementRing.inGrams, closeTo(0.3, highPrecisiontolerance));
          expect(earrings.inGrams, closeTo(0.15, highPrecisiontolerance));
        });

        test('shipping and cargo', () {
          // Freight shipping weights
          final containerLimit = 30.tonnes;
          final truckLoad = 40000.pounds;

          expect(containerLimit.inKilograms, closeTo(30000.0, highPrecisiontolerance));
          expect(truckLoad.inTonnes, closeTo(18.1436948, tolerance));

          // Compare different ton types for cargo
          final usShipping = 20.shortTons;
          final ukShipping = 20.longTons;
          final metricShipping = 20.tonnes;

          expect(ukShipping.compareTo(metricShipping), greaterThan(0));
          expect(metricShipping.compareTo(usShipping), greaterThan(0));
        });
      });

      group('Round trip conversions for new units', () {
        const testValue = 567.89;

        test('SI prefix round trips', () {
          final units = [
            MassUnit.hectogram,
            MassUnit.decagram,
            MassUnit.decigram,
            MassUnit.centigram,
            MassUnit.microgram,
            MassUnit.nanogram,
          ];

          for (final unit in units) {
            final original = Mass(testValue, unit);
            final converted = original.convertTo(MassUnit.kilogram).convertTo(unit);
            expect(
              converted.value,
              closeTo(testValue, tolerance),
              reason: 'Round trip failed for ${unit.symbol}',
            );
          }
        });

        test('special unit round trips', () {
          // Test atomic mass unit with smaller value due to extreme scale
          const amuOriginal = Mass(12.011, MassUnit.atomicMassUnit); // Carbon average
          final amuConverted =
              amuOriginal.convertTo(MassUnit.kilogram).convertTo(MassUnit.atomicMassUnit);
          expect(amuConverted.value, closeTo(12.011, tolerance));

          // Test carat
          const caratOriginal = Mass(testValue, MassUnit.carat);
          final caratConverted =
              caratOriginal.convertTo(MassUnit.kilogram).convertTo(MassUnit.carat);
          expect(caratConverted.value, closeTo(testValue, highPrecisiontolerance));

          // Test tons
          const shortTonOriginal = Mass(testValue, MassUnit.shortTon);
          final shortTonConverted =
              shortTonOriginal.convertTo(MassUnit.kilogram).convertTo(MassUnit.shortTon);
          expect(shortTonConverted.value, closeTo(testValue, tolerance));
        });
      });

      group('toString formatting for new units', () {
        test('should display correct symbols', () {
          expect(1.0.hg.toString(), '1.0\u00A0hg');
          expect(1.0.dag.toString(), '1.0\u00A0dag');
          expect(1.0.dg.toString(), '1.0\u00A0dg');
          expect(1.0.cg.toString(), '1.0\u00A0cg');
          expect(1.0.ug.toString(), '1.0\u00A0μg');
          expect(1.0.ng.toString(), '1.0\u00A0ng');
          expect(1.0.shortTons.toString(), '1.0\u00A0short ton');
          expect(1.0.longTons.toString(), '1.0\u00A0long ton');
          expect(1.0.u.toString(), '1.0\u00A0u');
          expect(1.0.ct.toString(), '1.0\u00A0ct');
        });
      });

      group('Mixed unit arithmetic', () {
        test('adding very different scales', () {
          final bigMass = 1.0.tonnes;
          final smallMass = 1.0.mg;
          final combined = bigMass + smallMass;

          // Milligram should be negligible compared to tonne
          expect(combined.inTonnes, closeTo(1.0, highTolerance));
          expect(combined.unit, MassUnit.tonne);
        });

        test('precision in small scale arithmetic', () {
          final drug1 = 250.ug; // micrograms
          final drug2 = 750.ug;
          final totalDose = drug1 + drug2;

          expect(totalDose.inMicrograms, closeTo(1000.0, highPrecisiontolerance));
          expect(totalDose.inMilligrams, closeTo(1.0, highPrecisiontolerance));
        });

        test('atomic mass arithmetic', () {
          // Water molecule: 2 H + 1 O
          final hydrogen = 1.008.u;
          final oxygen = 15.999.u;
          final waterMass = (hydrogen * 2) + oxygen;

          expect(waterMass.inAtomicMassUnits, closeTo(18.015, highPrecisiontolerance));
        });
      });
    });

    group('Mega and Giga Units', () {
      const tolerance = 1e-9;

      test('megagram conversions and equivalence with tonne', () {
        // Use the new explicit extension `megaG`
        final oneMegagram = 1.0.megaG;
        expect(oneMegagram.inKilograms, closeTo(1000.0, tolerance));
        expect(oneMegagram.inGrams, closeTo(1e6, tolerance));

        // Megagram should be equivalent to tonne
        final oneTonne = 1.0.t;
        expect(oneMegagram.compareTo(oneTonne), 0);
        expect(oneMegagram.inTonnes, closeTo(1.0, tolerance));
      });

      test('gigagram conversions', () {
        // Use the new explicit extension `gigaG`
        final oneGigagram = 1.0.gigaG;
        expect(oneGigagram.inKilograms, closeTo(1e6, tolerance));
        // Use the new explicit getter `inMegaG`
        expect(oneGigagram.inMegaG, closeTo(1000.0, tolerance));
        expect(oneGigagram.inTonnes, closeTo(1000.0, tolerance));
      });

      test('large scale mass examples', () {
        // Mass of a large bridge might be in gigagrams
        final bridgeMass = 50.0.gigaG; // 50,000 tonnes
        expect(bridgeMass.inTonnes, closeTo(50000.0, tolerance));

        // Compare with a space shuttle mass (~2 Gg)
        final shuttleMass = 2.0.gigaG;
        expect(bridgeMass.compareTo(shuttleMass), greaterThan(0));
      });

      test('round trip conversions for mega and giga', () {
        const testValue = 123.456;
        // Test round trip via kilograms
        final originalMega = testValue.megaG;
        final roundTripMega = originalMega.asKilograms.asMegaG;
        expect(roundTripMega.value, closeTo(testValue, tolerance));

        final originalGiga = testValue.gigaG;
        final roundTripGiga = originalGiga.asKilograms.asGigaG;
        expect(roundTripGiga.value, closeTo(testValue, tolerance));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/mass_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/molar_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming MolarAmount and MolarUnit are exported
import 'package:test/test.dart';

void main() {
  group('MolarAmount', () {
    const tolerance = 1e-12; // Molar amounts can be very small, requiring higher precision
    const defaultTolerance = 1e-9; // For general comparisons

    // Helper for round trip tests
    void testRoundTrip(
      MolarUnit initialUnit,
      MolarUnit intermediateUnit,
      double initialValue, {
      double tol = tolerance, // Default to higher precision for molar round trips
    }) {
      final ma1 = MolarAmount(initialValue, initialUnit);
      final ma2 = ma1.convertTo(intermediateUnit);
      final ma3 = ma2.convertTo(initialUnit);
      expect(
        ma3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${ma3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create MolarAmount from num extensions and retrieve values correctly', () {
        final maMol = 0.5.mol;
        expect(maMol.value, 0.5);
        expect(maMol.unit, MolarUnit.mole);
        expect(maMol.inMillimoles, closeTo(500.0, tolerance));
        expect(maMol.asMillimoles.value, closeTo(500.0, tolerance));
        expect(maMol.asMillimoles.unit, MolarUnit.millimole);

        final maMmol = 2500.0.millimoles; // Using alias
        expect(maMmol.value, 2500.0);
        expect(maMmol.unit, MolarUnit.millimole);
        expect(maMmol.inMoles, closeTo(2.5, tolerance));

        final maUmol = 1234.0.umol;
        expect(maUmol.value, 1234.0);
        expect(maUmol.unit, MolarUnit.micromole);
        expect(maUmol.inMoles, closeTo(0.001234, tolerance));
        expect(maUmol.inNanomoles, closeTo(1234000.0, 1e-9));
      });

      test('getValue should return correct value for same unit', () {
        const molarAmount = MolarAmount(0.025, MolarUnit.mole);
        expect(molarAmount.getValue(MolarUnit.mole), 0.025);
      });
    });

    group('Conversions between various molar units', () {
      final oneMole = 1.0.mol;
      test('1 Mole to other units', () {
        expect(oneMole.inKilomoles, closeTo(0.001, tolerance));
        expect(oneMole.inMillimoles, closeTo(1000.0, tolerance));
        expect(oneMole.inMicromoles, closeTo(1000000.0, tolerance));
        expect(oneMole.inNanomoles, closeTo(1.0e9, 1e-6));
        expect(oneMole.inPicomoles, closeTo(1.0e12, tolerance));
      });

      final oneKiloMole = 1.0.kmol;
      test('1 Kilomole to moles', () {
        expect(oneKiloMole.inMoles, closeTo(1000.0, tolerance));
      });

      final oneMilliMole = 1.0.mmol;
      test('1 Millimole to micromoles and moles', () {
        expect(oneMilliMole.inMicromoles, closeTo(1000.0, tolerance));
        expect(oneMilliMole.inMoles, closeTo(0.001, tolerance));
      });

      final oneNanoMole = 123.0.nmol;
      test('123 Nanomoles to picomoles and micromoles', () {
        expect(oneNanoMole.inPicomoles, closeTo(123000.0, 1e-10));
        expect(oneNanoMole.inMicromoles, closeTo(0.123, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new MolarAmount object with converted value and unit', () {
        final maMmol = 1500.0.mmol;
        final maMol = maMmol.convertTo(MolarUnit.mole);

        expect(maMol.unit, MolarUnit.mole);
        expect(maMol.value, closeTo(1.5, tolerance));
        expect(maMmol.unit, MolarUnit.millimole); // Original should be unchanged
        expect(maMmol.value, 1500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final ma1 = 0.1.mol;
        final ma2 = ma1.convertTo(MolarUnit.mole);
        expect(identical(ma1, ma2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final ma1Mol = 1.0.mol;
      final ma1000Mmol = 1000.0.mmol;
      final ma999Mmol = 999.0.mmol;
      final ma0_1Kmol = 0.1.kmol; // 100 mol
      final ma0_0001Kmol = 0.0001.kmol; // 0.1 mol

      test('should correctly compare molar amounts of different units', () {
        expect(ma1Mol.compareTo(ma999Mmol), greaterThan(0)); // 1mol > 999mmol
        expect(ma999Mmol.compareTo(ma1Mol), lessThan(0)); // 999mmol < 1mol
        expect(ma1Mol.compareTo(ma1000Mmol), 0); // 1mol == 1000mmol

        expect(ma1Mol.compareTo(ma0_1Kmol), lessThan(0)); // 1mol < 100mol
        expect(ma1Mol.compareTo(ma0_0001Kmol), greaterThan(0)); // 1mol > 0.1mol
      });

      test('should return 0 for equal molar amounts in different units', () {
        final maInUmol = 1000000.0.umol; // 1 mol in micromoles
        expect(ma1Mol.compareTo(maInUmol), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const ma1 = MolarAmount(0.05, MolarUnit.mole);
        const ma2 = MolarAmount(0.05, MolarUnit.mole);
        expect(ma1 == ma2, isTrue);
        expect(ma1.hashCode == ma2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const ma1 = MolarAmount(0.05, MolarUnit.mole);
        const ma2Diffval = MolarAmount(0.051, MolarUnit.mole);
        const ma3Diffunit = MolarAmount(0.05, MolarUnit.millimole);
        const ma4Diffvalandunit = MolarAmount(1.0, MolarUnit.kilomole);

        expect(ma1 == ma2Diffval, isFalse);
        expect(ma1 == ma3Diffunit, isFalse);
        expect(ma1 == ma4Diffvalandunit, isFalse);

        expect(ma1.hashCode == ma2Diffval.hashCode, isFalse);
        expect(ma1.hashCode == ma3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.mol is not equal to 1000.mmol', () {
        final oneMol = 1.mol;
        final thousandMmol = 1000.mmol;
        expect(oneMol == thousandMmol, isFalse);
        expect(oneMol.compareTo(thousandMmol), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(0.25.mol.toString(), '0.25\u00A0mol');
        expect(123.micromoles.toString(), '123.0\u00A0µmol'); // Note µ symbol
        expect(
          1.5e-9.nmol.toString(),
          '1.5e-9\u00A0nmol',
        ); // Scientific notation from double.toString()
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 0.0123456789;

      // Test all units via Mole (the base for MolarUnit)
      for (final unit in MolarUnit.values) {
        test('Round trip ${unit.symbol} <-> mol', () {
          testRoundTrip(
            unit,
            MolarUnit.mole,
            testValue,
            tol: (unit == MolarUnit.mole) ? tolerance : tolerance, // Use high precision always
          );
        });
      }

      // Test some other common pairs
      test('Round trip mmol <-> µmol', () {
        testRoundTrip(MolarUnit.millimole, MolarUnit.micromole, 0.5);
      });
      test('Round trip nmol <-> pmol', () {
        testRoundTrip(MolarUnit.nanomole, MolarUnit.picomole, 0.005);
      });
      test('Round trip mol <-> kmol', () {
        testRoundTrip(MolarUnit.mole, MolarUnit.kilomole, 2500.0);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final maZeroMol = 0.0.mol;
        for (final unit in MolarUnit.values) {
          expect(maZeroMol.getValue(unit), 0.0, reason: '0 mol to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with very small and large values', () {
        final verySmall = 1.0e-15.mol; // femtomoles range
        expect(verySmall.inPicomoles, closeTo(0.001, tolerance));

        final veryLarge = 1.0e6.mol; // megamoles range
        expect(veryLarge.inKilomoles, closeTo(1000.0, tolerance));
      });
    });

    group('Arithmetic Operators for MolarAmount', () {
      final ma1mol = 1.0.mol;
      final ma2mol = 2.0.mol;
      final ma500mmol = 500.mmol; // 0.5 mol
      final ma100umol = 100.umol; // 0.0001 mol

      // Operator +
      test('operator + combines molar amounts, result in unit of left operand', () {
        final sum1 = ma2mol + ma1mol;
        expect(sum1.value, closeTo(3.0, defaultTolerance));
        expect(sum1.unit, MolarUnit.mole);

        final sum2 = ma1mol + ma500mmol; // 1mol + 0.5mol = 1.5mol
        expect(sum2.value, closeTo(1.5, defaultTolerance));
        expect(sum2.unit, MolarUnit.mole);

        final sum3 = ma500mmol + ma1mol; // 500mmol + 1000mmol = 1500mmol
        expect(sum3.value, closeTo(1500.0, defaultTolerance));
        expect(sum3.unit, MolarUnit.millimole);

        final sum4 = ma1mol + ma100umol; // 1mol + 0.0001mol
        expect(sum4.value, closeTo(1.0 + 0.0001, tolerance));
        expect(sum4.unit, MolarUnit.mole);
      });

      // Operator -
      test('operator - subtracts molar amounts, result in unit of left operand', () {
        final diff1 = ma2mol - ma1mol;
        expect(diff1.value, closeTo(1.0, defaultTolerance));
        expect(diff1.unit, MolarUnit.mole);

        final diff2 = ma1mol - ma500mmol; // 1mol - 0.5mol = 0.5mol
        expect(diff2.value, closeTo(0.5, defaultTolerance));
        expect(diff2.unit, MolarUnit.mole);

        final diff3 = ma1mol - ma100umol; // 1mol - 0.0001mol
        expect(diff3.value, closeTo(1.0 - 0.0001, tolerance));
        expect(diff3.unit, MolarUnit.mole);
      });

      // Operator * (scalar)
      test('operator * scales molar amount by a scalar', () {
        final scaled1 = ma2mol * 3.5;
        expect(scaled1.value, closeTo(7.0, defaultTolerance));
        expect(scaled1.unit, MolarUnit.mole);

        final scaled2 = ma500mmol * 0.1;
        expect(scaled2.value, closeTo(50.0, defaultTolerance));
        expect(scaled2.unit, MolarUnit.millimole);
      });

      // Operator / (scalar)
      test('operator / scales molar amount by a scalar', () {
        final scaled1 = ma2mol / 4.0;
        expect(scaled1.value, closeTo(0.5, defaultTolerance));
        expect(scaled1.unit, MolarUnit.mole);

        final scaled2 = ma1mol / 0.01;
        expect(scaled2.value, closeTo(100.0, defaultTolerance));
        expect(scaled2.unit, MolarUnit.mole);

        expect(() => ma1mol / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialAmount = 0.1.mol;
        final maAdd = initialAmount + 50.mmol; // 0.1mol + 0.05mol = 0.15mol
        final maMul = maAdd * 10.0; // 0.15mol * 10 = 1.5mol
        final maSub = maMul - 100000.umol; // 1.5mol - 0.1mol = 1.4mol

        expect(initialAmount.value, 0.1); // Original unchanged
        expect(initialAmount.unit, MolarUnit.mole);

        expect(maAdd.value, closeTo(0.15, tolerance));
        expect(maAdd.unit, MolarUnit.mole);

        expect(maMul.value, closeTo(1.5, tolerance));
        expect(maMul.unit, MolarUnit.mole);

        final expectedMaSubVal = 1.5 - 100000.0.umol.getValue(MolarUnit.mole);
        expect(maSub.value, closeTo(expectedMaSubVal, tolerance));
        expect(maSub.unit, MolarUnit.mole);
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/molar_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/power_test.dart -->
// test/units/power_test.dart

import 'package:quantify/power.dart';
import 'package:test/test.dart';

void main() {
  group('Power', () {
    const strictTolerance = 1e-12;
    const defaultTolerance = 1e-9;

    // Helper for round trip tests
    void testRoundTrip(
      PowerUnit initialUnit,
      PowerUnit intermediateUnit,
      double initialValue, {
      double tol = defaultTolerance,
    }) {
      final p1 = Power(initialValue, initialUnit);
      final p2 = p1.convertTo(intermediateUnit);
      final p3 = p2.convertTo(initialUnit);
      expect(
        p3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Power from num extensions and retrieve values', () {
        final p1 = 150.0.kW;
        expect(p1.value, 150.0);
        expect(p1.unit, PowerUnit.kilowatt);
        expect(p1.inWatts, closeTo(150000.0, strictTolerance));
        expect(p1.inMegawatts, closeTo(0.15, strictTolerance));
      });

      test('should create from all new units', () {
        final pMw = 500.mW;
        expect(pMw.inWatts, closeTo(0.5, strictTolerance));

        final pGw = 1.2.gigaW;
        expect(pGw.inMegawatts, closeTo(1200.0, strictTolerance));

        final pMetricHp = 100.0.metricHp;
        expect(pMetricHp.inWatts, closeTo(73549.875, defaultTolerance));

        final pBtu = 1000.0.btuPerHour;
        expect(pBtu.inWatts, closeTo(293.071, 1e-3));

        final pErg = 1e7.ergPerSecond; // Should be 1 Watt
        expect(pErg.inWatts, closeTo(1.0, defaultTolerance));
      });
    });

    group('Conversions', () {
      test('Horsepower (hp) vs Metric Horsepower (PS)', () {
        final mechHp = 1.0.hp;
        final metricHp = 1.0.metricHp;

        // Mechanical hp should be slightly more powerful than metric hp
        expect(mechHp.compareTo(metricHp), greaterThan(0));
        expect(mechHp.inWatts, closeTo(745.7, 1e-1));
        expect(metricHp.inWatts, closeTo(735.5, 1e-1));
      });

      test('Kilowatt to Horsepower and BTU/h', () {
        final oneKw = 1.0.kW;
        expect(oneKw.inHorsepower, closeTo(1.341, 1e-3));
        expect(oneKw.inMetricHorsepower, closeTo(1.360, 1e-3));
        expect(oneKw.inBtuPerHour, closeTo(3412.14, 1e-2));
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final p1 = 100.kW;
        final p2 = 0.1.megaW;
        final p3 = 134.hp; // approx 99.9 kW

        expect(p1.compareTo(p2), 0);
        expect(p1.compareTo(p3), greaterThan(0));
        expect(p3.compareTo(p1), lessThan(0));
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction correctly', () {
        final sum = 1.kW + 500.W; // 1000 W + 500 W = 1500 W
        expect(sum.inKilowatts, closeTo(1.5, defaultTolerance));
        expect(sum.unit, PowerUnit.kilowatt);
      });

      test('should perform scalar multiplication and division', () {
        final power = 20.hp;
        expect((power * 3.0).inHorsepower, closeTo(60.0, defaultTolerance));
        expect((power / 2.0).inHorsepower, closeTo(10.0, defaultTolerance));
        expect(() => power / 0, throwsArgumentError);
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in PowerUnit.values) {
        test('Round trip ${unit.symbol} <-> W', () {
          testRoundTrip(unit, PowerUnit.watt, 123.456);
        });
      }
    });

    group('Practical Examples', () {
      test('Car Engine Power', () {
        // A car engine is rated at 250 PS.
        final enginePower = 250.0.metricHp;
        // Check its equivalent in mechanical horsepower and kilowatts.
        expect(enginePower.inHorsepower, closeTo(246.6, 1e-1));
        expect(enginePower.inKilowatts, closeTo(183.9, 1e-1));
      });

      test('HVAC System', () {
        // A home AC unit has a cooling capacity of 12,000 Btu/h.
        final acPower = 12000.0.btuPerHour;
        // Check its power consumption in kilowatts.
        expect(acPower.inKilowatts, closeTo(3.516, 1e-3));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/power_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/pressure_test.dart -->
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons

  group('Pressure', () {
    // Helper for round trip tests
    void testRoundTrip(
      PressureUnit initialUnit,
      PressureUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final p1 = Pressure(initialValue, initialUnit);
      final p2 = p1.convertTo(intermediateUnit);
      final p3 = p2.convertTo(initialUnit);
      expect(
        p3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Pressure from num extensions and retrieve values', () {
        final p1 = 101325.0.pa;
        expect(p1.value, 101325.0);
        expect(p1.unit, PressureUnit.pascal);
        expect(p1.inAtm, closeTo(1.0, 1e-9));

        final p2 = 1.0.atm;
        expect(p2.value, 1.0);
        expect(p2.unit, PressureUnit.atmosphere);
        expect(p2.inPa, closeTo(101325.0, 1e-9));

        final p3 = 30.0.psi;
        expect(p3.inPsi, 30.0);
        expect(p3.unit, PressureUnit.psi);

        final p4 = 1000.mbar; // millibars
        expect(p4.inMbar, 1000.0);
        expect(p4.inHPa, closeTo(1000.0, 1e-9)); // mbar and hPa are often same scale
        expect(p4.inBar, closeTo(1.0, 1e-9));
      });

      test('getValue should return correct value for same unit', () {
        const p = Pressure(15, PressureUnit.psi);
        expect(p.getValue(PressureUnit.psi), 15.0);
      });

      test('getValue for all units from Pascal base', () {
        final p = 100000.0.pa; // 1 bar
        expect(p.inPa, 100000.0);
        expect(p.inAtm, closeTo(100000.0 / 101325.0, 1e-7));
        expect(p.inBar, closeTo(1.0, 1e-9));
        expect(p.inPsi, closeTo(100000.0 / 6894.757293168361, 1e-7));
        expect(p.inTorr, closeTo(100000.0 / (101325.0 / 760.0), 1e-7));
        expect(p.inMmHg, closeTo(100000.0 / (101325.0 / 760.0), 1e-7));
        expect(
          p.inInHg,
          closeTo(
            100000.0 / ((101325.0 / 760.0) * 25.4),
            1e-6,
          ),
        ); // Higher tolerance due to more factors
        expect(p.inKPa, closeTo(100.0, 1e-9));
        expect(p.inHPa, closeTo(1000.0, 1e-9));
        expect(p.inMbar, closeTo(1000.0, 1e-9));
        expect(p.inCmH2O, closeTo(100000.0 / 98.0665, 1e-7));
        expect(p.inInH2O, closeTo(100000.0 / 249.08891, 1e-7));
      });
    });

    group('Conversions', () {
      final oneAtm = 1.0.atm;

      test('1 atm to Pascals', () {
        expect(oneAtm.inPa, closeTo(101325.0, 1e-9));
      });
      test('1 atm to Bars', () {
        expect(oneAtm.inBar, closeTo(1.01325, 1e-9));
      });
      test('1 atm to PSI', () {
        expect(oneAtm.inPsi, closeTo(14.695948775513, 1e-7));
      });
      test('1 atm to Torr (mmHg)', () {
        expect(oneAtm.inTorr, closeTo(760.0, 1e-9));
        expect(oneAtm.inMmHg, closeTo(760.0, 1e-9));
      });
      test('1 atm to Inches of Mercury', () {
        expect(oneAtm.inInHg, closeTo(760.0 / 25.4, 1e-7));
      });
      test('1 atm to Kilopascals', () {
        expect(oneAtm.inKPa, closeTo(101.325, 1e-9));
      });
      test('1 atm to Hectopascals/Millibars', () {
        expect(oneAtm.inHPa, closeTo(1013.25, 1e-9));
        expect(oneAtm.inMbar, closeTo(1013.25, 1e-9));
      });
      test('1 atm to cmH2O', () {
        expect(oneAtm.inCmH2O, closeTo(101325.0 / 98.0665, 1e-7));
      });
      test('1 atm to inH2O', () {
        expect(oneAtm.inInH2O, closeTo(101325.0 / 249.08891, 1e-7));
      });

      // Test specific tricky conversions
      test('PSI to Bar', () {
        final pPsi = 29.0.psi; // Approx 1.99948 bar
        expect(pPsi.inBar, closeTo(29.0 * 6894.757293168361 / 100000.0, 1e-7));
      });

      test('Bar to PSI', () {
        final pBar = 2.0.bar; // Approx 29.0075 psi
        expect(pBar.inPsi, closeTo(2.0 * 100000.0 / 6894.757293168361, 1e-7));
      });

      test('inH2O to Pa', () {
        final pInH2O = 10.0.inH2O;
        expect(pInH2O.inPa, closeTo(10.0 * 249.08891, 1e-7));
      });
    });

    group('convertTo method', () {
      test('should return new Pressure object with converted value and unit', () {
        final pPsi = 29.0.psi;
        final pBar = pPsi.convertTo(PressureUnit.bar);
        expect(pBar.unit, PressureUnit.bar);
        expect(pBar.value, closeTo(pPsi.inBar, 1e-9));
        expect(pPsi.unit, PressureUnit.psi); // Original should be unchanged
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final p1 = 10.0.pa;
        final p2 = p1.convertTo(PressureUnit.pascal);
        expect(identical(p1, p2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final pBar = 1.0.bar; // 100000 Pa
      final pPsiSlightlyLess = 14.5.psi; // 14.5 * 6894.757... ≈ 99973.98 Pa
      final pPsiSlightlyMore = 14.6.psi; // 14.6 * 6894.757... ≈ 100663.4 Pa
      final pAtm = 1.0.atm; // 101325 Pa

      test('should correctly compare pressures of different units', () {
        expect(pBar.compareTo(pPsiSlightlyLess), greaterThan(0)); // 1 bar > 14.5 psi
        expect(pPsiSlightlyLess.compareTo(pBar), lessThan(0)); // 14.5 psi < 1 bar
        expect(pBar.compareTo(pPsiSlightlyMore), lessThan(0)); // 1 bar < 14.6 psi
        expect(pBar.compareTo(pAtm), lessThan(0)); // 1 bar < 1 atm
      });

      test('should return 0 for equal pressures in different units', () {
        final pPascals = 100000.0.pa;
        final pMillibars = 1000.0.mbar;
        expect(pBar.compareTo(pPascals), 0);
        expect(pPascals.compareTo(pBar), 0);
        expect(pBar.compareTo(pMillibars), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const p1 = Pressure(10, PressureUnit.bar);
        const p2 = Pressure(10, PressureUnit.bar);
        expect(p1 == p2, isTrue);
        expect(p1.hashCode == p2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const p1 = Pressure(10, PressureUnit.bar);
        const p2 = Pressure(10.1, PressureUnit.bar);
        const p3 = Pressure(10, PressureUnit.psi);
        expect(p1 == p2, isFalse);
        expect(p1 == p3, isFalse);
        expect(p1.hashCode == p2.hashCode, isFalse); // Likely false
        expect(p1.hashCode == p3.hashCode, isFalse); // Likely false
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(14.7.psi.toString(), '14.7 psi');
        expect(1013.25.mbar.toString(), '1013.25 mbar');
        expect(1.0.atm.toString(), '1.0 atm');
        expect(25.0.cmH2O.toString(), '25.0 cmH₂O');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 123.456;
      const highTolerance = 1e-6; // For chains of conversions

      // Test all units via Pascal
      for (final unit in PressureUnit.values) {
        test('Round trip ${unit.symbol} <-> Pa', () {
          testRoundTrip(
            unit,
            PressureUnit.pascal,
            testValue,
            tolerance: (unit == PressureUnit.pascal) ? 1e-9 : highTolerance,
          );
        });
      }

      // Test some other common pairs
      test('Round trip psi <-> bar', () {
        testRoundTrip(PressureUnit.psi, PressureUnit.bar, testValue, tolerance: highTolerance);
      });
      test('Round trip atm <-> mmHg', () {
        testRoundTrip(
          PressureUnit.atmosphere,
          PressureUnit.millimeterOfMercury,
          2.5,
          tolerance: highTolerance,
        );
      });
      test('Round trip kPa <-> psi', () {
        testRoundTrip(PressureUnit.kilopascal, PressureUnit.psi, 350, tolerance: highTolerance);
      });
      test('Round trip inH2O <-> cmH2O', () {
        testRoundTrip(
          PressureUnit.inchOfWater,
          PressureUnit.centimeterOfWater,
          10,
          tolerance: highTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final pZero = 0.0.pa;
        for (final unit in PressureUnit.values) {
          expect(pZero.getValue(unit), 0.0, reason: '0 Pa to ${unit.symbol} should be 0');
        }
        final pPsiZero = 0.0.psi;
        for (final unit in PressureUnit.values) {
          expect(pPsiZero.getValue(unit), 0.0, reason: '0 psi to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with negative value (if meaningful for pressure, though usually positive)',
          () {
        // Pressure is typically positive, but the math should still work.
        final pNegative = (-100.0).pa;
        expect(pNegative.inBar, closeTo(-0.001, 1e-9));
      });
    });

    group('Arithmetic Operators for Pressure', () {
      final p1Bar = 1.0.bar;
      final p2Bar = 2.0.bar;
      final p10Psi = 10.psi; // approx 0.689 bar

      // Operator +
      test('operator + combines pressures', () {
        final sum1 = p2Bar + p1Bar;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, PressureUnit.bar);

        final sum2 = p1Bar + p10Psi; // 1 bar + ~0.689 bar
        final expectedSum2Value = 1.0 + p10Psi.getValue(PressureUnit.bar);
        expect(sum2.value, closeTo(expectedSum2Value, tolerance));
        expect(sum2.unit, PressureUnit.bar);

        final sum3 = p10Psi + p1Bar; // 10 psi + (1 bar in psi)
        final expectedSum3Value = 10.0 + p1Bar.getValue(PressureUnit.psi);
        expect(sum3.value, closeTo(expectedSum3Value, tolerance));
        expect(sum3.unit, PressureUnit.psi);
      });

      // Operator -
      test('operator - subtracts pressures', () {
        final diff1 = p2Bar - p1Bar;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, PressureUnit.bar);

        final diff2 = p1Bar - p10Psi; // 1 bar - ~0.689 bar
        final expectedDiff2Value = 1.0 - p10Psi.getValue(PressureUnit.bar);
        expect(diff2.value, closeTo(expectedDiff2Value, tolerance));
        expect(diff2.unit, PressureUnit.bar);
      });

      // Operator * (scalar)
      test('operator * scales pressure by a scalar', () {
        final scaled = p2Bar * 1.5;
        expect(scaled.value, closeTo(3.0, tolerance));
        expect(scaled.unit, PressureUnit.bar);
      });

      // Operator / (scalar)
      test('operator / scales pressure by a scalar', () {
        final scaled = p2Bar / 4.0;
        expect(scaled.value, closeTo(0.5, tolerance));
        expect(scaled.unit, PressureUnit.bar);
        expect(() => p1Bar / 0.0, throwsArgumentError);
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/pressure_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/solid_angle_test.dart -->
import 'dart:math' as math;

import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('SolidAngle', () {
    const tolerance = 1e-12;

    // Helper for round trip tests
    void testRoundTrip(
      SolidAngleUnit initialUnit,
      SolidAngleUnit intermediateUnit,
      double initialValue, {
      double tol = tolerance,
    }) {
      final sa1 = SolidAngle(initialValue, initialUnit);
      final sa2 = sa1.convertTo(intermediateUnit);
      final sa3 = sa2.convertTo(initialUnit);
      expect(
        sa3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create from num extensions and retrieve values', () {
        final solidAngle = (2 * math.pi).sr;
        expect(solidAngle.value, 2 * math.pi);
        expect(solidAngle.unit, SolidAngleUnit.steradian);
        expect(solidAngle.inSpat, closeTo(0.5, tolerance));
      });
    });

    group('Conversions', () {
      test('Full sphere (spat) to other units', () {
        final fullSphere = 1.0.sp;
        expect(fullSphere.inSteradians, closeTo(4 * math.pi, tolerance));
        // Full sphere is approx 41252.96 deg²
        expect(fullSphere.inSquareDegrees, closeTo(41252.96, 1e-2));
      });

      test('Steradian to Square Degrees', () {
        final oneSteradian = 1.0.sr;
        // 1 sr = (180/π)² deg²
        expect(
          oneSteradian.inSquareDegrees,
          closeTo(math.pow(180 / math.pi, 2), tolerance),
        );
      });

      test('Square Degree to Steradians', () {
        final oneSqDeg = 1.0.deg2;
        expect(
          oneSqDeg.inSteradians,
          closeTo(math.pow(math.pi / 180, 2), tolerance),
        );
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final hemisphere = (2 * math.pi).sr; // ~6.283 sr (Half a sphere)
        final slightlyLess = 20000.deg2; // ~6.092 sr
        final slightlyMore = 21000.deg2; // ~6.397 sr

        // Test GREATER THAN
        expect(hemisphere.compareTo(slightlyLess), greaterThan(0));

        // Test LESS THAN
        expect(hemisphere.compareTo(slightlyMore), lessThan(0));

        // Test EQUAL
        expect(hemisphere.compareTo(const SolidAngle(2 * math.pi, SolidAngleUnit.steradian)), 0);
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction', () {
        final sum = math.pi.sr + 10000.deg2;
        final expected = math.pi + (10000 * math.pow(math.pi / 180, 2));
        expect(sum.inSteradians, closeTo(expected, tolerance));
        expect(sum.unit, SolidAngleUnit.steradian);
      });

      test('should perform scalar multiplication and division', () {
        final angle = math.pi.sr;
        expect((angle * 2.0).inSteradians, closeTo(2 * math.pi, tolerance));
        expect((angle / 4.0).inSteradians, closeTo(math.pi / 4, tolerance));
        expect(() => angle / 0, throwsArgumentError);
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in SolidAngleUnit.values) {
        test('Round trip ${unit.symbol} <-> sr', () {
          testRoundTrip(unit, SolidAngleUnit.steradian, 0.5);
        });
      }
    });

    group('Practical Examples', () {
      test('Field of view calculation', () {
        // A camera lens with a 90° x 90° field of view
        // We will approximate this as a cone with a 45° half-angle for this example.
        // The solid angle of a cone is Ω = 2π * (1 - cos(θ)), where θ is the half-angle.
        final halfAngle = 45.0.degrees.inRadians;
        final solidAngleCone = 2 * math.pi * (1 - math.cos(halfAngle));

        final fov = SolidAngle(solidAngleCone, SolidAngleUnit.steradian);

        // First, verify the steradian value is as expected (~1.84 sr)
        expect(fov.inSteradians, closeTo(1.8404, 1e-4));

        // Now, test the conversion of that calculated value to square degrees.
        // The previous expected value of 6048 was incorrect. The actual value is ~6041.356.
        expect(fov.inSquareDegrees, closeTo(6041.356, 1e-3));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/solid_angle_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/speed_test.dart -->
// test/units/speed_test.dart

import 'package:quantify/length.dart';
import 'package:quantify/speed.dart';
import 'package:quantify/time.dart';
import 'package:test/test.dart';

void main() {
  group('Speed', () {
    const tolerance = 1e-12;

    group('Constructors and Getters', () {
      test('should create from num extensions and retrieve values', () {
        final speed = 100.0.kmh;
        expect(speed.value, 100.0);
        expect(speed.unit, SpeedUnit.kilometerPerHour);
        // 100 km/h = 100 * 1000 / 3600 m/s
        expect(speed.inMps, closeTo(100 * 1000 / 3600, tolerance));
      });
    });

    group('Conversions', () {
      test('Meter per second to others', () {
        final speed = 10.0.mps; // 10 m/s
        expect(speed.inKmh, closeTo(36.0, tolerance));
        expect(speed.inMph, closeTo(22.3694, 1e-4));
        expect(speed.inKnots, closeTo(19.4384, 1e-4));
        expect(speed.inFeetPerSecond, closeTo(32.8084, 1e-4));
      });

      test('Kilometer per hour to others', () {
        final speed = 36.0.kmh;
        expect(speed.inMps, closeTo(10.0, tolerance));
      });

      test('Knot to m/s', () {
        final speed = 1.0.knots;
        expect(speed.inMps, closeTo(1852.0 / 3600.0, tolerance));
      });
    });

    group('Comparison', () {
      test('should correctly compare different units', () {
        final s1 = 10.0.mps; // 36 km/h
        final s2 = 36.0.kmh;
        final s3 = 35.0.kmh;

        expect(s1.compareTo(s2), 0);
        expect(s1.compareTo(s3), greaterThan(0));
        expect(s3.compareTo(s1), lessThan(0));
      });
    });

    group('Arithmetic', () {
      test('should perform addition and subtraction', () {
        final sum = 10.mps + 18.kmh; // 10 m/s + 5 m/s = 15 m/s
        expect(sum.inMps, closeTo(15.0, tolerance));
        expect(sum.unit, SpeedUnit.meterPerSecond);
      });

      test('should perform scalar multiplication and division', () {
        final speed = 50.0.kmh;
        expect((speed * 2.0).inKmh, closeTo(100.0, tolerance));
        expect((speed / 5.0).inKmh, closeTo(10.0, tolerance));
        expect(() => speed / 0, throwsArgumentError);
      });
    });

    group('Dimensional Analysis', () {
      test('Length / Time = Speed', () {
        final distance = 100.m;
        final time = 10.s;
        final speed = Speed.from(distance, time);
        expect(speed, isA<Speed>());
        expect(speed.inMps, closeTo(10.0, tolerance));

        final distanceKm = 1.km;
        final timeHours = 1.h;
        final speed2 = Speed.from(distanceKm, timeHours);
        expect(speed2.inKmh, closeTo(1.0, tolerance));

        expect(() => Speed.from(100.m, 0.s), throwsArgumentError);
      });

      test('Speed * Time = Length', () {
        final speed = 60.kmh;
        final time = 2.h;
        final distance = speed.distanceOver(time);
        expect(distance, isA<Length>());
        expect(distance.inKm, closeTo(120.0, tolerance));

        final speed2 = 10.mps;
        final time2 = 30.s;
        final distance2 = speed2.distanceOver(time2);
        expect(distance2.inM, closeTo(300.0, tolerance));
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in SpeedUnit.values) {
        test('Round trip ${unit.symbol} <-> m/s', () {
          const initialValue = 123.456;
          final speed = Speed(initialValue, unit);
          final roundTripSpeed = speed.asMetersPerSecond.convertTo(unit);
          expect(roundTripSpeed.value, closeTo(initialValue, tolerance));
        });
      }
    });

    group('Practical Examples', () {
      test('Vehicle speed', () {
        final highwaySpeed = 120.kmh;
        final citySpeed = 30.mph;

        // Compare speeds
        expect(highwaySpeed.compareTo(citySpeed), greaterThan(0));

        // Calculate travel distance
        final travelTime = 30.minutes;
        final distance = highwaySpeed.distanceOver(travelTime);
        expect(distance.inKm, closeTo(60.0, tolerance));
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/speed_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/temperature_test.dart -->
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons

  group('Temperature', () {
    group('Constructors and Getters', () {
      test('should create Temperature from num extensions and retrieve values', () {
        final t1 = 25.0.celsius;
        expect(t1.value, 25.0);
        expect(t1.unit, TemperatureUnit.celsius);
        expect(t1.inFahrenheit, closeTo(77.0, tolerance));

        final t2 = 0.0.kelvin;
        expect(t2.value, 0.0);
        expect(t2.unit, TemperatureUnit.kelvin);
        expect(t2.inCelsius, closeTo(-273.15, tolerance));

        final t3 = 32.fahrenheit;
        expect(t3.value, 32.0);
        expect(t3.unit, TemperatureUnit.fahrenheit);
        expect(t3.inCelsius, closeTo(0.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const temp = Temperature(100, TemperatureUnit.celsius);
        expect(temp.getValue(TemperatureUnit.celsius), 100.0);
      });

      test('Unit.factorTo should throw UnsupportedError for TemperatureUnit', () {
        expect(
          // ignore: invalid_use_of_protected_member : protected member access
          () => TemperatureUnit.celsius.factorTo(TemperatureUnit.fahrenheit),
          throwsUnsupportedError,
        );
        expect(
          // ignore: invalid_use_of_protected_member : protected member access
          () => TemperatureUnit.kelvin.factorTo(TemperatureUnit.celsius),
          throwsUnsupportedError,
        );
      });
    });

    group('Conversions', () {
      // Celsius to others
      test('0°C to Fahrenheit and Kelvin', () {
        final tempC = 0.0.celsius;
        expect(tempC.inFahrenheit, closeTo(32.0, tolerance));
        expect(tempC.inKelvin, closeTo(273.15, tolerance));
      });
      test('100°C to Fahrenheit and Kelvin', () {
        final tempC = 100.0.celsius;
        expect(tempC.inFahrenheit, closeTo(212.0, tolerance));
        expect(tempC.inKelvin, closeTo(373.15, tolerance));
      });
      test('-40°C to Fahrenheit and Kelvin', () {
        final tempC = (-40.0).celsius;
        expect(tempC.inFahrenheit, closeTo(-40.0, tolerance));
        expect(tempC.inKelvin, closeTo(233.15, tolerance));
      });

      // Kelvin to others
      test('0K to Celsius and Fahrenheit', () {
        final tempK = 0.0.kelvin;
        expect(tempK.inCelsius, closeTo(-273.15, tolerance));
        // (-273.15 * 1.8) + 32 = -491.67 + 32 = -459.67
        expect(tempK.inFahrenheit, closeTo(-459.67, tolerance));
      });
      test('273.15K to Celsius and Fahrenheit', () {
        final tempK = 273.15.kelvin;
        expect(tempK.inCelsius, closeTo(0.0, tolerance));
        expect(tempK.inFahrenheit, closeTo(32.0, tolerance));
      });

      // Fahrenheit to others
      test('32°F to Celsius and Kelvin', () {
        final tempF = 32.0.fahrenheit;
        expect(tempF.inCelsius, closeTo(0.0, tolerance));
        expect(tempF.inKelvin, closeTo(273.15, tolerance));
      });
      test('212°F to Celsius and Kelvin', () {
        final tempF = 212.0.fahrenheit;
        expect(tempF.inCelsius, closeTo(100.0, tolerance));
        expect(tempF.inKelvin, closeTo(373.15, tolerance));
      });
      test('-40°F to Celsius and Kelvin', () {
        final tempF = (-40.0).fahrenheit;
        expect(tempF.inCelsius, closeTo(-40.0, tolerance));
        expect(tempF.inKelvin, closeTo(233.15, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Temperature object with converted value and unit', () {
        final tempC = 20.0.celsius;
        final tempF = tempC.convertTo(TemperatureUnit.fahrenheit);

        expect(tempF.unit, TemperatureUnit.fahrenheit);
        expect(tempF.value, closeTo(68.0, tolerance));
        expect(tempC.unit, TemperatureUnit.celsius); // Original should be unchanged
        expect(tempC.value, 20.0);
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final t1 = 10.0.kelvin;
        final t2 = t1.convertTo(TemperatureUnit.kelvin);
        expect(identical(t1, t2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final t0c = 0.0.celsius;
      final t32f = 32.0.fahrenheit;
      final t273k = 273.15.kelvin;

      final t10c = 10.0.celsius;
      final t50f = 50.0.fahrenheit; // 10°C

      test('should correctly compare temperatures of different units', () {
        expect(t0c.compareTo(t32f), 0); // 0°C == 32°F
        expect(t0c.compareTo(t273k), 0); // 0°C == 273.15K
        expect(t32f.compareTo(t273k), 0); // 32°F == 273.15K

        expect(t10c.compareTo(t0c), greaterThan(0)); // 10°C > 0°C
        expect(t50f.compareTo(t32f), greaterThan(0)); // 50°F > 32°F (10°C > 0°C)
        expect(t10c.compareTo(t32f), greaterThan(0)); // 10°C > 32°F (0°C)
        expect(t0c.compareTo(t10c), lessThan(0));
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const t1 = Temperature(25, TemperatureUnit.celsius);
        const t2 = Temperature(25, TemperatureUnit.celsius);
        expect(t1 == t2, isTrue);
        expect(t1.hashCode == t2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const t1 = Temperature(25, TemperatureUnit.celsius);
        const t2 = Temperature(25.1, TemperatureUnit.celsius);
        const t3 = Temperature(25, TemperatureUnit.fahrenheit);
        expect(t1 == t2, isFalse);
        expect(t1 == t3, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(25.0.celsius.toString(), '25.0 °C');
        expect(0.0.kelvin.toString(), '0.0 K');
        expect(77.fahrenheit.toString(), '77.0 °F');
      });
    });

    group('Round Trip Conversions (via direct methods)', () {
      const initialCelsius = 23.45;
      const initialKelvin = 300.12;
      const initialFahrenheit = 68.78;

      test('Celsius round trips', () {
        final c1 = initialCelsius.celsius;
        expect(
          c1.convertTo(TemperatureUnit.fahrenheit).convertTo(TemperatureUnit.celsius).value,
          closeTo(initialCelsius, tolerance),
        );
        expect(
          c1.convertTo(TemperatureUnit.kelvin).convertTo(TemperatureUnit.celsius).value,
          closeTo(initialCelsius, tolerance),
        );
      });

      test('Kelvin round trips', () {
        final k1 = initialKelvin.kelvin;
        expect(
          k1.convertTo(TemperatureUnit.celsius).convertTo(TemperatureUnit.kelvin).value,
          closeTo(initialKelvin, tolerance),
        );
        expect(
          k1.convertTo(TemperatureUnit.fahrenheit).convertTo(TemperatureUnit.kelvin).value,
          closeTo(initialKelvin, tolerance),
        );
      });

      test('Fahrenheit round trips', () {
        final f1 = initialFahrenheit.fahrenheit;
        expect(
          f1.convertTo(TemperatureUnit.celsius).convertTo(TemperatureUnit.fahrenheit).value,
          closeTo(initialFahrenheit, tolerance),
        );
        expect(
          f1.convertTo(TemperatureUnit.kelvin).convertTo(TemperatureUnit.fahrenheit).value,
          closeTo(initialFahrenheit, tolerance),
        );
      });
    });
    group('Arithmetic Operators for Temperature', () {
      final t20C = 20.0.celsius;
      final t10C = 10.0.celsius;
      final t50F = 50.0.fahrenheit; // 10 °C
      final t283K = 283.15.kelvin; // 10 °C

      // Operator - (Temperature) -> double (difference)
      test('operator - calculates temperature difference as double', () {
        final diffC = t20C - t10C; // 20°C - 10°C = 10 C°
        expect(diffC, closeTo(10.0, tolerance));

        final diffCFromF = t20C - t50F; // 20°C - 10°C = 10 C°
        expect(diffCFromF, closeTo(10.0, tolerance));

        // Corrected from previous state where 'diffF_direct' was not used:
        // Original operation: t50F - t20C.convertTo(TemperatureUnit.fahrenheit)
        // This is 50°F - (20°C as °F which is 68°F) = -18 F°
        final temp20CAsFahrenheit = t20C.convertTo(TemperatureUnit.fahrenheit);
        final diffF = t50F - temp20CAsFahrenheit;
        expect(
          diffF,
          closeTo(-18.0, tolerance),
          reason: '50F - 20C (as F) should be -18 F difference',
        );

        final diffkOperation = t283K - t20C; // 283.15K (10°C) - 20°C (converted to K)
        // 283.15K - (20 + 273.15)K = 283.15K - 293.15K = -10.0
        expect(diffkOperation, closeTo(-10.0, tolerance));

        // This was the variable causing the warning. Let's ensure it's used.
        // It will hold the same value as diffK_operation in this case.
        final diffkVariable = t283K - t20C;
        expect(
          diffkVariable,
          closeTo(-10.0, tolerance),
          reason: 'Variable diffK should hold -10.0',
        );

        final zeroDiff = t10C - t50F; // 10C - 10C (50F)
        expect(zeroDiff, closeTo(0.0, tolerance));
      });

      // Operator / (Temperature) -> double (ratio)
      test('operator / divides temperature by another, returning double ratio', () {
        // Note: Ratios of Celsius or Fahrenheit are generally not physically meaningful.
        // Kelvin should be used for meaningful ratios. Test calculates as per implementation.

        final t200K = 200.0.kelvin;
        final t100K = 100.0.kelvin;
        final ratioK = t200K / t100K;
        expect(ratioK, closeTo(2.0, tolerance));

        final t10CVal = 10.0.celsius; // Not 283.15K
        final t20CVal = 20.0.celsius; // Not 293.15K
        // Ratio based on C values: 20/10 = 2.0. If converted to K first, result would be different.
        // The implementation converts the 'other' to 'this.unit'
        final ratioC = t20CVal / t10CVal;
        expect(ratioC, closeTo(2.0, tolerance));

        // 20 C / 50 F => 20 C / 10 C (as 50F is 10C)
        final ratioCF = t20CVal / 50.0.fahrenheit;
        expect(ratioCF, closeTo(2.0, tolerance));

        expect(
          () => t20C / 0.0.celsius,
          throwsArgumentError,
          reason: 'Should throw on division by zero magnitude if dividend is non-zero',
        );
        expect(0.0.celsius / 0.0.celsius, isNaN, reason: '0.0/0.0 should be NaN');
        expect(0.0.kelvin / 0.0.kelvin, isNaN);

        final tZeroKelvin = 0.0.kelvin;
        final tNonZeroKelvin = 10.0.kelvin;
        expect(() => tNonZeroKelvin / tZeroKelvin, throwsArgumentError);
      });

      test('operator + is not defined for Temperature + Temperature', () {
        // This is a check that the operator isn't inadvertently available.
        // Since Dart doesn't allow removing operators via inheritance easily
        // without an abstract method in the base or a linter rule,
        // we just ensure it's not implemented directly in Temperature.
        // If it were inherited from a base that defined it, this test would need adjustment.
        // For now, it's just a conceptual check.
        final dynamic tempA = 10.celsius;
        final dynamic tempB = 20.celsius;
        // Check if calling the '+' operator results in an error,
        // typically NoSuchMethodError if not defined, or TypeError in some dynamic contexts.
        expect(
          // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
          () => tempA + tempB,
          throwsA(
            anyOf(
              isA<NoSuchMethodError>(),
              isA<TypeError>(),
              // Falls eine Basisklasse es doch implementieren würde und Temperature es blockiert:
              // isA<UnsupportedError>()
            ),
          ),
        );
      });

      test('operator * (scalar) is not defined for Temperature', () {
        final dynamic tempA = 10.celsius;
        // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
        expect(() => tempA * 2.0, throwsA(anyOf(isA<NoSuchMethodError>(), isA<TypeError>())));
      });
      test('operator / (scalar) is not defined for Temperature', () {
        final dynamic tempA = 10.celsius;
        // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
        expect(() => tempA / 2.0, throwsA(anyOf(isA<NoSuchMethodError>(), isA<TypeError>())));
      });
    });
  });

  group('Rankine Conversions', () {
    test('absolute zero conversions', () {
      final absoluteZeroK = 0.0.kelvin;
      final absoluteZeroR = 0.0.rankine;
      final absoluteZeroC = (-273.15).celsius;
      final absoluteZeroF = (-459.67).fahrenheit;

      // All should represent absolute zero
      expect(absoluteZeroK.inRankine, closeTo(0.0, tolerance));
      expect(absoluteZeroR.inKelvin, closeTo(0.0, tolerance));
      expect(absoluteZeroC.inRankine, closeTo(0.0, tolerance));
      expect(absoluteZeroF.inRankine, closeTo(0.0, tolerance));
    });

    test('freezing point of water conversions', () {
      final freezingC = 0.0.celsius;
      final freezingF = 32.0.fahrenheit;
      final freezingK = 273.15.kelvin;
      final freezingR = 491.67.rankine; // 32°F + 459.67

      expect(freezingC.inRankine, closeTo(491.67, tolerance));
      expect(freezingF.inRankine, closeTo(491.67, tolerance));
      expect(freezingK.inRankine, closeTo(491.67, tolerance));
      expect(freezingR.inCelsius, closeTo(0.0, tolerance));
      expect(freezingR.inFahrenheit, closeTo(32.0, tolerance));
      expect(freezingR.inKelvin, closeTo(273.15, tolerance));
    });

    test('boiling point of water conversions', () {
      final boilingC = 100.0.celsius;
      final boilingF = 212.0.fahrenheit;
      final boilingK = 373.15.kelvin;
      final boilingR = 671.67.rankine; // 212°F + 459.67

      expect(boilingC.inRankine, closeTo(671.67, tolerance));
      expect(boilingF.inRankine, closeTo(671.67, tolerance));
      expect(boilingK.inRankine, closeTo(671.67, tolerance));
      expect(boilingR.inCelsius, closeTo(100.0, tolerance));
      expect(boilingR.inFahrenheit, closeTo(212.0, tolerance));
      expect(boilingR.inKelvin, closeTo(373.15, tolerance));
    });

    test('rankine to other units', () {
      final temp500R = 500.0.rankine;
      const tolerance = 1e-9;

      const expectedF = 500.0 - Temperature.rankineOffsetFromFahrenheit;
      const expectedC =
          (expectedF - Temperature.fahrenheitOffset) / Temperature.fahrenheitScaleFactor;
      const expectedK = 500.0 / Temperature.fahrenheitScaleFactor;

      expect(temp500R.inFahrenheit, closeTo(expectedF, tolerance));
      expect(temp500R.inCelsius, closeTo(expectedC, tolerance));
      expect(temp500R.inKelvin, closeTo(expectedK, tolerance));
    });

    test('engineering temperature examples', () {
      // Gas turbine inlet temperature ≈ 2500°R
      final turbineTemp = 2500.0.rankine;
      const tolerance = 1e-9;

      const expectedF = 2500.0 - Temperature.rankineOffsetFromFahrenheit;
      const expectedC =
          (expectedF - Temperature.fahrenheitOffset) / Temperature.fahrenheitScaleFactor;
      const expectedK = 2500.0 / Temperature.fahrenheitScaleFactor;

      expect(turbineTemp.inFahrenheit, closeTo(expectedF, tolerance));
      expect(turbineTemp.inCelsius, closeTo(expectedC, tolerance));
      expect(turbineTemp.inKelvin, closeTo(expectedK, tolerance));

      // Cryogenic nitrogen ≈ 140°R
      final liquidNitrogen = 140.0.rankine;

      const expectedFahrenheit = 140.0 - Temperature.rankineOffsetFromFahrenheit;
      const expectedCelsius =
          (expectedFahrenheit - Temperature.fahrenheitOffset) / Temperature.fahrenheitScaleFactor;
      const expectedKelvin =
          140.0 / Temperature.fahrenheitScaleFactor; // Direct conversion from Rankine to Kelvin

      expect(liquidNitrogen.inFahrenheit, closeTo(expectedFahrenheit, tolerance));
      expect(liquidNitrogen.inCelsius, closeTo(expectedCelsius, tolerance));
      expect(liquidNitrogen.inKelvin, closeTo(expectedKelvin, tolerance));
    });
  });

  group('Rankine Scale Properties', () {
    test('rankine is absolute scale like kelvin', () {
      // Both Rankine and Kelvin start at absolute zero
      final absoluteZeroR = 0.0.rankine;
      final absoluteZeroK = 0.0.kelvin;

      expect(absoluteZeroR.inKelvin, closeTo(0.0, tolerance));
      expect(absoluteZeroK.inRankine, closeTo(0.0, tolerance));
    });

    test('rankine degree size equals fahrenheit degree size', () {
      // Temperature difference should be the same in °R and °F
      final temp1R = 100.0.rankine;
      final temp2R = 200.0.rankine;
      final diffR = temp2R - temp1R; // 100 degree difference

      final temp1F = temp1R.inFahrenheit;
      final temp2F = temp2R.inFahrenheit;
      final diffF = temp2F - temp1F;

      expect(diffR, closeTo(diffF, tolerance));
      expect(diffR, closeTo(100.0, tolerance));
    });

    test('kelvin to rankine conversion factor', () {
      // 1 K = 9/5 °R (same ratio as C to F degree size)
      final oneKelvin = 1.0.kelvin;
      final zeroKelvin = 0.0.kelvin;

      final oneKelvinInRankine = oneKelvin.inRankine;
      final zeroKelvinInRankine = zeroKelvin.inRankine;

      final conversionFactor = oneKelvinInRankine - zeroKelvinInRankine;
      expect(conversionFactor, closeTo(1.8, tolerance)); // 9/5
    });
  });

  group('Round Trip Conversions with Rankine', () {
    test('all temperature units round trip through rankine', () {
      const testTemps = [0.0, 100.0, 273.15, 373.15, 500.0];

      for (final temp in testTemps) {
        // Celsius round trip
        final celsius = temp.celsius;
        final celsiusRoundTrip = celsius.asRankine.asCelsius;
        expect(celsiusRoundTrip.value, closeTo(temp, tolerance));

        // Kelvin round trip
        final kelvin = temp.kelvin;
        final kelvinRoundTrip = kelvin.asRankine.asKelvin;
        expect(kelvinRoundTrip.value, closeTo(temp, tolerance));

        // Fahrenheit round trip
        final fahrenheit = temp.fahrenheit;
        final fahrenheitRoundTrip = fahrenheit.asRankine.asFahrenheit;
        expect(fahrenheitRoundTrip.value, closeTo(temp, tolerance));

        // Rankine round trip
        final rankine = temp.rankine;
        final rankineRoundTrip = rankine.asKelvin.asRankine;
        expect(rankineRoundTrip.value, closeTo(temp, tolerance));
      }
    });
  });

  group('Temperature Arithmetic with Rankine', () {
    test('temperature difference calculations', () {
      final temp1 = 500.0.rankine;
      final temp2 = 600.0.rankine;

      final difference = temp2 - temp1;
      expect(difference, closeTo(100.0, tolerance));

      // Same difference in other units
      final temp1F = temp1.asFahrenheit;
      final temp2F = temp2.asFahrenheit;
      final differenceF = temp2F - temp1F;
      expect(differenceF, closeTo(100.0, tolerance));
    });

    test('temperature ratios on absolute scales', () {
      final temp1 = 200.0.rankine;
      final temp2 = 400.0.rankine;

      final ratio = temp2 / temp1;
      expect(ratio, closeTo(2.0, tolerance));

      // Same ratio in Kelvin
      final temp1K = temp1.asKelvin;
      final temp2K = temp2.asKelvin;
      final ratioK = temp2K / temp1K;
      expect(ratioK, closeTo(2.0, tolerance));
    });
  });

  group('Engineering Applications', () {
    test('thermodynamic cycle calculations', () {
      // Simple heat engine with Rankine cycle
      final hotReservoir = 1000.0.rankine; // High temperature
      final coldReservoir = 500.0.rankine; // Low temperature

      // Carnot efficiency = 1 - T_cold/T_hot (absolute temperatures)
      final carnotEfficiency = 1.0 - (coldReservoir / hotReservoir);
      expect(carnotEfficiency, closeTo(0.5, tolerance)); // 50% efficiency

      // Same calculation in Kelvin should give same result
      final hotK = hotReservoir.asKelvin;
      final coldK = coldReservoir.asKelvin;
      final carnotEfficiencyK = 1.0 - (coldK / hotK);
      expect(carnotEfficiencyK, closeTo(carnotEfficiency, tolerance));
    });

    test('gas law calculations', () {
      // Ideal gas law: PV = nRT (requires absolute temperature)
      final roomTemp = 70.0.fahrenheit; // Room temperature
      final roomTempR = roomTemp.inRankine;
      final roomTempK = roomTemp.inKelvin;

      // Both should be above absolute zero
      expect(roomTempR, greaterThan(0.0));
      expect(roomTempK, greaterThan(0.0));

      // Ratio should be the conversion factor
      final tempRatio = roomTempR / roomTempK;
      expect(tempRatio, closeTo(1.8, tolerance)); // 9/5
    });
  });

  group('Comparison and Sorting with Rankine', () {
    test('temperature comparison across all scales', () {
      final freezingC = 0.0.celsius;
      final freezingR = 491.67.rankine;
      final boilingF = 212.0.fahrenheit;
      final roomTempK = 295.0.kelvin; // About 22°C

      // All should be comparable
      expect(freezingC.compareTo(freezingR), 0); // Equal
      expect(roomTempK.compareTo(freezingC), greaterThan(0)); // Room temp > freezing
      expect(boilingF.compareTo(roomTempK), greaterThan(0)); // Boiling > room temp
    });

    test('sorting mixed temperature units', () {
      final temps = [
        100.0.celsius, // Boiling water
        32.0.fahrenheit, // Freezing water
        300.0.kelvin, // Room temperature
        671.67.rankine, // Boiling water in Rankine
        0.0.kelvin, // Absolute zero
      ];

      // ignore: cascade_invocations // Sort by magnitude
      temps.sort();

      // Should be sorted by actual temperature value
      expect(temps[0].unit, TemperatureUnit.kelvin); // Absolute zero
      expect(temps[0].value, 0.0);
      expect(temps[1].unit, TemperatureUnit.fahrenheit); // Freezing
      expect(temps[2].unit, TemperatureUnit.kelvin); // Room temp
      // Last two should be boiling point (equal temperatures)
      expect(temps[3].inCelsius, closeTo(100.0, tolerance));
      expect(temps[4].inCelsius, closeTo(100.0, tolerance));
    });
  });

  group('toString formatting for Rankine', () {
    test('should display correct symbol', () {
      expect(100.0.rankine.toString(), '100.0\u00A0°R');
      expect(459.67.rankine.toString(), '459.67\u00A0°R');
    });

    test('formatting with conversion', () {
      final tempR = 600.0.rankine;
      // Check the Fahrenheit conversion first
      expect(
        tempR.toString(targetUnit: TemperatureUnit.fahrenheit, fractionDigits: 1),
        '140.3\u00A0°F', // Use non-breaking space
      );
      // Now check the Celsius conversion with the correct rounded value
      expect(
        tempR.toString(targetUnit: TemperatureUnit.celsius, fractionDigits: 2),
        '60.18\u00A0°C', // Corrected value and non-breaking space
      );
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/temperature_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/time_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart';
import 'package:quantify/src/units/time/time_factors.dart';
import 'package:test/test.dart';

void main() {
  const highprecisionTolerance = 1e-12; // High precision for time
  const tolerance = 1e-9; // General purpose
  const lowprecisionTolerance = 1e-6; // For calendar units (months, years)

  group('Time', () {
    // Helper for round trip tests
    void testRoundTrip(
      TimeUnit initialUnit,
      TimeUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final t1 = Time(initialValue, initialUnit);
      final t2 = t1.convertTo(intermediateUnit);
      final t3 = t2.convertTo(initialUnit);
      expect(
        t3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Time from num extensions and retrieve values', () {
        final t1 = 60.0.seconds;
        expect(t1.value, 60.0);
        expect(t1.unit, TimeUnit.second);
        expect(t1.inMinutes, closeTo(1.0, highprecisionTolerance));

        final t2 = 1.5.hours;
        expect(t2.value, 1.5);
        expect(t2.unit, TimeUnit.hour);
        expect(t2.inMinutes, closeTo(90.0, highprecisionTolerance));
        expect(t2.inSeconds, closeTo(1.5 * 3600.0, highprecisionTolerance));

        final t3 = 500.milliseconds;
        expect(t3.inSeconds, closeTo(0.5, highprecisionTolerance));

        final t4 = 1.days;
        expect(t4.inHours, closeTo(24.0, highprecisionTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const t = Time(25.0, TimeUnit.minute);
        expect(t.getValue(TimeUnit.minute), 25.0);
      });

      test('getValue for all units from Second base', () {
        final t = 3600.0.seconds; // 1 hour
        expect(t.inSeconds, 3600.0);
        expect(t.inMilliseconds, closeTo(3600.0 * 1000.0, highprecisionTolerance));
        expect(t.inMinutes, closeTo(60.0, highprecisionTolerance));
        expect(t.inHours, closeTo(1.0, highprecisionTolerance));
        expect(t.inDays, closeTo(1.0 / 24.0, highprecisionTolerance));
      });
    });

    group('Conversions', () {
      final oneHour = 1.0.hours;

      test('1 hour to various units', () {
        expect(oneHour.inMinutes, closeTo(60.0, highprecisionTolerance));
        expect(oneHour.inSeconds, closeTo(3600.0, highprecisionTolerance));
        expect(oneHour.inMilliseconds, closeTo(3600.0 * 1000.0, highprecisionTolerance));
      });

      final oneDay = 1.0.days;
      test('1 day to various units', () {
        expect(oneDay.inHours, closeTo(24.0, highprecisionTolerance));
        expect(oneDay.inMinutes, closeTo(24.0 * 60.0, highprecisionTolerance));
        expect(oneDay.inSeconds, closeTo(24.0 * 3600.0, highprecisionTolerance));
      });

      final thirtyMinutes = 30.0.minutes;
      test('30 minutes to hours and seconds', () {
        expect(thirtyMinutes.inHours, closeTo(0.5, highprecisionTolerance));
        expect(thirtyMinutes.inSeconds, closeTo(30.0 * 60.0, highprecisionTolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Time object with converted value and unit', () {
        final tMinutes = 90.0.minutes;
        final tHours = tMinutes.convertTo(TimeUnit.hour);
        expect(tHours.unit, TimeUnit.hour);
        expect(tHours.value, closeTo(1.5, highprecisionTolerance));
        expect(tMinutes.unit, TimeUnit.minute); // Original should be unchanged
      });

      test('convertTo same unit should return same instance', () {
        final t1 = 10.0.seconds;
        final t2 = t1.convertTo(TimeUnit.second);
        expect(identical(t1, t2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final t1Hour = 1.0.hours;
      final t59Minutes = 59.0.minutes;
      final t61Minutes = 61.0.minutes;
      final t3600Seconds = 3600.0.seconds;

      test('should correctly compare times of different units', () {
        expect(t1Hour.compareTo(t59Minutes), greaterThan(0));
        expect(t59Minutes.compareTo(t1Hour), lessThan(0));
        expect(t1Hour.compareTo(t61Minutes), lessThan(0));
      });

      test('should return 0 for equal times in different units', () {
        expect(t1Hour.compareTo(t3600Seconds), 0);
        expect(t3600Seconds.compareTo(t1Hour), 0);
        final tPoint5Hours = 0.5.hours;
        final t30Minutes = 30.0.minutes;
        expect(tPoint5Hours.compareTo(t30Minutes), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const t1 = Time(10.0, TimeUnit.second);
        const t2 = Time(10.0, TimeUnit.second);
        expect(t1 == t2, isTrue);
        expect(t1.hashCode == t2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const t1 = Time(10.0, TimeUnit.second);
        const t2 = Time(10.1, TimeUnit.second);
        const t3 = Time(10.0, TimeUnit.minute);
        expect(t1 == t2, isFalse);
        expect(t1 == t3, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(10.5.seconds.toString(), '10.5 s');
        expect(120.0.minutes.toString(), '120.0 min');
        expect(2.5.hours.toString(), '2.5 h');
        expect(1.days.toString(), '1.0 d');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 789.123;
      const highTolerance = 1e-7;

      for (final unit in TimeUnit.values) {
        test('Round trip ${unit.symbol} <-> s', () {
          testRoundTrip(
            unit,
            TimeUnit.second,
            testValue,
            tolerance: (unit == TimeUnit.second) ? 1e-9 : highTolerance,
          );
        });
      }

      test('Round trip min <-> h', () {
        testRoundTrip(TimeUnit.minute, TimeUnit.hour, 120.0, tolerance: highTolerance);
      });
      test('Round trip ms <-> s', () {
        testRoundTrip(TimeUnit.millisecond, TimeUnit.second, 2500.0, tolerance: highTolerance);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final tZero = 0.0.seconds;
        for (final unit in TimeUnit.values) {
          expect(tZero.getValue(unit), 0.0, reason: '0 s to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for Time', () {
      final t1Hour = 1.0.hours;
      final t2Hours = 2.0.hours;
      final t30Minutes = 30.minutes; // 0.5 hours

      // Operator +
      test('operator + combines time durations', () {
        final sum1 = t2Hours + t1Hour;
        expect(sum1.value, closeTo(3.0, highprecisionTolerance));
        expect(sum1.unit, TimeUnit.hour);

        final sum2 = t1Hour + t30Minutes; // 1h + 0.5h = 1.5h
        expect(sum2.value, closeTo(1.5, highprecisionTolerance));
        expect(sum2.unit, TimeUnit.hour);

        final sum3 = t30Minutes + t1Hour; // 30min + 60min = 90min
        expect(sum3.value, closeTo(90.0, highprecisionTolerance));
        expect(sum3.unit, TimeUnit.minute);
      });

      // Operator -
      test('operator - subtracts time durations', () {
        final diff1 = t2Hours - t1Hour;
        expect(diff1.value, closeTo(1.0, highprecisionTolerance));
        expect(diff1.unit, TimeUnit.hour);

        final diff2 = t1Hour - t30Minutes; // 1h - 0.5h = 0.5h
        expect(diff2.value, closeTo(0.5, highprecisionTolerance));
        expect(diff2.unit, TimeUnit.hour);
      });

      // Operator * (scalar)
      test('operator * scales time duration by a scalar', () {
        final scaled = t2Hours * 0.5;
        expect(scaled.value, closeTo(1.0, highprecisionTolerance));
        expect(scaled.unit, TimeUnit.hour);
      });

      // Operator / (scalar)
      test('operator / scales time duration by a scalar', () {
        final scaled = t2Hours / 2.0;
        expect(scaled.value, closeTo(1.0, highprecisionTolerance));
        expect(scaled.unit, TimeUnit.hour);
        expect(() => t1Hour / 0.0, throwsArgumentError);
      });
    });
  });

  group('Extended Time Units', () {
    group('SI Prefix Units (sub-second)', () {
      test('microsecond conversions', () {
        final oneMicrosecond = 1.0.us;
        expect(oneMicrosecond.inSeconds, closeTo(1e-6, highprecisionTolerance));
        expect(oneMicrosecond.inMilliseconds, closeTo(0.001, highprecisionTolerance));
        expect(oneMicrosecond.inNanoseconds, closeTo(1000.0, highprecisionTolerance));
      });

      test('nanosecond conversions', () {
        final oneNanosecond = 1.0.ns;
        expect(oneNanosecond.inSeconds, closeTo(1e-9, highprecisionTolerance));
        expect(oneNanosecond.inMicroseconds, closeTo(0.001, highprecisionTolerance));
        expect(oneNanosecond.inPicoseconds, closeTo(1000.0, highprecisionTolerance));
      });

      test('picosecond conversions', () {
        final onePicosecond = 1.0.ps;
        expect(onePicosecond.inSeconds, closeTo(1e-12, highprecisionTolerance));
        expect(onePicosecond.inNanoseconds, closeTo(0.001, highprecisionTolerance));
        expect(onePicosecond.inMicroseconds, closeTo(1e-6, highprecisionTolerance));
      });

      test('sub-second scale relationships', () {
        // Test the progression: s -> ms -> μs -> ns -> ps
        final oneSecond = 1.0.s;
        expect(oneSecond.inMilliseconds, closeTo(1000.0, highprecisionTolerance));
        expect(oneSecond.inMicroseconds, closeTo(1e6, highprecisionTolerance));
        expect(oneSecond.inNanoseconds, closeTo(1e9, lowprecisionTolerance));
        expect(oneSecond.inPicoseconds, closeTo(1e12, highprecisionTolerance));
      });
    });

    group('Calendar Units', () {
      test('week conversions', () {
        final oneWeek = 1.0.wk;
        expect(oneWeek.inDays, closeTo(7.0, highprecisionTolerance));
        expect(oneWeek.inHours, closeTo(168.0, highprecisionTolerance)); // 7 * 24
        expect(oneWeek.inMinutes, closeTo(10080.0, highprecisionTolerance)); // 7 * 24 * 60
        expect(oneWeek.inSeconds, closeTo(604800.0, highprecisionTolerance)); // 7 * 24 * 60 * 60
      });

      test('month conversions', () {
        final oneMonth = 1.0.mo;
        // Based on average month: 365.25 days / 12 = 30.4375 days
        expect(oneMonth.inDays, closeTo(30.4375, tolerance));
        expect(oneMonth.inWeeks, closeTo(4.348214286, tolerance));
        expect(oneMonth.inHours, closeTo(730.5, tolerance));
        expect(oneMonth.inSeconds, closeTo(2629800.0, tolerance));
      });

      test('year conversions', () {
        final oneYear = 1.0.yr;
        // Based on Julian year: 365.25 days
        expect(oneYear.inDays, closeTo(365.25, highprecisionTolerance));
        expect(oneYear.inWeeks, closeTo(52.178571429, lowprecisionTolerance));
        expect(oneYear.inMonths, closeTo(12.0, lowprecisionTolerance));
        expect(oneYear.inHours, closeTo(8766.0, highprecisionTolerance)); // 365.25 * 24
        expect(
          oneYear.inSeconds,
          closeTo(31557600.0, highprecisionTolerance),
        ); // 365.25 * 24 * 60 * 60
      });

      test('calendar relationships', () {
        // Test approximate relationships
        final oneYear = 1.0.yr;
        final twelveMonths = 12.0.mo;
        final fiftyTwoWeeks = 52.0.wk;

        // Based on the definitions, a Julian year is now exactly 12 average months.
        expect(oneYear.compareTo(twelveMonths), 0);

        // Year should be slightly more than 52 weeks
        expect(oneYear.compareTo(fiftyTwoWeeks), greaterThan(0));

        // Differences should be small
        expect(oneYear.inMonths, closeTo(12.0, 0.1));
        expect(oneYear.inWeeks, closeTo(52.18, 0.2));
      });
    });

    group('Practical time measurements', () {
      test('computer processing times', () {
        // CPU clock cycles at 3 GHz
        final cpuCycle = (1.0 / 3e9).s; // 1/3 nanosecond
        expect(cpuCycle.inNanoseconds, closeTo(1.0 / 3.0, tolerance));

        // Memory access time ≈ 100 ns
        final memoryAccess = 100.0.ns;
        expect(memoryAccess.inMicroseconds, closeTo(0.1, highprecisionTolerance));

        // SSD access time ≈ 0.1 ms
        final ssdAccess = 0.1.ms;
        expect(ssdAccess.inMicroseconds, closeTo(100.0, highprecisionTolerance));
      });

      test('scientific measurements', () {
        // Light travel times
        final lightToMoon = 1.28.s; // Light travel time to moon
        final lightAroundEarth = 0.134.s; // Light travel around Earth's equator

        expect(lightToMoon.inMilliseconds, closeTo(1280.0, highprecisionTolerance));
        expect(lightAroundEarth.inMilliseconds, closeTo(134.0, highprecisionTolerance));

        // Atomic vibrations ≈ femtoseconds (10^-15 s)
        final atomicVibration = 1e-3.ps; // 1 femtosecond in picoseconds
        expect(atomicVibration.inSeconds, closeTo(1e-15, highprecisionTolerance));
      });

      test('biological time scales', () {
        // Human heartbeat ≈ 1 Hz (1 beat per second)
        final heartbeat = 1.0.s;
        expect(heartbeat.inMilliseconds, closeTo(1000.0, highprecisionTolerance));

        // Nerve impulse ≈ 1 ms
        final nerveImpulse = 1.0.ms;
        expect(nerveImpulse.inMicroseconds, closeTo(1000.0, highprecisionTolerance));

        // Muscle contraction ≈ 100 ms
        final muscleContraction = 100.0.ms;
        expect(muscleContraction.inSeconds, closeTo(0.1, highprecisionTolerance));
      });

      test('human time scales', () {
        // Work schedules
        final workDay = 8.0.h;
        final workWeek = workDay * 5;
        expect(workWeek.inHours, closeTo(40.0, highprecisionTolerance));

        // Life spans
        final humanLifespan = 75.0.yr;
        final dogLifespan = 12.0.yr;
        expect(humanLifespan.inMonths, closeTo(900.0, lowprecisionTolerance));
        expect(dogLifespan.inDays, closeTo(4383.0, lowprecisionTolerance));
      });
    });

    group('Time arithmetic with mixed scales', () {
      test('adding very different time scales', () {
        final longTime = 1.0.yr;
        final shortTime = 1.0.ns;
        final combined = longTime + shortTime;

        // Nanosecond should be negligible compared to year
        expect(combined.inYears, closeTo(1.0, lowprecisionTolerance));
        expect(combined.unit, TimeUnit.year);
      });

      test('precise timing calculations', () {
        // GPS satellite clock corrections
        final gpsClockDrift = 38.0.us; // microseconds per day
        final oneDay = 1.0.d;

        expect(gpsClockDrift.inNanoseconds, closeTo(38000.0, tolerance));
        expect(oneDay.inMicroseconds, closeTo(86400e6, highprecisionTolerance));

        // Clock error rate
        final errorRate = gpsClockDrift.inSeconds / oneDay.inSeconds;
        expect(errorRate, closeTo(4.4e-10, 1e-12)); // Very small error rate
      });

      test('project timeline calculations', () {
        // Software development timeline

        final projectDuration = 6.0.mo;
        final sprintDuration = 2.0.wk;

        // Calculate expected value instead of hardcoding it
        const expectedWeeks = (6 * TimeFactors.secondsPerMonth) / TimeFactors.secondsPerWeek;
        expect(projectDuration.inWeeks, closeTo(expectedWeeks, lowprecisionTolerance));

        final numberOfSprints = projectDuration.inWeeks / sprintDuration.inWeeks;
        // The expectation for numberOfSprints should also be calculated
        const expectedSprints = expectedWeeks / 2.0;
        expect(numberOfSprints, closeTo(expectedSprints, 0.1));
      });
    });

    group('Round trip conversions for new units', () {
      const testValue = 789.123;

      test('sub-second round trips', () {
        final units = [
          TimeUnit.microsecond,
          TimeUnit.nanosecond,
          TimeUnit.picosecond,
        ];

        for (final unit in units) {
          final original = Time(testValue, unit);
          final converted = original.convertTo(TimeUnit.second).convertTo(unit);
          expect(
            converted.value,
            closeTo(testValue, tolerance),
            reason: 'Round trip failed for ${unit.symbol}',
          );
        }
      });

      test('calendar unit round trips', () {
        final units = [
          TimeUnit.week,
          TimeUnit.month,
          TimeUnit.year,
        ];

        for (final unit in units) {
          final original = Time(testValue, unit);
          final converted = original.convertTo(TimeUnit.second).convertTo(unit);
          expect(
            converted.value,
            closeTo(testValue, lowprecisionTolerance),
            reason: 'Round trip failed for ${unit.symbol}',
          );
        }
      });
    });

    group('Sorting different time scales', () {
      test('mixed scale sorting', () {
        final times = [
          1.0.yr, // 1 year
          100.0.d, // 100 days
          1000.0.h, // 1000 hours ≈ 41.7 days
          1.0.mo, // 1 month ≈ 30.4 days
          10.0.wk, // 10 weeks = 70 days
        ];

        // ignore: cascade_invocations // Sort by magnitude
        times.sort();

        // Should be sorted: 1 mo < 1000 h < 10 wk < 100 d < 1 yr
        expect(times[0].unit, TimeUnit.month);
        expect(times[1].unit, TimeUnit.hour);
        expect(times[2].unit, TimeUnit.week);
        expect(times[3].unit, TimeUnit.day);
        expect(times[4].unit, TimeUnit.year);
      });
    });

    group('toString formatting for new units', () {
      test('should display correct symbols', () {
        expect(1.0.us.toString(), '1.0\u00A0μs');
        expect(1.0.ns.toString(), '1.0\u00A0ns');
        expect(1.0.ps.toString(), '1.0\u00A0ps');
        expect(1.0.wk.toString(), '1.0\u00A0wk');
        expect(1.0.mo.toString(), '1.0\u00A0mo');
        expect(1.0.yr.toString(), '1.0\u00A0yr');
      });

      test('alternative short form accessors', () {
        expect(1.0.min.toString(), '1.0\u00A0min');
        expect(1.0.h.toString(), '1.0\u00A0h');
        expect(1.0.d.toString(), '1.0\u00A0d');
        expect(1.0.s.toString(), '1.0\u00A0s');
        expect(1.0.ms.toString(), '1.0\u00A0ms');
      });
    });

    group('SI Prefix Units (deci, centi, deca, hecto, kilo, mega, giga)', () {
      const tolerance = 1e-12;

      test('deci- and centiseconds', () {
        final oneSecond = 1.0.s;
        expect(oneSecond.inDeciseconds, closeTo(10.0, tolerance));
        expect(oneSecond.inCentiseconds, closeTo(100.0, tolerance));

        final oneDecisecond = 1.0.ds;
        expect(oneDecisecond.inMilliseconds, closeTo(100.0, tolerance));

        final oneCentisecond = 1.0.cs;
        expect(oneCentisecond.inMilliseconds, closeTo(10.0, tolerance));
      });

      test('deca-, hecto-, and kiloseconds', () {
        final oneKilosecond = 1.0.kiloS;
        expect(oneKilosecond.inSeconds, closeTo(1000.0, tolerance));
        expect(oneKilosecond.inHectoseconds, closeTo(10.0, tolerance));
        expect(oneKilosecond.inDecaseconds, closeTo(100.0, tolerance));
      });

      test('mega- and gigaseconds', () {
        final oneMegasecond = 1.0.megaS; // 1 million seconds
        expect(oneMegasecond.inDays, closeTo(1e6 / 86400, 1e-9)); // ~11.57 days

        final oneGigasecond = 1.0.gigaS; // 1 billion seconds
        expect(oneGigasecond.inYears, closeTo(1e9 / 31557600.0, 1e-9)); // ~31.7 years
      });
    });

    group('Calendar Units (Fortnight, Decade, Century)', () {
      const tolerance = 1e-9;

      test('fortnight conversions', () {
        final oneFortnight = 1.0.fortnights;
        expect(oneFortnight.inDays, closeTo(14.0, tolerance));
        expect(oneFortnight.inWeeks, closeTo(2.0, tolerance));
      });

      test('decade conversions', () {
        final oneDecade = 1.0.decades;
        expect(oneDecade.inYears, closeTo(10.0, tolerance));
        // A decade has 120 average months
        expect(oneDecade.inMonths, closeTo(120.0, 1e-6));
      });

      test('century conversions', () {
        final oneCentury = 1.0.centuries;
        expect(oneCentury.inYears, closeTo(100.0, tolerance));
        expect(oneCentury.inDecades, closeTo(10.0, tolerance));
      });

      test('sorting calendar units', () {
        final times = [1.0.centuries, 1.0.years, 1.0.decades, 1.0.fortnights]..sort();

        expect(times[0].unit, TimeUnit.fortnight);
        expect(times[1].unit, TimeUnit.year);
        expect(times[2].unit, TimeUnit.decade);
        expect(times[3].unit, TimeUnit.century);
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/time_test.dart -->

<!-- BEGIN FILE: [v0.12.0] test/units/volume_test.dart -->
import 'package:quantify/volume.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9;
  const highTolerance = 1e-6;

  group('Volume', () {
    // Helper for round trip tests
    void testRoundTrip(
      VolumeUnit initialUnit,
      VolumeUnit intermediateUnit,
      double initialValue, {
      double tol = tolerance,
    }) {
      final v1 = Volume(initialValue, initialUnit);
      final v2 = v1.convertTo(intermediateUnit);
      final v3 = v2.convertTo(initialUnit);
      expect(
        v3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Volume from num extensions and retrieve values', () {
        final v1 = 1.5.m3;
        expect(v1.value, 1.5);
        expect(v1.unit, VolumeUnit.cubicMeter);
        expect(v1.inLiters, closeTo(1500.0, tolerance));

        final v2 = 500.ml;
        expect(v2.inLiters, closeTo(0.5, tolerance));
        expect(v2.inCubicCentimeters, closeTo(500.0, tolerance));

        final v3 = 1.gal;
        expect(v3.inQuarts, closeTo(4.0, tolerance));
        expect(v3.inPints, closeTo(8.0, tolerance));
        expect(v3.inFluidOunces, closeTo(128.0, tolerance));
      });
    });

    group('Conversions', () {
      test('SI and Litre equivalences', () {
        expect(1.m3.inKiloliters, closeTo(1.0, tolerance));
        expect(1.dm3.inLiters, closeTo(1.0, tolerance));
        expect(1.cm3.inMilliliters, closeTo(1.0, tolerance));
        expect(1.mm3.inMicroliters, closeTo(1.0, tolerance));
        expect(1.dam3.inMegaliters, closeTo(1.0, tolerance));
        expect(1.hm3.inGigaliters, closeTo(1.0, tolerance));
        expect(1.km3.inTeraliters, closeTo(1.0, tolerance));
      });

      test('US customary hierarchy', () {
        final oneGallon = 1.gal;
        expect(oneGallon.inQuarts, closeTo(4.0, tolerance));
        expect(oneGallon.inPints, closeTo(8.0, tolerance));
        expect(oneGallon.inFluidOunces, closeTo(128.0, tolerance));
        expect(oneGallon.inTablespoons, closeTo(256.0, tolerance));
        expect(oneGallon.inTeaspoons, closeTo(768.0, tolerance));
      });

      test('Cubic imperial/US hierarchy', () {
        final oneCubicFoot = 1.ft3;
        expect(oneCubicFoot.inCubicInches, closeTo(1728.0, tolerance));
      });

      test('Cross-system conversions', () {
        // Calculate expected values from fundamental definitions (1 gal = 231 in³, 1 in = 2.54 cm)
        const cubicInchesPerGallon = 231.0;
        const cmPerInch = 2.54;
        const cubicCmPerCubicInch = cmPerInch * cmPerInch * cmPerInch;
        const cubicCmPerLiter = 1000.0;

        const expectedLitersInOneGallon =
            (cubicInchesPerGallon * cubicCmPerCubicInch) / cubicCmPerLiter;

        // --- Test Gallon to Liter ---
        final oneGallon = 1.gal;
        expect(oneGallon.inLiters, closeTo(expectedLitersInOneGallon, highTolerance));

        // --- Test Liter to other units ---
        final oneLiter = 1.l;
        const expectedGallonsInOneLiter = 1 / expectedLitersInOneGallon;
        const expectedFlOzInOneLiter = expectedGallonsInOneLiter * 128.0;
        const expectedCubicInchesInOneLiter = cubicCmPerLiter / cubicCmPerCubicInch;

        expect(oneLiter.inGallons, closeTo(expectedGallonsInOneLiter, highTolerance));
        expect(oneLiter.inFluidOunces, closeTo(expectedFlOzInOneLiter, highTolerance));
        expect(oneLiter.inCubicInches, closeTo(expectedCubicInchesInOneLiter, highTolerance));
      });
    });

    group('Comparison', () {
      test('should correctly compare volumes of different units', () {
        // Test GREATER THAN: 1 cubic meter (1000 L) is greater than 999 liters.
        expect(1.m3.compareTo(999.l), greaterThan(0));

        // Test EQUAL: 1 US Gallon is EXACTLY 4 US Quarts.
        expect(1.gal.compareTo(4.qt), 0, reason: '1 gallon should be exactly equal to 4 quarts');

        // Test LESS THAN: 1 US Gallon is less than 5 US Quarts.
        expect(1.gal.compareTo(5.qt), lessThan(0));

        // Test EQUAL: 1 Liter is EXACTLY 1000 Cubic Centimeters.
        expect(1.l.compareTo(1000.cm3), 0);
      });
    });

    group('Arithmetic', () {
      test('should correctly perform arithmetic operations', () {
        final v1 = 1.gal;
        final v2 = 1.l;
        final sum = v1 + v2;
        final difference = v1 - v2;

        expect(sum.inGallons, closeTo(1.0 + 0.264172, highTolerance));
        expect(difference.inGallons, closeTo(1.0 - 0.264172, highTolerance));
        expect((v1 * 2.0).inGallons, closeTo(2.0, tolerance));
        expect((v1 / 2.0).inGallons, closeTo(0.5, tolerance));
      });
    });

    group('Round Trip Conversions', () {
      for (final unit in VolumeUnit.values) {
        test('Round trip ${unit.symbol} <-> m³', () {
          testRoundTrip(
            unit,
            VolumeUnit.cubicMeter,
            123.456,
            tol: highTolerance,
          );
        });
      }
    });

    group('toString()', () {
      test('should return formatted string for various units', () {
        expect(1.5.m3.toString(), '1.5\u00A0m³');
        expect(250.ml.toString(), '250.0\u00A0mL');
        expect(1.gal.toString(), '1.0\u00A0gal');
        expect(8.flOz.toString(), '8.0\u00A0fl-oz');
        expect(1.tsp.toString(), '1.0\u00A0tsp');
      });
    });
  });
}

<!-- END FILE: [v0.12.0] test/units/volume_test.dart -->

---
Generated with llmifier v0.2.2
Created by Software Engineering Philipp Gerber
Repository: https://github.com/PhilippHGerber/llmifier
Package: https://pub.dev/packages/llmifier
