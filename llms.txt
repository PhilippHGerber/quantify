# Project Documentation: quantify v0.2.0

Generated by llmifier on: 2025-06-16T10:44:14
Extraction Mode: full
Project Type: dart

---

<!-- BEGIN FILE: [v0.2.0] README.md -->
# Quantify

[![pub version](https://img.shields.io/pub/v/quantify.svg)](https://pub.dev/packages/quantify)
[![license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/PhilippHGerber/quantify/blob/main/LICENSE)

A type-safe units of measurement library for Dart, providing an elegant syntax for unit conversions with good precision and optimal performance.

## Why `quantify`?

`quantify` makes working with physical units in Dart safer, more readable, and efficient:

* **Type Safety:** Prevents unit mismatch errors at compile-time.
* **Elegant API:** Intuitive syntax like `10.m` or `length.inKm`.
* **Precise & Performant:** Uses `double` and direct conversion factors for speed and to minimize rounding errors.
* **Immutable:** `Quantity` objects are immutable for safer code.
* **Configurable Output:** Highly flexible `toString()` for customized formatting.
* **Lightweight:** Minimal dependencies.

## Quick Start

```dart
import 'package:quantify/quantify.dart';
// For locale-specific number formatting, add 'intl' to your pubspec.yaml
// and import 'package:intl/intl.dart';

void main() {
  // Create quantities
  final pathA = 1500.m;
  final pathB = 2.5.km;

  // Convert to value / a new Quantity object
  double pathInKm = pathA.inKm;
  final pathAsKm = pathA.asKm;

  // Convert and print
  print(pathA.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 1));  // Output: "1.5 km"
  print(pathB.toString(targetUnit: LengthUnit.mile, fractionDigits: 2));  // Output: "1.55 mi" (approx.)

  // Arithmetic
  final distance = pathA + pathB; // pathB is converted to meters
  print(distance.toString(fractionDigits: 0));  // Output: "4000 m"
  print(distance.toString(
    targetUnit: LengthUnit.yard,
    fractionDigits: 0,
  ));  // Output: "4374 yd" (approx., with non-breaking space)

  // Locale-specific example (if 'intl' is used)
  // final distanceDE = 1234.567.m;
  print(distanceDE.toString(
    targetUnit: LengthUnit.kilometer,
    fractionDigits: 2,
    locale: 'de_DE',
  ));  // Output: "1,23 km"
}
```

## Installation

Add to your `pubspec.yaml`:

```yaml
dependencies:
  quantify: ^0.2.0 # Or latest version
  # Optional, for locale-specific number formatting:
  # intl: ^0.19.0
```

Then run `dart pub get` or `flutter pub get`.

## Supported Units

The library aims to support a wide range of physical quantities, including fundamental SI units and common derived units. Below is an overview:

| Quantity Type                 | Status | Example Units Available / Planned (SI units emphasized)                                              | Notes / SI Base Unit Ref. |
| :---------------------------- | :--: | :----------------------------------------------------------------------------------------------------- | :------------------------ |
| **Length**                    |  ‚úÖ  | **`m`** (meter), `km`, `cm`, `mm`, `in`, `ft`, `yd`, `mi`, `nmi`                                       | SI Base: Meter (m)        |
| **Mass**                      |  ‚úÖ  | **`kg`** (kilogram), `g`, `mg`, `t` (tonne), `lb`, `oz`, `st` (stone), `slug`                          | SI Base: Kilogram (kg)    |
| **Time**                      |  ‚úÖ  | **`s`** (second), `ms`, `min`, `h`, `d`                                                                | SI Base: Second (s)       |
| **Electric Current**          |  ‚úÖ  | **`A`** (ampere), `mA`, `¬µA`, `nA`, `kA`                                                               | SI Base: Ampere (A)       |
| **Temperature**               |  ‚úÖ  | **`K`** (kelvin), `¬∞C` (celsius), `¬∞F` (fahrenheit)                                                    | SI Base: Kelvin (K)       |
| **Amount of Substance**       |  ‚úÖ  | **`mol`** (mole), `mmol`, `¬µmol`, `nmol`, `pmol`, `kmol`                                               | SI Base: Mole (mol)       |
| **Luminous Intensity**        |  ‚úÖ  | **`cd`** (candela), `mcd`, `kcd`                                                                       | SI Base: Candela (cd)     |
| --- Derived ---               |      |                                                                                                        |                           |
| **Pressure**                  |  ‚úÖ  | **`Pa`** (Pascal), `atm`, `bar`, `psi`, `Torr`, `mmHg`, `inHg`, `kPa`, `hPa`, `mbar`, `cmH‚ÇÇO`, `inH‚ÇÇO` | Derived SI: N/m¬≤          |
| Area                          |  üóìÔ∏è  | **`m¬≤`** (square meter), `km¬≤`, `cm¬≤`, `ha` (hectare), `acre` ...                                      | Derived SI                |
| Volume                        |  üóìÔ∏è  | **`m¬≥`** (cubic meter), `L` (liter), `mL`, `cm¬≥`, `gal` (gallon), `fl oz` ...                          | Derived SI                |
| Speed / Velocity              |  üóìÔ∏è  | **`m/s`** (meter per second), `km/h`, `mph`, `knot` ...                                                | Derived SI                |
| Acceleration                  |  üóìÔ∏è  | **`m/s¬≤`** (meter per second squared), `g` (standard gravity) ...                                      | Derived SI                |
| Force                         |  üóìÔ∏è  | **`N`** (Newton), `lbf` (pound-force), `dyn` (dyne) ...                                                | Derived SI: kg¬∑m/s¬≤       |
| Energy / Work                 |  üóìÔ∏è  | **`J`** (Joule), `kWh` (kilowatt-hour), `cal` (calorie), `eV` (electronvolt) ...                       | Derived SI: N¬∑m           |
| Power                         |  üí°  | **`W`** (Watt), `hp` (horsepower) ...                                                                  | Derived SI: J/s           |
| Frequency                     |  üí°  | **`Hz`** (Hertz), `kHz`, `MHz` ...                                                                     | Derived SI: 1/s           |
| --- Electrical (Derived) ---  |      |                                                                                                        |                           |
| Electric Charge               |  üí°  | **`C`** (Coulomb) ...                                                                                  | Derived SI: A¬∑s           |
| Electric Potential            |  üí°  | **`V`** (Volt) ...                                                                                     | Derived SI: W/A           |
| Electric Resistance           |  üí°  | **`Œ©`** (Ohm) ...                                                                                      | Derived SI: V/A           |
| Electric Capacitance          |  üí°  | **`F`** (Farad) ...                                                                                    | Derived SI: C/V           |
| --- Photometric (Derived) --- |      |                                                                                                        |                           |
| Luminous Flux                 |  üí°  | **`lm`** (Lumen) ...                                                                                   | Derived SI: cd¬∑sr         |
| Illuminance                   |  üí°  | **`lx`** (Lux) ...                                                                                     | Derived SI: lm/m¬≤         |
| --- Other ---                 |      |                                                                                                        |                           |
| *...more*                     |  üí°  | Other common physical quantities based on demand.                                                      |                           |

## Detailed Usage

### Creating Quantities

Use extension methods on `num` for readability:

```dart
final myLength = 25.5.m;
final anotherLength = 10.ft;
```

Or use the constructor of the specific `Quantity` class:

```dart
final specificLength = Length(5.0, LengthUnit.yard);
```

### Converting and Retrieving Values

1. **Get Numerical Value:** Use `in[UnitName]` getters or `getValue(TargetUnit)`.

    ```dart
    final oneMile = 1.0.mi;
    double milesInKm = oneMile.inKm; // approx 1.609344
    double milesInMeters = oneMile.getValue(LengthUnit.meter); // approx 1609.344
    ```

2. **Get New `Quantity` Object:** Use `convertTo(TargetUnit)` or `as[UnitName]` getters.

    ```dart
    final tenMeters = 10.m;
    final tenMetersInFeetObj = tenMeters.convertTo(LengthUnit.foot);
    // tenMetersInFeetObj is Length(approx 32.8084, LengthUnit.foot)
    final tenMetersInKmObj = tenMeters.asKm;
    // tenMetersInKmObj is Length(0.01, LengthUnit.kilometer)
    ```

### Formatting Output with `toString()`

The `toString()` method on `Quantity` objects is highly configurable:

```dart
final myDistance = 1578.345.m;

// Default
print(myDistance.toString()); // "1578.345 m"

// Convert to kilometers, 2 fraction digits
print(myDistance.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2));
// Output: "1.58 km"

// Convert to feet, 1 fraction digit, hide unit symbol
print(myDistance.toString(
    targetUnit: LengthUnit.foot,
    fractionDigits: 1,
    showUnitSymbol: false,
));
// Output: "5178.3"

// Parameters:
// - targetUnit: Converts to this unit before formatting.
// - fractionDigits: Sets fixed number of decimal places.
// - showUnitSymbol: (Default: true) Hides unit symbol if false.
// - unitSymbolSeparator: (Default: " ") String between value and symbol. Use '\u00A0' for non-breaking space.
// - locale: (Requires 'intl' package) BCP 47 language tag (e.g., 'en_US', 'de_DE') for locale-aware number formatting.
// - numberFormat: (Requires 'intl' package) An intl.NumberFormat instance for full control.
```

### Arithmetic Operations

Standard arithmetic operators (`+`, `-`, `*`, `/` by a scalar) are overloaded. The result's unit is typically that of the left-hand operand. `Temperature` has specific arithmetic rules.

```dart
final segment1 = 500.m;
final segment2 = 0.25.km; // 250 meters
final total = segment1 + segment2; // Result is in meters
print(total.toString()); // "750.0 m"

final scaled = segment1 * 3;
print(scaled.toString()); // "1500.0 m"
```

### Comparisons & Sorting

Quantities are `Comparable`, allowing them to be sorted even if their units differ. `compareTo()` is used for magnitude comparison. The `==` operator checks for equal value AND unit.

```dart
final oneMeter = 1.m;
final hundredCm = 100.cm;
final twoFeet = 2.ft; // approx 0.6096 meters
final oneYard = 1.yd; // approx 0.9144 meters

print(oneMeter.compareTo(hundredCm) == 0); // true (magnitudes are equal)
print(oneMeter == hundredCm);          // false (units are different)

// Sorting a list of various lengths
final lengths = [
  oneMeter,    // 1.0 m
  twoFeet,     // ~0.61 m
  oneYard,     // ~0.91 m
  50.cm,       // 0.5 m
  0.2.km       // 200.0 m
];

print('Original list:');
lengths.forEach((l) => print(l.toString(fractionDigits: 2)));

lengths.sort(); // Sorts in ascending order by magnitude

print('\nSorted list (ascending):');
lengths.forEach((l) => print(l.toString(fractionDigits: 2)));
// Output (approximate, order will be based on precise double values):
// Sorted list (ascending):
// 50.00 cm
// 2.00 ft
// 1.00 yd
// 1.00 m
// 200.00 km

// To sort descending:
// lengths.sort((a, b) => b.compareTo(a));
```

## Goals & Roadmap

* **V1.0 (Current):** Solid foundation for common units (`double` precision), type safety, elegant API, configurable `toString()`.
* **V2.0 and Beyond:**
  * **High Precision:** Support for `Decimal`.
  * **Enhanced Quantity Arithmetic:** e.g., `Distance / Time = Speed`.
  * **More Unit Types:** See table above.
  * **Serialization support.**

## Contributing

Contributions are welcome! Please open an [Issue](https://github.com/PhilippHGerber/quantify/issues) or a [Pull Request](https://github.com/PhilippHGerber/quantify/pulls).

## License

MIT License - see the `LICENSE` file.

<!-- END FILE: [v0.2.0] README.md -->

<!-- BEGIN FILE: [v0.2.0] CHANGELOG.md -->
# Changelog

All notable changes to the `quantify` package will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.2.0]

2025-06-16

### Added

- **New SI Base Quantity Types (completing all 7 SI base units):**
  - **Mass:**
    - `Mass` class and `MassUnit` enum (`kg`, `g`, `mg`, `t` (tonne), `lb`, `oz`, `st` (stone), `slug`).
  - **Amount of Substance (Molar Amount):**
    - `MolarAmount` class and `MolarUnit` enum (`mol`, `mmol`, `¬µmol`, `nmol`, `pmol`, `kmol`).
  - **Electric Current:**
    - `Current` class and `CurrentUnit` enum (`A`, `mA`, `¬µA`, `nA`, `kA`).
  - **Luminous Intensity:**
    - `LuminousIntensity` class and `LuminousIntensityUnit` enum (`cd`, `mcd`, `kcd`).

## [0.1.0]

2025-06-12

### Added

- **Initial Release of `quantify` v0.1.0**
- **Core Functionality:**
  - Type-safe `Quantity` base class for representing physical quantities with a value and a unit.
  - `Unit` interface for defining conversion factors and symbols.
  - Immutable `Quantity` objects.
  - `double` precision for quantity values.
  - Elegant API with extension methods on `num` for quantity creation (e.g., `10.m`, `20.celsius`).
  - Extension methods on `Quantity` for easy value retrieval in target units (e.g., `length.inKm`) and for obtaining new `Quantity` objects in target units (e.g., `length.asKm`).
  - Configurable `toString()` method on `Quantity` objects supporting:
    - Conversion to a `targetUnit` before formatting.
    - Fixed `fractionDigits`.
    - Option to `showUnitSymbol`.
    - Custom `unitSymbolSeparator`.
    - Locale-aware number formatting via `locale` parameter (using `intl` package).
    - Full control over number formatting via `numberFormat` parameter (using `intl` package).
  - Arithmetic operations (`+`, `-`, `*` by scalar, `/` by scalar) for most quantities.
  - Specialized arithmetic for `Temperature` (difference `T - T` returns `double`, ratio `T / T` returns `double`).
  - `Comparable` interface implementation for sorting quantities by magnitude.
  - `==` operator override for value and unit equality.
- **Supported Quantity Types (with units and extensions):**
  - **Length:** Meter (m), Kilometer (km), Centimeter (cm), Millimeter (mm), Inch (in), Foot (ft), Yard (yd), Mile (mi), Nautical Mile (nmi).
  - **Time:** Second (s), Millisecond (ms), Minute (min), Hour (h), Day (d).
  - **Temperature:** Kelvin (K), Celsius (¬∞C), Fahrenheit (¬∞F). Handles affine conversions correctly.
  - **Pressure:** Pascal (Pa), Atmosphere (atm), Bar (bar), PSI (psi), Torr, mmHg, inHg, kPa, hPa, mbar, cmH‚ÇÇO, inH‚ÇÇO.

<!-- END FILE: [v0.2.0] CHANGELOG.md -->

<!-- BEGIN FILE: [v0.2.0] LICENSE -->
Copyright 2025 Philipp H. Gerber

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without
restriction, including without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

<!-- END FILE: [v0.2.0] LICENSE -->

<!-- BEGIN FILE: [v0.2.0] pubspec.yaml -->
name: quantify
description: A type-safe units of measurement library for Dart, providing elegant syntax for unit conversions with good precision, optimal performance, and configurable output formatting.
version: 0.2.0

homepage: https://github.com/PhilippHGerber/quantify
repository: https://github.com/PhilippHGerber/quantify
issue_tracker: https://github.com/PhilippHGerber/quantify/issues

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  intl: ">=0.18.1 <0.21.0"
  meta: ^1.16.0

dev_dependencies:
  test: ^1.26.0
  very_good_analysis: ^8.0.0

topics:
  - units
  - measurement
  - conversion
  - physics
  - utility

screenshots:
  - description: "quantify Logo"
    path: pub/quantify.webp

<!-- END FILE: [v0.2.0] pubspec.yaml -->

<!-- BEGIN FILE: [v0.2.0] analysis_options.yaml -->
include: package:very_good_analysis/analysis_options.yaml

formatter:
  page_width: 100
#  trailing_commas: preserve

analyzer:
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"
    - "test/.test_coverage.dart"
    - "bin/cache/**"
    - "lib/generated_plugin_registrant.dart"

  errors:
    unused_import: warning
    todo: ignore

linter:
  rules:
    # Allow relative imports for files within the same package
    always_use_package_imports: false
    # Prefer using relative imports within the same package
    prefer_relative_imports: true
    # Allow lines to exceed 80 characters
    lines_longer_than_80_chars: false
    # Prefer using const constructors where possible
    prefer_const_constructors: true
    # Prefer declaring local variables as final if they are not reassigned
    prefer_final_locals: true
    # Allow mutable literal lists/maps/sets even if they could be const
    prefer_const_literals_to_create_immutables: false
    # Allow explicitly typing closure parameters
    avoid_types_on_closure_parameters: false
    # Allow TODOs without the Flutter-style format (e.g., missing author tags)
    flutter_style_todos: false
    # Use trailing commas for all parameter lists and argument lists.
    require_trailing_commas: true
    # Use enums rather than classes that behave like enums.
    use_enums: true

    # Prototyping and Development:
    # Allow public classes and members without documentation comments
    public_member_api_docs: true

<!-- END FILE: [v0.2.0] analysis_options.yaml -->

<!-- BEGIN FILE: [v0.2.0] lib/quantify.dart -->
/// A type-safe library for units of measurement, providing elegant syntax for unit conversions.
library;

export 'src/core/quantity.dart';
export 'src/core/unit.dart';
// Exporting units and their extensions for electric current
export 'src/units/current/current.dart';
export 'src/units/current/current_extensions.dart';
export 'src/units/current/current_unit.dart';
// Exporting units and their extensions for length
export 'src/units/length/length.dart';
export 'src/units/length/length_extensions.dart';
export 'src/units/length/length_unit.dart';
// Exporting units and their extensions for luminous intensity
export 'src/units/luminous/luminous_intensity.dart';
export 'src/units/luminous/luminous_intensity_extensions.dart';
export 'src/units/luminous/luminous_intensity_unit.dart';
// Exporting units and their extensions for mass
export 'src/units/mass/mass.dart';
export 'src/units/mass/mass_extensions.dart';
export 'src/units/mass/mass_unit.dart';
// Exporting units and their extensions for molar amount
export 'src/units/molar/molar_amount.dart';
export 'src/units/molar/molar_extensions.dart';
export 'src/units/molar/molar_unit.dart';
// Exporting units and their extensions for pressure
export 'src/units/pressure/pressure.dart';
export 'src/units/pressure/pressure_extensions.dart';
export 'src/units/pressure/pressure_unit.dart';
// Exporting units and their extensions for temperature
export 'src/units/temperature/temperature.dart';
export 'src/units/temperature/temperature_extensions.dart';
export 'src/units/temperature/temperature_unit.dart';
// Exporting units and their extensions for time
export 'src/units/time/time.dart';
export 'src/units/time/time_extensions.dart';
export 'src/units/time/time_unit.dart';

<!-- END FILE: [v0.2.0] lib/quantify.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/core/quantity.dart -->
import 'package:intl/intl.dart';
import 'package:meta/meta.dart';

import 'unit.dart';

/// An abstract representation of a physical quantity, encapsulating a numerical
/// [value] and a specific [unit] of measurement.
///
/// This class serves as the foundation for all specific quantity types (e.g., `Length`,
/// `Pressure`, `Temperature`). It enforces a common interface for unit conversions,
/// comparisons, and string formatting.
///
/// ## Immutability
/// `Quantity` objects are immutable. Operations that might seem to modify a quantity,
/// such as unit conversion (`convertTo`) or arithmetic, always return a new `Quantity`
/// instance with the updated value or unit, leaving the original instance unchanged.
/// This promotes safer and more predictable code.
///
/// ## Type Parameter `T`
/// The type parameter `T` represents the specific `Unit` enum associated with this
/// quantity type. For example, a `Pressure` quantity would use `PressureUnit` for `T`,
/// so it would be declared as `class Pressure extends Quantity<PressureUnit>`.
///
/// ## Comparison
/// `Quantity` implements `Comparable<Quantity<T>>`, allowing quantities of the
/// same type (e.g., two `Length` objects) to be compared based on their physical
/// magnitude, even if their internal units differ. The `compareTo` method handles
/// necessary conversions for accurate comparison.
@immutable
abstract class Quantity<T extends Unit<T>> implements Comparable<Quantity<T>> {
  /// Creates a new `Quantity` with a given numerical [value] and its corresponding [unit].
  ///
  /// Subclasses will typically call this constructor via `super(value, unit)`.
  ///
  /// - [_value]: The numerical magnitude of the quantity.
  /// - [_unit]: The unit of measurement for the `_value`.
  const Quantity(this._value, this._unit);

  /// The internal numerical value of this quantity, represented as a [double].
  /// This value is always in the context of the original [_unit] it was created with.
  final double _value;

  /// The internal unit of measurement for this quantity's [_value].
  /// This is an instance of the specific `Unit` enum `T`.
  final T _unit;

  /// Returns the numerical value of this quantity in its original [unit].
  ///
  /// Example:
  /// ```dart
  /// final length = Length(10.5, LengthUnit.meter);
  /// print(length.value); // Output: 10.5
  /// ```
  double get value => _value;

  /// Returns the unit of measurement associated with this quantity's original [value].
  ///
  /// Example:
  /// ```dart
  /// final length = Length(10.5, LengthUnit.meter);
  /// print(length.unit); // Output: LengthUnit.meter
  /// ```
  T get unit => _unit;

  /// Converts this quantity's [value] to the specified [targetUnit] and
  /// returns the numerical result of this conversion.
  ///
  /// This method must be implemented by concrete subclasses.
  ///
  /// For most quantities (e.g., `Length`, `Pressure`), this involves a direct
  /// multiplication by a conversion factor:
  /// `convertedValue = this.value * this.unit.factorTo(targetUnit)`.
  ///
  /// For quantities with affine conversions (like `Temperature` with Celsius or
  /// Fahrenheit), subclasses must implement specific conversion formulas that
  /// account for offsets (e.g., `(value * 9/5) + 32` for Celsius to Fahrenheit).
  ///
  /// - [targetUnit]: The desired unit to which the current quantity's value
  ///   should be converted.
  ///
  /// Returns the numerical value of this quantity expressed in the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final lengthInMeters = Length(1.0, LengthUnit.kilometer);
  /// double meters = lengthInMeters.getValue(LengthUnit.meter); // meters will be 1000.0
  ///
  /// final tempInCelsius = Temperature(0.0, TemperatureUnit.celsius);
  /// double fahrenheit = tempInCelsius.getValue(TemperatureUnit.fahrenheit); // fahrenheit will be 32.0
  /// ```
  double getValue(T targetUnit);

  /// Creates a new `Quantity` instance of the same type, with its value
  /// converted to the specified [targetUnit].
  ///
  /// This method must be implemented by concrete subclasses.
  /// It should utilize `getValue(targetUnit)` to get the numerical value in the
  /// target unit and then construct a new instance of the concrete quantity type.
  ///
  /// This is useful for obtaining a new `Quantity` object in a different unit
  /// while preserving the type information and immutability.
  ///
  /// - [targetUnit]: The desired unit for the new `Quantity` instance.
  ///
  /// Returns a new `Quantity` instance representing the same physical magnitude
  /// as this instance, but expressed in the [targetUnit]. If `targetUnit` is
  /// the same as `this.unit`, this method might return `this` instance directly
  /// as an optimization, since `Quantity` objects are immutable.
  ///
  /// Example:
  /// ```dart
  /// final lengthInKm = Length(1.5, LengthUnit.kilometer);
  /// final lengthInMeters = lengthInKm.convertTo(LengthUnit.meter);
  /// // lengthInMeters is now Length(1500.0, LengthUnit.meter)
  ///
  /// final tempInC = Temperature(20.0, TemperatureUnit.celsius);
  /// final tempInF = tempInC.convertTo(TemperatureUnit.fahrenheit);
  /// // tempInF is now Temperature(68.0, TemperatureUnit.fahrenheit)
  /// ```
  Quantity<T> convertTo(T targetUnit);

  /// Compares this quantity to another [Quantity] of the same type (`T`).
  ///
  /// This method must be implemented by concrete subclasses.
  /// The comparison is based on the physical magnitude of the quantities.
  /// To achieve this, one quantity (or both) might need to be converted to a
  /// common unit before their numerical values are compared. A common strategy
  /// is to convert `this.value` to `other.unit` using `getValue(other.unit)`
  /// and then compare the result with `other.value`.
  ///
  /// Returns:
  /// - A negative integer if this quantity is less than [other].
  /// - Zero if this quantity is equal in magnitude to [other].
  /// - A positive integer if this quantity is greater than [other].
  ///
  /// This method is essential for sorting collections of `Quantity` objects.
  @override
  int compareTo(Quantity<T> other);

  /// Returns a string representation of this quantity, with options for
  /// formatting and unit conversion.
  ///
  /// By default, it formats as `"[value] [unit_symbol]"` (e.g., "10.5 m"),
  /// using the quantity's current value and unit symbol, separated by a
  /// non-breaking space. Number formatting defaults to Dart's `double.toString()`.
  ///
  /// ## Parameters:
  ///
  /// - [targetUnit]: (Optional) If provided, the quantity's value will be
  ///   converted to this unit *before* formatting. The displayed unit symbol
  ///   will also be that of [targetUnit].
  ///   Example: `1.km.toString(targetUnit: LengthUnit.meter)` might produce "1000.0 m".
  ///
  /// - [fractionDigits]: (Optional) If provided and [numberFormat] is `null`,
  ///   the numerical value will be formatted to this fixed number of decimal places.
  ///   If [locale] is also provided, formatting attempts to respect it for decimal
  ///   and grouping separators (using `NumberFormat.decimalPatternDigits`).
  ///   Otherwise, `double.toStringAsFixed()` is used (locale-agnostic, uses '.' as decimal separator).
  ///   Example: `1.2345.m.toString(fractionDigits: 2)` might produce "1.23 m".
  ///
  /// - [showUnitSymbol]: (Optional) Defaults to `true`. If `false`, only the
  ///   numerical value (potentially converted and formatted) is returned, without
  ///   the unit symbol and separator.
  ///   Example: `10.m.toString(showUnitSymbol: false)` produces "10.0".
  ///
  /// - [unitSymbolSeparator]: (Optional) The string used to separate the formatted
  ///   numerical value and the unit symbol. Defaults to a non-breaking space (`'\u00A0'`).
  ///   Example: `10.m.toString(unitSymbolSeparator: "-")` produces "10.0-m".
  ///
  /// - [locale]: (Optional) A BCP 47 language tag (e.g., 'en_US', 'de_DE').
  ///   If provided and [numberFormat] is `null`, this locale is used for number
  ///   formatting (via `package:intl`). This affects decimal separators, grouping
  ///   separators, etc. Requires the `intl` package to be available.
  ///   Example: `1234.56.m.toString(locale: 'de_DE', fractionDigits: 1)` might produce "1234,6 m".
  ///
  /// - [numberFormat]: (Optional) An explicit `intl.NumberFormat` instance.
  ///   If provided, this takes precedence over [fractionDigits] and [locale] for
  ///   number formatting, offering maximum control. Requires the `intl` package.
  ///   Example:
  ///   ```dart
  ///   final customFormat = NumberFormat("#,##0.000", "en_US");
  ///   print(1234.5.m.toString(numberFormat: customFormat)); // "1,234.500 m"
  ///   ```
  ///
  /// Returns a string representation of the quantity according to the specified options.
  @override
  String toString({
    T? targetUnit,
    int? fractionDigits,
    bool showUnitSymbol = true,
    String unitSymbolSeparator = '\u00A0', // Default: Non-breaking space
    String? locale,
    NumberFormat? numberFormat,
  }) {
    var valueToFormat = _value;
    var unitToDisplay = _unit;

    // Step 1: Convert to target unit if specified.
    // If a target unit is provided and it's different from the current unit,
    // get the value in the target unit for formatting.
    if (targetUnit != null && targetUnit != _unit) {
      valueToFormat = getValue(targetUnit);
      unitToDisplay = targetUnit;
    }

    // Step 2: Format the numerical value.
    String formattedValue;

    if (numberFormat != null) {
      // If an explicit NumberFormat is provided, use it directly. This offers the most control.
      formattedValue = numberFormat.format(valueToFormat);
    } else {
      // Otherwise, use fractionDigits and/or locale if provided.
      if (locale != null) {
        // A locale is specified.
        if (fractionDigits != null) {
          // Both locale and fractionDigits: Use NumberFormat.decimalPatternDigits
          // for locale-aware fixed fraction digits.
          final nf = NumberFormat.decimalPatternDigits(
            locale: locale,
            decimalDigits: fractionDigits,
          );
          formattedValue = nf.format(valueToFormat);
        } else {
          // Locale provided, but no specific fractionDigits: Use a default decimal pattern for the locale.
          final nf = NumberFormat.decimalPattern(locale);
          formattedValue = nf.format(valueToFormat);
        }
      } else {
        // No locale and no explicit NumberFormat. Use Dart's built-in formatting.
        if (fractionDigits != null) {
          // Only fractionDigits provided: Use Dart's toStringAsFixed.
          // This is NOT locale-aware (always uses '.' as decimal separator).
          formattedValue = valueToFormat.toStringAsFixed(fractionDigits);
        } else {
          // No formatting options: Default double to string conversion.
          formattedValue = valueToFormat.toString();
        }
      }
    }

    // Step 3: Construct the final string.
    if (showUnitSymbol) {
      // Append the unit symbol (from unitToDisplay, which is targetUnit if conversion occurred)
      // and the specified separator.
      return '$formattedValue$unitSymbolSeparator${unitToDisplay.symbol}';
    } else {
      // Return only the formatted numerical value.
      return formattedValue;
    }
  }

  /// Determines whether this [Quantity] is equal to another [Object].
  ///
  /// Two `Quantity` instances are considered equal if they are:
  /// 1. The same instance (identical).
  /// 2. Of the exact same runtime type (e.g., both `Length`, not one `Length` and one `Pressure`).
  /// 3. Have the same numerical [value].
  /// 4. Have the same [unit].
  ///
  /// This means `1.m` is NOT equal to `100.cm` according to `==`, because their
  /// units differ, even though their physical magnitudes are the same.
  /// For magnitude comparison, use `compareTo()` or convert to a common unit first.
  ///
  /// - [other]: The object to compare against.
  ///
  /// Returns `true` if the objects are equal based on the criteria above, `false` otherwise.
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Quantity<T> &&
        runtimeType ==
            other.runtimeType && // Ensures strict type equality (e.g., Length != Pressure)
        _value == other._value &&
        _unit == other._unit;
  }

  /// Returns a hash code for this `Quantity` instance.
  ///
  /// The hash code is generated based on the [runtimeType], the numerical [_value],
  /// and the [_unit]. This is consistent with the `operator ==` implementation:
  /// if two `Quantity` objects are equal according to `==`, they will have the
  /// same hash code.
  @override
  int get hashCode => Object.hash(runtimeType, _value, _unit);
}

<!-- END FILE: [v0.2.0] lib/src/core/quantity.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/core/unit.dart -->
import 'package:meta/meta.dart';

/// A contract for all unit enums.
///
/// Each unit enum (e.g., `PressureUnit`, `LengthUnit`) must implement this
/// interface to provide a way to get a conversion factor to another unit
/// of the same type.
///
/// [T] is the specific unit enum type itself (e.g., `PressureUnit`).
abstract class Unit<T extends Unit<T>> {
  /// Returns the direct conversion factor to convert a value from this unit
  /// to the [targetUnit].
  ///
  /// The conversion is performed by multiplying the original value by this factor:
  /// `convertedValue = originalValue * this.factorTo(targetUnit);`
  @internal
  double factorTo(T targetUnit);

  /// A human-readable symbol or abbreviation for the unit.
  ///
  /// This should be a concise representation suitable for display.
  /// For example: "m" for Meter, "psi" for Pound per Square Inch, "¬∞C" for Celsius.
  String get symbol;
}

<!-- END FILE: [v0.2.0] lib/src/core/unit.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/current/current.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'current_unit.dart';

/// Represents a quantity of electric current.
///
/// Electric current is the rate of flow of electric charge. The SI base unit
/// for electric current is the Ampere (A). It is a fundamental quantity in
/// electrical engineering and physics.
///
/// This class provides a type-safe way to handle electric current values and
/// conversions between different units (e.g., amperes, milliamperes, kiloamperes).
@immutable
class Current extends Quantity<CurrentUnit> {
  /// Creates a new `Current` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final circuitCurrent = Current(1.5, CurrentUnit.ampere);
  /// final sensorOutput = Current(20.0, CurrentUnit.milliampere);
  /// ```
  const Current(super.value, super.unit);

  /// Converts this electric current's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `CurrentUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final currentInAmperes = Current(0.05, CurrentUnit.ampere);
  /// final valueInMilliamperes = currentInAmperes.getValue(CurrentUnit.milliampere); // 50.0
  /// ```
  @override
  double getValue(CurrentUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Current] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Current` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final currentInMilliamperes = Current(2500.0, CurrentUnit.milliampere);
  /// final currentInAmperesObj = currentInMilliamperes.convertTo(CurrentUnit.ampere);
  /// // currentInAmperesObj is Current(2.5, CurrentUnit.ampere)
  /// print(currentInAmperesObj); // Output: "2.5 A" (depending on toString formatting)
  /// ```
  @override
  Current convertTo(CurrentUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Current(newValue, targetUnit);
  }

  /// Compares this [Current] object to another [Quantity<CurrentUnit>].
  ///
  /// Comparison is based on the physical magnitude of the electric currents.
  /// For an accurate comparison, this current's value is converted to the unit
  /// of the [other] current before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this current is less than [other].
  /// - Zero if this current is equal in magnitude to [other].
  /// - A positive integer if this current is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final c1 = Current(1.0, CurrentUnit.ampere);        // 1000 mA
  /// final c2 = Current(1000.0, CurrentUnit.milliampere); // 1000 mA
  /// final c3 = Current(0.5, CurrentUnit.ampere);       // 500 mA
  ///
  /// print(c1.compareTo(c2)); // 0 (equal magnitude)
  /// print(c1.compareTo(c3)); // 1 (c1 > c3)
  /// print(c3.compareTo(c1)); // -1 (c3 < c1)
  /// ```
  @override
  int compareTo(Quantity<CurrentUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this electric current to another electric current.
  ///
  /// The [other] current is converted to the unit of this current before addition.
  /// The result is a new [Current] instance with the sum, expressed in the unit of this current.
  /// This is physically meaningful in contexts like Kirchhoff's Current Law (junction rule).
  ///
  /// Example:
  /// ```dart
  /// final currentBranchA = Current(0.75, CurrentUnit.ampere);
  /// final currentBranchB = Current(250.0, CurrentUnit.milliampere); // 0.25 A
  /// final totalCurrent = currentBranchA + currentBranchB; // Result: Current(1.0, CurrentUnit.ampere)
  /// ```
  Current operator +(Current other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Current(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another electric current from this electric current.
  ///
  /// The [other] current is converted to the unit of this current before subtraction.
  /// The result is a new [Current] instance with the difference, expressed in the unit of this current.
  ///
  /// Example:
  /// ```dart
  /// final mainCurrent = Current(2.0, CurrentUnit.ampere);
  /// final currentToDevice = Current(800.0, CurrentUnit.milliampere); // 0.8 A
  /// final remainingCurrent = mainCurrent - currentToDevice; // Result: Current(1.2, CurrentUnit.ampere)
  /// ```
  Current operator -(Current other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Current(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this electric current by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Current] instance with the scaled value, in the original unit of this current.
  /// This might be used, for example, if a current is distributed equally among several paths.
  ///
  /// Example:
  /// ```dart
  /// final currentPerWire = Current(0.1, CurrentUnit.ampere);
  /// final totalCurrentFor5Wires = currentPerWire * 5.0; // Result: Current(0.5, CurrentUnit.ampere)
  /// ```
  Current operator *(double scalar) {
    return Current(value * scalar, unit);
  }

  /// Divides this electric current by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Current] instance with the scaled value, in the original unit of this current.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalCurrent = Current(1.0, CurrentUnit.ampere);
  /// final currentPerBranch = totalCurrent / 4.0; // Result: Current(0.25, CurrentUnit.ampere)
  /// ```
  Current operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Current(value / scalar, unit);
  }

  // Potential future enhancements for Current:
  // - Current * Time = ElectricCharge (would require ElectricCharge type)
  // - ElectricPotential / Current = Resistance (would require ElectricPotential and Resistance types)
  // - Power / Current = ElectricPotential (would require Power and ElectricPotential types)
}

<!-- END FILE: [v0.2.0] lib/src/units/current/current.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/current/current_extensions.dart -->
import 'current.dart';
import 'current_unit.dart';

/// Provides convenient access to [Current] values in specific units
/// using getter properties.
extension CurrentValueGetters on Current {
  /// Returns the electric current value in Amperes (A).
  double get inAmperes => getValue(CurrentUnit.ampere);

  /// Returns the electric current value in Milliamperes (mA).
  double get inMilliamperes => getValue(CurrentUnit.milliampere);

  /// Returns the electric current value in Microamperes (¬µA).
  double get inMicroamperes => getValue(CurrentUnit.microampere);

  /// Returns the electric current value in Nanoamperes (nA).
  double get inNanoamperes => getValue(CurrentUnit.nanoampere);

  /// Returns the electric current value in Kiloamperes (kA).
  double get inKiloamperes => getValue(CurrentUnit.kiloampere);

  // --- "As" Getters for new Current objects ---

  /// Returns a new [Current] object representing this current in Amperes (A).
  Current get asAmperes => convertTo(CurrentUnit.ampere);

  /// Returns a new [Current] object representing this current in Milliamperes (mA).
  Current get asMilliamperes => convertTo(CurrentUnit.milliampere);

  /// Returns a new [Current] object representing this current in Microamperes (¬µA).
  Current get asMicroamperes => convertTo(CurrentUnit.microampere);

  /// Returns a new [Current] object representing this current in Nanoamperes (nA).
  Current get asNanoamperes => convertTo(CurrentUnit.nanoampere);

  /// Returns a new [Current] object representing this current in Kiloamperes (kA).
  Current get asKiloamperes => convertTo(CurrentUnit.kiloampere);
}

/// Provides convenient factory methods for creating [Current] instances from [num]
/// using getter properties named after common unit symbols or names.
extension CurrentCreation on num {
  /// Creates a [Current] instance representing this numerical value in Amperes (A).
  Current get A => Current(toDouble(), CurrentUnit.ampere); // Using symbol 'A'

  /// Creates a [Current] instance representing this numerical value in Amperes (A).
  /// Alias for `A`.
  Current get amperes => Current(toDouble(), CurrentUnit.ampere);

  /// Creates a [Current] instance representing this numerical value in Milliamperes (mA).
  Current get mA => Current(toDouble(), CurrentUnit.milliampere);

  /// Creates a [Current] instance representing this numerical value in Milliamperes (mA).
  /// Alias for `mA`.
  Current get milliamperes => Current(toDouble(), CurrentUnit.milliampere);

  /// Creates a [Current] instance representing this numerical value in Microamperes (¬µA).
  Current get uA => Current(toDouble(), CurrentUnit.microampere); // Using 'uA' for micro

  /// Creates a [Current] instance representing this numerical value in Microamperes (¬µA).
  /// Alias for `uA`.
  Current get microamperes => Current(toDouble(), CurrentUnit.microampere);

  /// Creates a [Current] instance representing this numerical value in Nanoamperes (nA).
  Current get nA => Current(toDouble(), CurrentUnit.nanoampere);

  /// Creates a [Current] instance representing this numerical value in Nanoamperes (nA).
  /// Alias for `nA`.
  Current get nanoamperes => Current(toDouble(), CurrentUnit.nanoampere);

  /// Creates a [Current] instance representing this numerical value in Kiloamperes (kA).
  Current get kA => Current(toDouble(), CurrentUnit.kiloampere);

  /// Creates a [Current] instance representing this numerical value in Kiloamperes (kA).
  /// Alias for `kA`.
  Current get kiloamperes => Current(toDouble(), CurrentUnit.kiloampere);
}

<!-- END FILE: [v0.2.0] lib/src/units/current/current_extensions.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/current/current_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

/// Defines base conversion factors for various electric current units relative
/// to the Ampere (A), which is the SI base unit for electric current.
///
/// These constants represent: `1 [Unit] = Z [Amperes]`.
/// So, `amperesPerMilliampere` means `1 milliampere = amperesPerMilliampere amperes`.
class CurrentFactors {
  // --- SI Prefixed Units (relative to Ampere) ---

  /// Amperes per Milliampere: 1 milliampere (mA) = 0.001 amperes (A).
  static const double amperesPerMilliampere = 0.001;

  /// Amperes per Microampere: 1 microampere (¬µA) = 0.000001 amperes (A).
  static const double amperesPerMicroampere = 0.000001; // 1e-6

  /// Amperes per Nanoampere: 1 nanoampere (nA) = 1e-9 amperes (A).
  static const double amperesPerNanoampere = 1.0e-9;

  /// Amperes per Kiloampere: 1 kiloampere (kA) = 1000 amperes (A).
  static const double amperesPerKiloampere = 1000.0;

  // --- Other potential units (less common for general use, but exist) ---
  // Example: Biot (Bi) or abampere, an electromagnetic CGS unit of current.
  // 1 Biot (abampere) = 10 Amperes.
  // static const double amperesPerBiot = 10.0;

  // Example: Statampere, an electrostatic CGS unit of current.
  // 1 Statampere ‚âà 3.33564 √ó 10‚Åª¬π‚Å∞ Amperes.
  // static const double amperesPerStatampere = 3.3356409519815204e-10;
  // For now, focusing on SI prefixed units.
}

<!-- END FILE: [v0.2.0] lib/src/units/current/current_factors.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/current/current_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'current_factors.dart';

/// Represents units for electric current.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each electric current unit.
/// All conversion factors are pre-calculated in the constructor relative to Ampere (A),
/// which is the SI base unit for electric current.
enum CurrentUnit implements Unit<CurrentUnit> {
  /// Ampere (A), the SI base unit of electric current.
  /// Defined by taking the fixed numerical value of the elementary charge *e* to be
  /// 1.602176634 √ó 10‚Åª¬π‚Åπ when expressed in the unit C, which is equal to A s.
  ampere(1, 'A'),

  /// Milliampere (mA), equal to 0.001 amperes.
  milliampere(CurrentFactors.amperesPerMilliampere, 'mA'),

  /// Microampere (¬µA), equal to 1e-6 amperes.
  microampere(CurrentFactors.amperesPerMicroampere, '¬µA'),

  /// Nanoampere (nA), equal to 1e-9 amperes.
  nanoampere(CurrentFactors.amperesPerNanoampere, 'nA'),

  /// Kiloampere (kA), equal to 1000 amperes.
  kiloampere(CurrentFactors.amperesPerKiloampere, 'kA');

  // If Biot were to be added:
  // /// Biot (Bi) or abampere, an electromagnetic CGS unit of current.
  // /// 1 Bi = 10 A.
  // biot(CurrentFactors.amperesPerBiot, 'Bi');

  /// Constant constructor for enum members.
  ///
  /// [_toAmpereFactor] is the factor to convert from this unit to the base unit (Ampere).
  /// For Ampere itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `CurrentUnit`.
  const CurrentUnit(double toAmpereFactor, this.symbol)
      : _toAmpereFactor = toAmpereFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToAmpere = toAmpereFactor / 1.0, // Base unit factor for ampere is 1.0
        _factorToMilliampere = toAmpereFactor / CurrentFactors.amperesPerMilliampere,
        _factorToMicroampere = toAmpereFactor / CurrentFactors.amperesPerMicroampere,
        _factorToNanoampere = toAmpereFactor / CurrentFactors.amperesPerNanoampere,
        _factorToKiloampere = toAmpereFactor / CurrentFactors.amperesPerKiloampere;
  // If biot were added:
  // _factorToBiot = toAmpereFactor / CurrentFactors.amperesPerBiot;

  /// The factor to convert a value from this unit to the base unit (Ampere).
  /// Example: For Milliampere, this is 0.001 (meaning 1 mA = 0.001 A).
  /// This field is primarily used internally by the constructor.
  // ignore: unused_field
  final double _toAmpereFactor;

  /// The human-readable symbol for this electric current unit (e.g., "A", "mA").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToAmpere;
  final double _factorToMilliampere;
  final double _factorToMicroampere;
  final double _factorToNanoampere;
  final double _factorToKiloampere;
  // If biot were added:
  // final double _factorToBiot;

  /// Returns the direct conversion factor to convert a value from this [CurrentUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `Current`
  /// class for conversions.
  @override
  @internal
  double factorTo(CurrentUnit targetUnit) {
    switch (targetUnit) {
      case CurrentUnit.ampere:
        return _factorToAmpere;
      case CurrentUnit.milliampere:
        return _factorToMilliampere;
      case CurrentUnit.microampere:
        return _factorToMicroampere;
      case CurrentUnit.nanoampere:
        return _factorToNanoampere;
      case CurrentUnit.kiloampere:
        return _factorToKiloampere;
      // If biot were added:
      // case CurrentUnit.biot:
      //  return _factorToBiot;
    }
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/current/current_unit.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/length/length.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'length_unit.dart';

/// Represents a quantity of length.
@immutable
class Length extends Quantity<LengthUnit> {
  /// Creates a new Length quantity with the given [value] and [unit].
  const Length(super.value, super.unit);

  /// Converts this length's value to the specified [targetUnit].
  @override
  double getValue(LengthUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Length] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Length` object in a different unit
  /// without losing the type information.
  ///
  /// Example:
  /// ```dart
  /// final oneFoot = Length(1.0, LengthUnit.foot);
  /// final inInches = oneFoot.convertTo(LengthUnit.inch); // Length(12.0, LengthUnit.inch)
  /// print(inInches.value); // 12.0
  /// ```
  @override
  Length convertTo(LengthUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Length(newValue, targetUnit);
  }

  /// Compares this [Length] object to another [Quantity<LengthUnit>].
  ///
  /// Comparison is based on the physical magnitude of the lengths.
  /// For comparison, this length is converted to the unit of the [other] length.
  ///
  /// Returns:
  /// - A negative integer if this length is less than [other].
  /// - Zero if this length is equal to [other].
  /// - A positive integer if this length is greater than [other].
  @override
  int compareTo(Quantity<LengthUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this length to another length.
  /// The [other] length is converted to the unit of this length before addition.
  /// Returns a new [Length] instance with the result in the unit of this length.
  Length operator +(Length other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Length(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another length from this length.
  /// The [other] length is converted to the unit of this length before subtraction.
  /// Returns a new [Length] instance with the result in the unit of this length.
  Length operator -(Length other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Length(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this length by a scalar value.
  /// Returns a new [Length] instance with the scaled value in the original unit.
  Length operator *(double scalar) {
    return Length(value * scalar, unit);
  }

  /// Divides this length by a scalar value.
  /// Returns a new [Length] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Length operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Length(value / scalar, unit);
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/length/length.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/length/length_extensions.dart -->
import 'length.dart';
import 'length_unit.dart';

/// Provides convenient access to [Length] values in specific units
/// using shortened unit names where appropriate.
extension LengthValueGetters on Length {
  /// Returns the length value in Meters (m).
  double get inM => getValue(LengthUnit.meter);

  /// Returns the length value in Kilometers (km).
  double get inKm => getValue(LengthUnit.kilometer);

  /// Returns the length value in Centimeters (cm).
  double get inCm => getValue(LengthUnit.centimeter);

  /// Returns the length value in Millimeters (mm).
  double get inMm => getValue(LengthUnit.millimeter);

  /// Returns the length value in Inches (in).
  double get inInch => getValue(LengthUnit.inch);

  /// Returns the length value in Feet (ft).
  double get inFt => getValue(LengthUnit.foot);

  /// Returns the length value in Yards (yd).
  double get inYd => getValue(LengthUnit.yard);

  /// Returns the length value in Miles (mi).
  double get inMi => getValue(LengthUnit.mile);

  /// Returns the length value in Nautical Miles (nmi).
  double get inNmi => getValue(LengthUnit.nauticalMile);

  /// Returns a Length representing this length in Meters (m).
  Length get asM => convertTo(LengthUnit.meter);

  /// Returns a Length representing this length in Kilometers (km).
  Length get asKm => convertTo(LengthUnit.kilometer);

  /// Returns a Length representing this length in Centimeters (cm).
  Length get asCm => convertTo(LengthUnit.centimeter);

  /// Returns a Length representing this length in Millimeters (mm).
  Length get asMm => convertTo(LengthUnit.millimeter);

  /// Returns a Length representing this length in Inches (in).
  Length get asInch => convertTo(LengthUnit.inch);

  /// Returns a Length representing this length in Feet (ft).
  Length get asFt => convertTo(LengthUnit.foot);

  /// Returns a Length representing this length in Yards (yd).
  Length get asYd => convertTo(LengthUnit.yard);

  /// Returns a Length representing this length in Miles (mi).
  Length get asMi => convertTo(LengthUnit.mile);

  /// Returns a Length representing this length in Nautical Miles (nmi).
  Length get asNmi => convertTo(LengthUnit.nauticalMile);
}

/// Provides convenient factory methods for creating [Length] instances from [num]
/// using shortened unit names where appropriate.
extension LengthCreation on num {
  /// Creates a [Length] instance representing this numerical value in Meters (m).
  Length get m => Length(toDouble(), LengthUnit.meter);

  /// Creates a [Length] instance representing this numerical value in Kilometers (km).
  Length get km => Length(toDouble(), LengthUnit.kilometer);

  /// Creates a [Length] instance representing this numerical value in Centimeters (cm).
  Length get cm => Length(toDouble(), LengthUnit.centimeter);

  /// Creates a [Length] instance representing this numerical value in Millimeters (mm).
  Length get mm => Length(toDouble(), LengthUnit.millimeter);

  /// Creates a [Length] instance representing this numerical value in Inches (in).
  Length get inch => Length(toDouble(), LengthUnit.inch);

  /// Creates a [Length] instance representing this numerical value in Feet (ft).
  Length get ft => Length(toDouble(), LengthUnit.foot);

  /// Creates a [Length] instance representing this numerical value in Yards (yd).
  Length get yd => Length(toDouble(), LengthUnit.yard);

  /// Creates a [Length] instance representing this numerical value in Miles (mi).
  Length get mi => Length(toDouble(), LengthUnit.mile);

  /// Creates a [Length] instance representing this numerical value in Nautical Miles (nmi).
  Length get nmi => Length(toDouble(), LengthUnit.nauticalMile);

  // Longer aliases (can be added or chosen over short forms)
  // Length get meters => Length(toDouble(), LengthUnit.meter);
  // Length get kilometers => Length(toDouble(), LengthUnit.kilometer);
  // Length get centimeters => Length(toDouble(), LengthUnit.centimeter);
  // Length get millimeters => Length(toDouble(), LengthUnit.millimeter);
  // Length get inches => Length(toDouble(), LengthUnit.inch);
  // Length get feet => Length(toDouble(), LengthUnit.foot);
  // Length get yards => Length(toDouble(), LengthUnit.yard);
  // Length get miles => Length(toDouble(), LengthUnit.mile);
  // Length get nauticalMiles => Length(toDouble(), LengthUnit.nauticalMile);
}

<!-- END FILE: [v0.2.0] lib/src/units/length/length_extensions.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/length/length_factors.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

/// Defines base conversion factors for various length units relative to Meter.
///
/// These constants are based on international standards (e.g., NIST).
class LengthFactors {
  // The base unit for internal calculations is Meter.
  // Factors represent: 1 [Unit] = X [Meters]

  /// Meters per Kilometer: 1 kilometer = 1000.0 meters.
  static const double metersPerKilometer = 1000.0;

  /// Meters per Centimeter: 1 centimeter = 0.01 meters.
  static const double metersPerCentimeter = 0.01;

  /// Meters per Millimeter: 1 millimeter = 0.001 meters.
  static const double metersPerMillimeter = 0.001;

  /// Meters per Inch: 1 inch = 0.0254 meters (exact definition).
  static const double metersPerInch = 0.0254;

  /// Meters per Foot: 1 foot = 0.3048 meters (exact definition, as 1 foot = 12 inches).
  static const double metersPerFoot = 0.3048;

  /// Meters per Yard: 1 yard = 0.9144 meters (exact definition, as 1 yard = 3 feet).
  static const double metersPerYard = 0.9144;

  /// Meters per Mile: 1 mile = 1609.344 meters (exact definition, as 1 mile = 1760 yards).
  static const double metersPerMile = 1609.344;

  /// Meters per Nautical Mile: 1 nautical mile = 1852.0 meters (international definition).
  static const double metersPerNauticalMile = 1852.0;
}

<!-- END FILE: [v0.2.0] lib/src/units/length/length_factors.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/length/length_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'length_factors.dart';

/// Represents units of length.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each length unit.
/// All conversion factors are pre-calculated in the constructor relative to Meter.
enum LengthUnit implements Unit<LengthUnit> {
  /// Meter (m), the SI base unit of length.
  meter(1, 'm'),

  /// Kilometer (km), equal to 1000 meters.
  kilometer(LengthFactors.metersPerKilometer, 'km'),

  /// Centimeter (cm), equal to 0.01 meters.
  centimeter(LengthFactors.metersPerCentimeter, 'cm'),

  /// Millimeter (mm), equal to 0.001 meters.
  millimeter(LengthFactors.metersPerMillimeter, 'mm'),

  /// Inch (in), defined as exactly 0.0254 meters.
  inch(LengthFactors.metersPerInch, 'in'),

  /// Foot (ft), defined as exactly 0.3048 meters (12 inches).
  foot(LengthFactors.metersPerFoot, 'ft'),

  /// Yard (yd), defined as exactly 0.9144 meters (3 feet).
  yard(LengthFactors.metersPerYard, 'yd'),

  /// Mile (mi), defined as exactly 1609.344 meters (1760 yards).
  mile(LengthFactors.metersPerMile, 'mi'),

  /// Nautical Mile (nmi), internationally defined as 1852 meters.
  nauticalMile(LengthFactors.metersPerNauticalMile, 'nmi');

  /// Constant constructor for enum members.
  ///
  /// [toBaseFactor] is the factor to convert from this unit to the base unit (Meter).
  /// For Meter itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `LengthUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used.
  const LengthUnit(double toBaseFactor, this.symbol)
      : _toMeterFactor = toBaseFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        // factor_A_to_B = factor_A_to_Base / factor_B_to_Base
        // Here, Base is Meter. So, factor_A_to_Meter = _toMeterFactor_A / 1.0
        _factorToMeter = toBaseFactor / 1.0,
        _factorToKilometer = toBaseFactor / LengthFactors.metersPerKilometer,
        _factorToCentimeter = toBaseFactor / LengthFactors.metersPerCentimeter,
        _factorToMillimeter = toBaseFactor / LengthFactors.metersPerMillimeter,
        _factorToInch = toBaseFactor / LengthFactors.metersPerInch,
        _factorToFoot = toBaseFactor / LengthFactors.metersPerFoot,
        _factorToYard = toBaseFactor / LengthFactors.metersPerYard,
        _factorToMile = toBaseFactor / LengthFactors.metersPerMile,
        _factorToNauticalMile = toBaseFactor / LengthFactors.metersPerNauticalMile;

  /// The factor to convert a value from this unit to the base unit (Meter).
  /// Example: For Kilometer, this is 1000.0 (meaning 1 km = 1000.0 m).
  /// After constructor initialization, its value is primarily baked into
  /// the specific _factorToXxx fields for direct inter-unit conversions.
  /// It's generally not accessed directly by methods outside this enum's constructor
  /// but is crucial for deriving the pre-calculated factors.
  // ignore: unused_field
  final double _toMeterFactor;

  /// The human-readable symbol for this length unit (e.g., "m", "km").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  // These are calculated once in the const constructor.

  final double _factorToMeter;
  final double _factorToKilometer;
  final double _factorToCentimeter;
  final double _factorToMillimeter;
  final double _factorToInch;
  final double _factorToFoot;
  final double _factorToYard;
  final double _factorToMile;
  final double _factorToNauticalMile;

  /// Returns the direct conversion factor to convert a value from this [LengthUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(LengthUnit targetUnit) {
    switch (targetUnit) {
      case LengthUnit.meter:
        return _factorToMeter;
      case LengthUnit.kilometer:
        return _factorToKilometer;
      case LengthUnit.centimeter:
        return _factorToCentimeter;
      case LengthUnit.millimeter:
        return _factorToMillimeter;
      case LengthUnit.inch:
        return _factorToInch;
      case LengthUnit.foot:
        return _factorToFoot;
      case LengthUnit.yard:
        return _factorToYard;
      case LengthUnit.mile:
        return _factorToMile;
      case LengthUnit.nauticalMile:
        return _factorToNauticalMile;
    }
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/length/length_unit.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/luminous/luminous_intensity.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'luminous_intensity_unit.dart';

/// Represents a quantity of luminous intensity.
///
/// Luminous intensity is a measure of the wavelength-weighted power emitted
/// by a light source in a particular direction per unit solid angle, based on
/// the luminosity function, a standardized model of the sensitivity of the
/// human eye. The SI base unit for luminous intensity is the Candela (cd).
///
/// This class provides a type-safe way to handle luminous intensity values and
/// conversions between different units (e.g., candelas, millicandelas).
@immutable
class LuminousIntensity extends Quantity<LuminousIntensityUnit> {
  /// Creates a new `LuminousIntensity` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final ledBrightness = LuminousIntensity(150.0, LuminousIntensityUnit.millicandela);
  /// final headlightIntensity = LuminousIntensity(800.0, LuminousIntensityUnit.candela);
  /// ```
  const LuminousIntensity(super.value, super.unit);

  /// Converts this luminous intensity's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the
  /// `LuminousIntensityUnit` enum for efficiency.
  ///
  /// Example:
  /// ```dart
  /// final intensityInCd = LuminousIntensity(0.5, LuminousIntensityUnit.candela);
  /// final valueInMcd = intensityInCd.getValue(LuminousIntensityUnit.millicandela); // 500.0
  /// ```
  @override
  double getValue(LuminousIntensityUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [LuminousIntensity] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final intensityInMcd = LuminousIntensity(2500.0, LuminousIntensityUnit.millicandela);
  /// final intensityInCdObj = intensityInMcd.convertTo(LuminousIntensityUnit.candela);
  /// // intensityInCdObj is LuminousIntensity(2.5, LuminousIntensityUnit.candela)
  /// print(intensityInCdObj); // Output: "2.5 cd"
  /// ```
  @override
  LuminousIntensity convertTo(LuminousIntensityUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return LuminousIntensity(newValue, targetUnit);
  }

  /// Compares this [LuminousIntensity] object to another [Quantity<LuminousIntensityUnit>].
  ///
  /// Comparison is based on the physical magnitude of the luminous intensities.
  ///
  /// Example:
  /// ```dart
  /// final li1 = LuminousIntensity(1.0, LuminousIntensityUnit.candela);      // 1000 mcd
  /// final li2 = LuminousIntensity(1000.0, LuminousIntensityUnit.millicandela); // 1000 mcd
  /// final li3 = LuminousIntensity(0.5, LuminousIntensityUnit.candela);     // 500 mcd
  ///
  /// print(li1.compareTo(li2)); // 0 (equal magnitude)
  /// print(li1.compareTo(li3)); // 1 (li1 > li3)
  /// ```
  @override
  int compareTo(Quantity<LuminousIntensityUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this luminous intensity to another luminous intensity.
  ///
  /// This is physically meaningful if, for example, combining light from multiple
  /// sources in the same direction (though solid angle considerations can be complex).
  /// The [other] intensity is converted to the unit of this intensity before addition.
  ///
  /// Example:
  /// ```dart
  /// final sourceA = LuminousIntensity(100.0, LuminousIntensityUnit.candela);
  /// final sourceB = LuminousIntensity(50000.0, LuminousIntensityUnit.millicandela); // 50 cd
  /// final combinedIntensity = sourceA + sourceB; // Result: LuminousIntensity(150.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator +(LuminousIntensity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return LuminousIntensity(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another luminous intensity from this luminous intensity.
  ///
  /// This could represent the reduction in intensity if one source is removed or shielded.
  /// The [other] intensity is converted to the unit of this intensity before subtraction.
  ///
  /// Example:
  /// ```dart
  /// final totalLight = LuminousIntensity(500.0, LuminousIntensityUnit.candela);
  /// final blockedLight = LuminousIntensity(150.0, LuminousIntensityUnit.candela);
  /// final remainingLight = totalLight - blockedLight; // Result: LuminousIntensity(350.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator -(LuminousIntensity other) {
    final otherValueInThisUnit = other.getValue(unit);
    return LuminousIntensity(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this luminous intensity by a scalar value (a dimensionless number).
  ///
  /// Example:
  /// ```dart
  /// final singleLed = LuminousIntensity(20.0, LuminousIntensityUnit.millicandela);
  /// final arrayBrightness = singleLed * 10.0; // Result: LuminousIntensity(200.0, LuminousIntensityUnit.millicandela)
  /// ```
  LuminousIntensity operator *(double scalar) {
    return LuminousIntensity(value * scalar, unit);
  }

  /// Divides this luminous intensity by a scalar value (a dimensionless number).
  ///
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalOutput = LuminousIntensity(1000.0, LuminousIntensityUnit.candela);
  /// final outputPerSegment = totalOutput / 5.0; // Result: LuminousIntensity(200.0, LuminousIntensityUnit.candela)
  /// ```
  LuminousIntensity operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return LuminousIntensity(value / scalar, unit);
  }

  // Potential future enhancements:
  // - LuminousIntensity * SolidAngle = LuminousFlux (would require SolidAngle type or representation)
  // - LuminousIntensity / Area = Luminance (would require Area type)
}

<!-- END FILE: [v0.2.0] lib/src/units/luminous/luminous_intensity.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/luminous/luminous_intensity_extensions.dart -->
import 'luminous_intensity.dart';
import 'luminous_intensity_unit.dart';

/// Provides convenient access to [LuminousIntensity] values in specific units
/// using getter properties.
extension LuminousIntensityValueGetters on LuminousIntensity {
  /// Returns the luminous intensity value in Candelas (cd).
  double get inCandelas => getValue(LuminousIntensityUnit.candela);

  /// Returns the luminous intensity value in Millicandelas (mcd).
  double get inMillicandelas => getValue(LuminousIntensityUnit.millicandela);

  /// Returns the luminous intensity value in Kilocandelas (kcd).
  double get inKilocandelas => getValue(LuminousIntensityUnit.kilocandela);

  // --- "As" Getters for new LuminousIntensity objects ---

  /// Returns a new [LuminousIntensity] object representing this intensity in Candelas (cd).
  LuminousIntensity get asCandelas => convertTo(LuminousIntensityUnit.candela);

  /// Returns a new [LuminousIntensity] object representing this intensity in Millicandelas (mcd).
  LuminousIntensity get asMillicandelas => convertTo(LuminousIntensityUnit.millicandela);

  /// Returns a new [LuminousIntensity] object representing this intensity in Kilocandelas (kcd).
  LuminousIntensity get asKilocandelas => convertTo(LuminousIntensityUnit.kilocandela);
}

/// Provides convenient factory methods for creating [LuminousIntensity] instances from [num]
/// using getter properties named after common unit symbols or names.
extension LuminousIntensityCreation on num {
  /// Creates a [LuminousIntensity] instance from this numerical value in Candelas (cd).
  LuminousIntensity get cd => LuminousIntensity(toDouble(), LuminousIntensityUnit.candela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Candelas (cd).
  /// Alias for `cd`.
  LuminousIntensity get candelas => LuminousIntensity(toDouble(), LuminousIntensityUnit.candela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Millicandelas (mcd).
  LuminousIntensity get mcd => LuminousIntensity(toDouble(), LuminousIntensityUnit.millicandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Millicandelas (mcd).
  /// Alias for `mcd`.
  LuminousIntensity get millicandelas =>
      LuminousIntensity(toDouble(), LuminousIntensityUnit.millicandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Kilocandelas (kcd).
  LuminousIntensity get kcd => LuminousIntensity(toDouble(), LuminousIntensityUnit.kilocandela);

  /// Creates a [LuminousIntensity] instance from this numerical value in Kilocandelas (kcd).
  /// Alias for `kcd`.
  LuminousIntensity get kilocandelas =>
      LuminousIntensity(toDouble(), LuminousIntensityUnit.kilocandela);
}

<!-- END FILE: [v0.2.0] lib/src/units/luminous/luminous_intensity_extensions.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/luminous/luminous_intensity_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

/// Defines base conversion factors for various luminous intensity units relative
/// to the Candela (cd), which is the SI base unit for luminous intensity.
///
/// These constants represent: `1 [Unit] = Z [Candelas]`.
/// So, `candelasPerMillicandela` means `1 millicandela = candelasPerMillicandela candelas`.
class LuminousIntensityFactors {
  // --- SI Prefixed Units (relative to Candela) ---

  /// Candelas per Millicandela: 1 millicandela (mcd) = 0.001 candelas (cd).
  static const double candelasPerMillicandela = 0.001;

  /// Candelas per Kilocandela: 1 kilocandela (kcd) = 1000 candelas (cd).
  /// Note: Kilocandela is a valid SI unit but less commonly used in practice
  /// compared to candela or millicandela for typical light sources.
  static const double candelasPerKilocandela = 1000.0;

  // --- Other historical or specialized units (less common) ---
  // Example: Hefnerkerze (HK) or Hefner candle, an old German unit of luminous intensity.
  // 1 HK ‚âà 0.903 cd.
  // static const double candelasPerHefnerCandle = 0.903;

  // Example: Carcel, an old French unit.
  // 1 Carcel ‚âà 9.74 cd (varies by definition).
  // static const double candelasPerCarcel = 9.74;

  // For a primary SI base unit like Candela, prefixed versions are the most relevant.
  // Other units are typically for historical context or very specialized applications.
  // Focusing on SI prefixed units for the core implementation.
}

<!-- END FILE: [v0.2.0] lib/src/units/luminous/luminous_intensity_factors.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/luminous/luminous_intensity_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'luminous_intensity_factors.dart';

/// Represents units for luminous intensity.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each luminous intensity unit.
/// All conversion factors are pre-calculated in the constructor relative to Candela (cd),
/// which is the SI base unit for luminous intensity.
enum LuminousIntensityUnit implements Unit<LuminousIntensityUnit> {
  /// Candela (cd), the SI base unit of luminous intensity.
  /// It is defined by taking the fixed numerical value of the luminous efficacy
  /// of monochromatic radiation of frequency 540 √ó 10¬π¬≤ Hz, Kcd, to be 683
  /// when expressed in the unit lm W‚Åª¬π, which is equal to cd sr W‚Åª¬π or
  /// cd sr kg‚Åª¬π m‚Åª¬≤ s¬≥.
  candela(1, 'cd'),

  /// Millicandela (mcd), equal to 0.001 candelas.
  /// Commonly used for LEDs and indicator lights.
  millicandela(LuminousIntensityFactors.candelasPerMillicandela, 'mcd'),

  /// Kilocandela (kcd), equal to 1000 candelas.
  /// A less common unit, might be used for very high-intensity light sources
  /// like searchlights or lighthouses.
  kilocandela(LuminousIntensityFactors.candelasPerKilocandela, 'kcd');

  // If Hefnerkerze were to be added:
  // /// Hefnerkerze (HK) or Hefner candle, an old German unit.
  // /// 1 HK ‚âà 0.903 cd.
  // hefnerCandle(LuminousIntensityFactors.candelasPerHefnerCandle, 'HK');

  /// Constant constructor for enum members.
  ///
  /// [_toCandelaFactor] is the factor to convert from this unit to the base unit (Candela).
  /// For Candela itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `LuminousIntensityUnit`.
  const LuminousIntensityUnit(double toCandelaFactor, this.symbol)
      : _toCandelaFactor = toCandelaFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToCandela = toCandelaFactor / 1.0, // Base unit factor for candela is 1.0
        _factorToMillicandela = toCandelaFactor / LuminousIntensityFactors.candelasPerMillicandela,
        _factorToKilocandela = toCandelaFactor / LuminousIntensityFactors.candelasPerKilocandela;
  // If hefnerCandle were added:
  // _factorToHefnerCandle = toCandelaFactor / LuminousIntensityFactors.candelasPerHefnerCandle;

  /// The factor to convert a value from this unit to the base unit (Candela).
  /// Example: For Millicandela, this is 0.001 (meaning 1 mcd = 0.001 cd).
  /// This field is primarily used internally by the constructor.
  // ignore: unused_field
  final double _toCandelaFactor;

  /// The human-readable symbol for this luminous intensity unit (e.g., "cd", "mcd").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToCandela;
  final double _factorToMillicandela;
  final double _factorToKilocandela;
  // If hefnerCandle were added:
  // final double _factorToHefnerCandle;

  /// Returns the direct conversion factor to convert a value from this [LuminousIntensityUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `LuminousIntensity`
  /// class for conversions.
  @override
  @internal
  double factorTo(LuminousIntensityUnit targetUnit) {
    switch (targetUnit) {
      case LuminousIntensityUnit.candela:
        return _factorToCandela;
      case LuminousIntensityUnit.millicandela:
        return _factorToMillicandela;
      case LuminousIntensityUnit.kilocandela:
        return _factorToKilocandela;
      // If hefnerCandle were added:
      // case LuminousIntensityUnit.hefnerCandle:
      //  return _factorToHefnerCandle;
    }
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/luminous/luminous_intensity_unit.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/mass/mass.dart -->
// BEGIN FILE: lib/src/units/mass/mass.dart
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'mass_unit.dart';

/// Represents a quantity of mass.
///
/// Mass is a fundamental physical property of matter. It is a measure of an
/// object's resistance to acceleration (a change in its state of motion)
/// when a net force is applied. It also determines the strength of its
/// mutual gravitational attraction to other bodies. The SI base unit of mass
/// is the Kilogram (kg).
///
/// This class provides a type-safe way to handle mass values and conversions
/// between different units of mass (e.g., kilograms, grams, pounds, ounces).
@immutable
class Mass extends Quantity<MassUnit> {
  /// Creates a new `Mass` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final personWeightKg = Mass(70.0, MassUnit.kilogram);
  /// final sugarAmountGrams = Mass(500.0, MassUnit.gram);
  /// final packageWeightLbs = Mass(5.0, MassUnit.pound);
  /// ```
  const Mass(super.value, super.unit);

  /// Converts this mass's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `MassUnit`
  /// enum for efficiency, typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final weightInKg = Mass(1.0, MassUnit.kilogram);
  /// final weightInGramsValue = weightInKg.getValue(MassUnit.gram); // 1000.0
  ///
  /// final weightInLbs = Mass(2.20462, MassUnit.pound);
  /// final weightInKgValue = weightInLbs.getValue(MassUnit.kilogram); // approx 1.0
  /// ```
  @override
  double getValue(MassUnit targetUnit) {
    // If the target unit is the same as the current unit, no conversion is needed.
    if (targetUnit == unit) return value;
    // Otherwise, multiply by the direct conversion factor.
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Mass] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Mass` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final weightInGrams = Mass(1500.0, MassUnit.gram);
  /// final weightInKilogramsObj = weightInGrams.convertTo(MassUnit.kilogram);
  /// // weightInKilogramsObj is Mass(1.5, MassUnit.kilogram)
  /// print(weightInKilogramsObj); // Output: "1.5 kg" (depending on toString formatting)
  /// ```
  @override
  Mass convertTo(MassUnit targetUnit) {
    // If the target unit is the same, return this instance (immutable optimization).
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Mass(newValue, targetUnit);
  }

  /// Compares this [Mass] object to another [Quantity<MassUnit>].
  ///
  /// Comparison is based on the physical magnitude of the masses.
  /// For an accurate comparison, this mass's value is converted to the unit
  /// of the [other] mass before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this mass is less than [other].
  /// - Zero if this mass is equal in magnitude to [other].
  /// - A positive integer if this mass is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final m1 = Mass(1.0, MassUnit.kilogram);    // 1000 g
  /// final m2 = Mass(1000.0, MassUnit.gram);    // 1000 g
  /// final m3 = Mass(2.0, MassUnit.pound);     // approx 907.18 g
  ///
  /// print(m1.compareTo(m2)); // 0 (equal magnitude)
  /// print(m1.compareTo(m3)); // 1 (m1 > m3, since 1kg > 2lb)
  /// print(m3.compareTo(m1)); // -1 (m3 < m1)
  /// ```
  @override
  int compareTo(Quantity<MassUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison of their magnitudes.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this mass to another mass.
  ///
  /// The [other] mass is converted to the unit of this mass before addition.
  /// The result is a new [Mass] instance with the sum, expressed in the unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final item1 = Mass(1.5, MassUnit.kilogram);
  /// final item2 = Mass(500.0, MassUnit.gram); // 0.5 kg
  /// final totalMass = item1 + item2; // Result: Mass(2.0, MassUnit.kilogram)
  /// ```
  Mass operator +(Mass other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Mass(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another mass from this mass.
  ///
  /// The [other] mass is converted to the unit of this mass before subtraction.
  /// The result is a new [Mass] instance with the difference, expressed in the unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final containerWithContents = Mass(5.0, MassUnit.kilogram);
  /// final contents = Mass(1500.0, MassUnit.gram); // 1.5 kg
  /// final emptyContainer = containerWithContents - contents; // Result: Mass(3.5, MassUnit.kilogram)
  /// ```
  Mass operator -(Mass other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Mass(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this mass by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Mass] instance with the scaled value, in the original unit of this mass.
  ///
  /// Example:
  /// ```dart
  /// final singleItemMass = Mass(0.25, MassUnit.kilogram);
  /// final massOfFourItems = singleItemMass * 4.0; // Result: Mass(1.0, MassUnit.kilogram)
  /// ```
  Mass operator *(double scalar) {
    return Mass(value * scalar, unit);
  }

  /// Divides this mass by a scalar value (a dimensionless number).
  ///
  /// Returns a new [Mass] instance with the scaled value, in the original unit of this mass.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalMass = Mass(10.0, MassUnit.kilogram);
  /// final massPerPortion = totalMass / 5.0; // Result: Mass(2.0, MassUnit.kilogram)
  /// ```
  Mass operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Mass(value / scalar, unit);
  }

  // Potential future enhancement:
  // Mass / Volume = Density (would require a Density quantity type)
  // Mass * Acceleration = Force (would require Force and Acceleration types)
}

<!-- END FILE: [v0.2.0] lib/src/units/mass/mass.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/mass/mass_extensions.dart -->
import 'mass.dart';
import 'mass_unit.dart';

/// Provides convenient access to [Mass] values in specific units
/// using getter properties.
///
/// These getters simplify retrieving the numerical value of a mass
/// in a desired unit without explicitly calling `getValue()`.
extension MassValueGetters on Mass {
  /// Returns the mass value in Kilograms (kg).
  double get inKilograms => getValue(MassUnit.kilogram);

  /// Returns the mass value in Grams (g).
  double get inGrams => getValue(MassUnit.gram);

  /// Returns the mass value in Milligrams (mg).
  double get inMilligrams => getValue(MassUnit.milligram);

  /// Returns the mass value in Tonnes (t, metric tons).
  double get inTonnes => getValue(MassUnit.tonne);

  /// Returns the mass value in Pounds (lb).
  double get inPounds => getValue(MassUnit.pound);

  /// Returns the mass value in Ounces (oz).
  double get inOunces => getValue(MassUnit.ounce);

  /// Returns the mass value in Stones (st).
  double get inStones => getValue(MassUnit.stone);

  /// Returns the mass value in Slugs (slug).
  double get inSlugs => getValue(MassUnit.slug);

  // --- "As" Getters for new Mass objects ---

  /// Returns a new [Mass] object representing this mass in Kilograms (kg).
  Mass get asKilograms => convertTo(MassUnit.kilogram);

  /// Returns a new [Mass] object representing this mass in Grams (g).
  Mass get asGrams => convertTo(MassUnit.gram);

  /// Returns a new [Mass] object representing this mass in Milligrams (mg).
  Mass get asMilligrams => convertTo(MassUnit.milligram);

  /// Returns a new [Mass] object representing this mass in Tonnes (t).
  Mass get asTonnes => convertTo(MassUnit.tonne);

  /// Returns a new [Mass] object representing this mass in Pounds (lb).
  Mass get asPounds => convertTo(MassUnit.pound);

  /// Returns a new [Mass] object representing this mass in Ounces (oz).
  Mass get asOunces => convertTo(MassUnit.ounce);

  /// Returns a new [Mass] object representing this mass in Stones (st).
  Mass get asStones => convertTo(MassUnit.stone);

  /// Returns a new [Mass] object representing this mass in Slugs (slug).
  Mass get asSlugs => convertTo(MassUnit.slug);
}

/// Provides convenient factory methods for creating [Mass] instances from [num]
/// using getter properties named after common unit symbols or names.
///
/// This allows for an intuitive and concise way to create mass quantities,
/// for example: `70.kg` or `500.grams`.
extension MassCreation on num {
  /// Creates a [Mass] instance representing this numerical value in Kilograms (kg).
  Mass get kg => Mass(toDouble(), MassUnit.kilogram);

  /// Creates a [Mass] instance representing this numerical value in Grams (g).
  Mass get g => Mass(toDouble(), MassUnit.gram);

  /// Creates a [Mass] instance representing this numerical value in Grams (g).
  /// Alias for `g`.
  Mass get grams => Mass(toDouble(), MassUnit.gram);

  /// Creates a [Mass] instance representing this numerical value in Milligrams (mg).
  Mass get mg => Mass(toDouble(), MassUnit.milligram);

  /// Creates a [Mass] instance representing this numerical value in Milligrams (mg).
  /// Alias for `mg`.
  Mass get milligrams => Mass(toDouble(), MassUnit.milligram);

  /// Creates a [Mass] instance representing this numerical value in Tonnes (t, metric tons).
  Mass get t => Mass(toDouble(), MassUnit.tonne);

  /// Creates a [Mass] instance representing this numerical value in Tonnes (t, metric tons).
  /// Alias for `t`.
  Mass get tonnes => Mass(toDouble(), MassUnit.tonne);

  /// Creates a [Mass] instance representing this numerical value in Pounds (lb).
  Mass get lb => Mass(toDouble(), MassUnit.pound);

  /// Creates a [Mass] instance representing this numerical value in Pounds (lb).
  /// Alias for `lb`.
  Mass get pounds => Mass(toDouble(), MassUnit.pound);

  /// Creates a [Mass] instance representing this numerical value in Ounces (oz).
  Mass get oz => Mass(toDouble(), MassUnit.ounce);

  /// Creates a [Mass] instance representing this numerical value in Ounces (oz).
  /// Alias for `oz`.
  Mass get ounces => Mass(toDouble(), MassUnit.ounce);

  /// Creates a [Mass] instance representing this numerical value in Stones (st).
  Mass get st => Mass(toDouble(), MassUnit.stone);

  /// Creates a [Mass] instance representing this numerical value in Stones (st).
  /// Alias for `st`.
  Mass get stones => Mass(toDouble(), MassUnit.stone);

  /// Creates a [Mass] instance representing this numerical value in Slugs (slug).
  Mass get slugs => Mass(toDouble(), MassUnit.slug);
}

<!-- END FILE: [v0.2.0] lib/src/units/mass/mass_extensions.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/mass/mass_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

import '../../../quantify.dart' show Unit;
import '../../core/unit.dart' show Unit;

/// Defines base conversion factors for various mass units relative to the Kilogram (kg),
/// which is the SI base unit for mass.
///
/// These constants are based on international standards and exact definitions where available
/// (e.g., the international avoirdupois pound).
///
/// The structure `X_per_Y` means "how many X are in one Y".
/// However, for consistency with how factors are used (1 [Unit] = X BaseUnit),
/// these constants represent: `1 [Unit] = Z [Kilograms]`.
/// So, `kilogramsPerGram` means `1 gram = kilogramsPerGram kilograms`.
class MassFactors {
  // --- SI Units (relative to Kilogram) ---

  /// Kilograms per Gram: 1 gram = 0.001 kilograms.
  static const double kilogramsPerGram = 0.001;

  /// Kilograms per Milligram: 1 milligram = 0.000001 kilograms.
  /// (1 mg = 0.001 g, and 1 g = 0.001 kg)
  static const double kilogramsPerMilligram = kilogramsPerGram * 0.001;

  /// Kilograms per Tonne (Metric Ton): 1 tonne = 1000 kilograms.
  static const double kilogramsPerTonne = 1000.0;

  // --- Imperial / US Customary Units (relative to Kilogram) ---

  /// Kilograms per Pound (Avoirdupois): 1 pound = 0.45359237 kilograms.
  /// This is an exact definition based on the international pound and yard agreement of 1959.
  static const double kilogramsPerPound = 0.45359237;

  /// Kilograms per Ounce (Avoirdupois): 1 ounce = 1/16 pound.
  /// 1 ounce = (0.45359237 / 16) kilograms.
  static const double kilogramsPerOunce = kilogramsPerPound / 16.0;

  /// Kilograms per Stone: 1 stone = 14 pounds.
  /// 1 stone = (14 * 0.45359237) kilograms.
  static const double kilogramsPerStone = kilogramsPerPound * 14.0;

  /// Kilograms per Slug: 1 slug ‚âà 14.5939029372 kilograms.
  /// The slug is a unit of mass in the gravitational systems of units,
  /// defined as the mass that accelerates by 1 ft/s¬≤ when a force of one pound-force (lbf)
  /// is exerted on it.
  /// 1 slug = 1 lbf‚ãÖs¬≤/ft.
  /// Using g‚ÇÄ = 9.80665 m/s¬≤ (standard gravity) and 1 ft = 0.3048 m:
  /// 1 lbf = 0.45359237 kg * 9.80665 m/s¬≤ (force)
  /// 1 slug = (0.45359237 * 9.80665) / 0.3048 kg (approx, if derived from lbf definition relative to kg-mass and g0)
  /// A more commonly cited direct conversion factor for slug to kg is used here.
  /// For example, NIST Special Publication 811 (2008 edition), Appendix B.8, lists:
  /// slug -> 1.459 390 E+01 kg
  static const double kilogramsPerSlug = 14.5939029372;

  // --- Other common units (can be added if needed) ---
  // Example: Carat (for gemstones)
  // /// Kilograms per Carat (metric): 1 carat = 0.0002 kilograms (0.2 grams).
  // static const double kilogramsPerCarat = 0.0002;
}

<!-- END FILE: [v0.2.0] lib/src/units/mass/mass_factors.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/mass/mass_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'mass_factors.dart';

/// Represents units of mass.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each mass unit.
/// All conversion factors are pre-calculated in the constructor relative to Kilogram (kg),
/// which is the SI base unit for mass.
enum MassUnit implements Unit<MassUnit> {
  /// Kilogram (kg), the SI base unit of mass.
  kilogram(1, 'kg'),

  /// Gram (g), equal to 0.001 kilograms.
  gram(MassFactors.kilogramsPerGram, 'g'),

  /// Milligram (mg), equal to 0.000001 kilograms (or 0.001 grams).
  milligram(MassFactors.kilogramsPerMilligram, 'mg'),

  /// Tonne (metric ton) (t), equal to 1000 kilograms.
  tonne(MassFactors.kilogramsPerTonne, 't'),

  /// Pound (lb), an avoirdupois pound, defined as exactly 0.45359237 kilograms.
  pound(MassFactors.kilogramsPerPound, 'lb'),

  /// Ounce (oz), an avoirdupois ounce, defined as 1/16 of an avoirdupois pound.
  ounce(MassFactors.kilogramsPerOunce, 'oz'),

  /// Stone (st), a unit of weight in the imperial system, equal to 14 pounds.
  stone(MassFactors.kilogramsPerStone, 'st'),

  /// Slug, a unit of mass in the British Imperial and US customary systems,
  /// defined as the mass that accelerates by 1 ft/s¬≤ when a force of one pound-force (lbf) is exerted on it.
  /// 1 slug ‚âà 14.59390 kilograms.
  slug(MassFactors.kilogramsPerSlug, 'slug');

  /// Constant constructor for enum members.
  ///
  /// [_toKilogramFactor] is the factor to convert from this unit to the base unit (Kilogram).
  /// For Kilogram itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `MassUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used,
  /// where the base unit is Kilogram.
  const MassUnit(double toKilogramFactor, this.symbol)
      : _toKilogramFactor = toKilogramFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        // factor_A_to_B = factor_A_to_Base / factor_B_to_Base
        // Here, Base is Kilogram. So, factor_A_to_Kilogram = _toKilogramFactor_A / 1.0
        _factorToKilogram = toKilogramFactor / 1.0, // Base unit factor for kilogram is 1.0
        _factorToGram = toKilogramFactor / MassFactors.kilogramsPerGram,
        _factorToMilligram = toKilogramFactor / MassFactors.kilogramsPerMilligram,
        _factorToTonne = toKilogramFactor / MassFactors.kilogramsPerTonne,
        _factorToPound = toKilogramFactor / MassFactors.kilogramsPerPound,
        _factorToOunce = toKilogramFactor / MassFactors.kilogramsPerOunce,
        _factorToStone = toKilogramFactor / MassFactors.kilogramsPerStone,
        _factorToSlug = toKilogramFactor / MassFactors.kilogramsPerSlug;

  /// The factor to convert a value from this unit to the base unit (Kilogram).
  /// Example: For Gram, this is 0.001 (meaning 1 g = 0.001 kg).
  /// After constructor initialization, its value is primarily baked into
  /// the specific _factorToXxx fields for direct inter-unit conversions.
  /// It's generally not accessed directly by methods outside this enum's constructor
  /// but is crucial for deriving the pre-calculated factors.
  // ignore: unused_field
  final double _toKilogramFactor;

  /// The human-readable symbol for this mass unit (e.g., "kg", "g", "lb").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  // These are calculated once in the const constructor for performance.

  final double _factorToKilogram;
  final double _factorToGram;
  final double _factorToMilligram;
  final double _factorToTonne;
  final double _factorToPound;
  final double _factorToOunce;
  final double _factorToStone;
  final double _factorToSlug;

  /// Returns the direct conversion factor to convert a value from this [MassUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `Mass`
  /// class for conversions.
  ///
  /// Example: `MassUnit.gram.factorTo(MassUnit.kilogram)` would return `0.001`.
  /// `MassUnit.kilogram.factorTo(MassUnit.gram)` would return `1000.0`.
  ///
  /// - [targetUnit]: The `MassUnit` to which a value should be converted.
  ///
  /// Returns the multiplication factor.
  @override
  @internal
  double factorTo(MassUnit targetUnit) {
    switch (targetUnit) {
      case MassUnit.kilogram:
        return _factorToKilogram;
      case MassUnit.gram:
        return _factorToGram;
      case MassUnit.milligram:
        return _factorToMilligram;
      case MassUnit.tonne:
        return _factorToTonne;
      case MassUnit.pound:
        return _factorToPound;
      case MassUnit.ounce:
        return _factorToOunce;
      case MassUnit.stone:
        return _factorToStone;
      case MassUnit.slug:
        return _factorToSlug;
    }
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/mass/mass_unit.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/molar/molar_amount.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'molar_unit.dart';

/// Represents a quantity of amount of substance, typically measured in moles.
///
/// The amount of substance is a measure of the number of elementary entities
/// (such as atoms, molecules, ions, or electrons) in a sample. The SI base unit
/// for amount of substance is the Mole (mol).
///
/// This class provides a type-safe way to handle molar amount values and
/// conversions between different units (e.g., moles, millimoles, kilomoles).
/// It is fundamental in chemistry and related fields.
@immutable
class MolarAmount extends Quantity<MolarUnit> {
  /// Creates a new `MolarAmount` quantity with the given numerical [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final glucoseSample = MolarAmount(0.5, MolarUnit.mole);
  /// final reagentAmount = MolarAmount(25.0, MolarUnit.millimole);
  /// ```
  const MolarAmount(super.value, super.unit);

  /// Converts this molar amount's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors from the `MolarUnit`
  /// enum for efficiency, involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final substanceInMoles = MolarAmount(0.05, MolarUnit.mole);
  /// final valueInMillimoles = substanceInMoles.getValue(MolarUnit.millimole); // 50.0
  /// ```
  @override
  double getValue(MolarUnit targetUnit) {
    // If the target unit is the same as the current unit, no conversion is needed.
    if (targetUnit == unit) return value;
    // Otherwise, multiply by the direct conversion factor.
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [MolarAmount] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `MolarAmount` object in a different unit
  /// while preserving type safety and the immutability of `Quantity` objects.
  ///
  /// Example:
  /// ```dart
  /// final amountInMillimoles = MolarAmount(1500.0, MolarUnit.millimole);
  /// final amountInMolesObj = amountInMillimoles.convertTo(MolarUnit.mole);
  /// // amountInMolesObj is MolarAmount(1.5, MolarUnit.mole)
  /// print(amountInMolesObj); // Output: "1.5 mol" (depending on toString formatting)
  /// ```
  @override
  MolarAmount convertTo(MolarUnit targetUnit) {
    // If the target unit is the same, return this instance (immutable optimization).
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return MolarAmount(newValue, targetUnit);
  }

  /// Compares this [MolarAmount] object to another [Quantity<MolarUnit>].
  ///
  /// Comparison is based on the physical magnitude of the amounts of substance.
  /// For an accurate comparison, this molar amount's value is converted to the unit
  /// of the [other] molar amount before their numerical values are compared.
  ///
  /// Returns:
  /// - A negative integer if this molar amount is less than [other].
  /// - Zero if this molar amount is equal in magnitude to [other].
  /// - A positive integer if this molar amount is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final ma1 = MolarAmount(1.0, MolarUnit.mole);      // 1000 mmol
  /// final ma2 = MolarAmount(1000.0, MolarUnit.millimole); // 1000 mmol
  /// final ma3 = MolarAmount(0.5, MolarUnit.mole);     // 500 mmol
  ///
  /// print(ma1.compareTo(ma2)); // 0 (equal magnitude)
  /// print(ma1.compareTo(ma3)); // 1 (ma1 > ma3)
  /// print(ma3.compareTo(ma1)); // -1 (ma3 < ma1)
  /// ```
  @override
  int compareTo(Quantity<MolarUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison of their magnitudes.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this molar amount to another molar amount.
  ///
  /// The [other] molar amount is converted to the unit of this molar amount before addition.
  /// The result is a new [MolarAmount] instance with the sum, expressed in the unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final reagentA = MolarAmount(0.2, MolarUnit.mole);
  /// final reagentB = MolarAmount(150.0, MolarUnit.millimole); // 0.15 mol
  /// final totalAmount = reagentA + reagentB; // Result: MolarAmount(0.35, MolarUnit.mole)
  /// ```
  MolarAmount operator +(MolarAmount other) {
    final otherValueInThisUnit = other.getValue(unit);
    return MolarAmount(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another molar amount from this molar amount.
  ///
  /// The [other] molar amount is converted to the unit of this molar amount before subtraction.
  /// The result is a new [MolarAmount] instance with the difference, expressed in the unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final initialAmount = MolarAmount(1.0, MolarUnit.mole);
  /// final amountUsed = MolarAmount(250.0, MolarUnit.millimole); // 0.25 mol
  /// final remainingAmount = initialAmount - amountUsed; // Result: MolarAmount(0.75, MolarUnit.mole)
  /// ```
  MolarAmount operator -(MolarAmount other) {
    final otherValueInThisUnit = other.getValue(unit);
    return MolarAmount(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this molar amount by a scalar value (a dimensionless number).
  ///
  /// Returns a new [MolarAmount] instance with the scaled value, in the original unit of this molar amount.
  ///
  /// Example:
  /// ```dart
  /// final singleReactionAmount = MolarAmount(0.05, MolarUnit.mole);
  /// final amountForTenReactions = singleReactionAmount * 10.0; // Result: MolarAmount(0.5, MolarUnit.mole)
  /// ```
  MolarAmount operator *(double scalar) {
    return MolarAmount(value * scalar, unit);
  }

  /// Divides this molar amount by a scalar value (a dimensionless number).
  ///
  /// Returns a new [MolarAmount] instance with the scaled value, in the original unit of this molar amount.
  /// Throws [ArgumentError] if the [scalar] is zero.
  ///
  /// Example:
  /// ```dart
  /// final totalStock = MolarAmount(2.0, MolarUnit.mole);
  /// final amountPerAliquot = totalStock / 20.0; // Result: MolarAmount(0.1, MolarUnit.mole)
  /// ```
  MolarAmount operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return MolarAmount(value / scalar, unit);
  }

  // Potential future enhancements for MolarAmount:
  // - MolarAmount / Volume = MolarConcentration (would require Volume and MolarConcentration types)
  // - Mass / MolarAmount = MolarMass (would require Mass and MolarMass types or a way to handle compound units)
}

<!-- END FILE: [v0.2.0] lib/src/units/molar/molar_amount.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/molar/molar_extensions.dart -->
import 'molar_amount.dart';
import 'molar_unit.dart';

/// Provides convenient access to [MolarAmount] values in specific units
/// using getter properties.
///
/// These getters simplify retrieving the numerical value of a molar amount
/// in a desired unit without explicitly calling `getValue()`.
extension MolarAmountValueGetters on MolarAmount {
  /// Returns the molar amount value in Moles (mol).
  double get inMoles => getValue(MolarUnit.mole);

  /// Returns the molar amount value in Millimoles (mmol).
  double get inMillimoles => getValue(MolarUnit.millimole);

  /// Returns the molar amount value in Micromoles (¬µmol).
  double get inMicromoles => getValue(MolarUnit.micromole);

  /// Returns the molar amount value in Nanomoles (nmol).
  double get inNanomoles => getValue(MolarUnit.nanomole);

  /// Returns the molar amount value in Picomoles (pmol).
  double get inPicomoles => getValue(MolarUnit.picomole);

  /// Returns the molar amount value in Kilomoles (kmol).
  double get inKilomoles => getValue(MolarUnit.kilomole);

  // --- "As" Getters for new MolarAmount objects ---

  /// Returns a new [MolarAmount] object representing this amount in Moles (mol).
  MolarAmount get asMoles => convertTo(MolarUnit.mole);

  /// Returns a new [MolarAmount] object representing this amount in Millimoles (mmol).
  MolarAmount get asMillimoles => convertTo(MolarUnit.millimole);

  /// Returns a new [MolarAmount] object representing this amount in Micromoles (¬µmol).
  MolarAmount get asMicromoles => convertTo(MolarUnit.micromole);

  /// Returns a new [MolarAmount] object representing this amount in Nanomoles (nmol).
  MolarAmount get asNanomoles => convertTo(MolarUnit.nanomole);

  /// Returns a new [MolarAmount] object representing this amount in Picomoles (pmol).
  MolarAmount get asPicomoles => convertTo(MolarUnit.picomole);

  /// Returns a new [MolarAmount] object representing this amount in Kilomoles (kmol).
  MolarAmount get asKilomoles => convertTo(MolarUnit.kilomole);
}

/// Provides convenient factory methods for creating [MolarAmount] instances from [num]
/// using getter properties named after common unit symbols or names.
///
/// This allows for an intuitive and concise way to create molar amount quantities,
/// for example: `0.5.mol` or `25.millimoles`.
extension MolarAmountCreation on num {
  /// Creates a [MolarAmount] instance representing this numerical value in Moles (mol).
  MolarAmount get mol => MolarAmount(toDouble(), MolarUnit.mole);

  /// Creates a [MolarAmount] instance representing this numerical value in Moles (mol).
  /// Alias for `mol`.
  MolarAmount get moles => MolarAmount(toDouble(), MolarUnit.mole);

  /// Creates a [MolarAmount] instance representing this numerical value in Millimoles (mmol).
  MolarAmount get mmol => MolarAmount(toDouble(), MolarUnit.millimole);

  /// Creates a [MolarAmount] instance representing this numerical value in Millimoles (mmol).
  /// Alias for `mmol`.
  MolarAmount get millimoles => MolarAmount(toDouble(), MolarUnit.millimole);

  /// Creates a [MolarAmount] instance representing this numerical value in Micromoles (¬µmol).
  MolarAmount get umol => MolarAmount(toDouble(), MolarUnit.micromole); // Using 'u' for micro

  /// Creates a [MolarAmount] instance representing this numerical value in Micromoles (¬µmol).
  /// Alias for `umol`.
  MolarAmount get micromoles => MolarAmount(toDouble(), MolarUnit.micromole);

  /// Creates a [MolarAmount] instance representing this numerical value in Nanomoles (nmol).
  MolarAmount get nmol => MolarAmount(toDouble(), MolarUnit.nanomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Nanomoles (nmol).
  /// Alias for `nmol`.
  MolarAmount get nanomoles => MolarAmount(toDouble(), MolarUnit.nanomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Picomoles (pmol).
  MolarAmount get pmol => MolarAmount(toDouble(), MolarUnit.picomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Picomoles (pmol).
  /// Alias for `pmol`.
  MolarAmount get picomoles => MolarAmount(toDouble(), MolarUnit.picomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Kilomoles (kmol).
  MolarAmount get kmol => MolarAmount(toDouble(), MolarUnit.kilomole);

  /// Creates a [MolarAmount] instance representing this numerical value in Kilomoles (kmol).
  /// Alias for `kmol`.
  MolarAmount get kilomoles => MolarAmount(toDouble(), MolarUnit.kilomole);
}
// END FILE: lib/src/units/molar/molar_extensions.dart

<!-- END FILE: [v0.2.0] lib/src/units/molar/molar_extensions.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/molar/molar_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision in calculations.

/// Defines base conversion factors for various molar amount units relative to the Mole (mol),
/// which is the SI base unit for amount of substance.
///
/// These constants represent: `1 [Unit] = Z [Moles]`.
/// So, `molesPerMillimole` means `1 millimole = molesPerMillimole moles`.
class MolarFactors {
  // --- SI Prefixed Units (relative to Mole) ---

  /// Moles per Millimole: 1 millimole (mmol) = 0.001 moles (mol).
  static const double molesPerMillimole = 0.001;

  /// Moles per Micromole: 1 micromole (¬µmol) = 0.000001 moles (mol).
  static const double molesPerMicromole = 0.000001;

  /// Moles per Nanomole: 1 nanomole (nmol) = 1e-9 moles (mol).
  static const double molesPerNanomole = 1.0e-9;

  /// Moles per Picomole: 1 picomole (pmol) = 1e-12 moles (mol).
  static const double molesPerPicomole = 1.0e-12;

  /// Moles per Kilomole: 1 kilomole (kmol) = 1000 moles (mol).
  static const double molesPerKilomole = 1000.0;

  // --- Other potential units (less common for direct amount of substance,
  //      but could be relevant in specific contexts or conversions) ---

  // Example: Pound-mole (lb-mol) - an imperial unit occasionally used in chemical engineering.
  // 1 lb-mol is the amount of a substance whose mass in pounds is numerically equal
  // to its molar mass in g/mol.
  // 1 lb-mol ‚âà 453.59237 mol (since 1 lb ‚âà 453.59237 g)
  // static const double molesPerPoundMole = 453.592370000104; // Derived from lb to g conversion.
  // Using a more direct reference or if precision is critical, this might need verification.
  // For now, focusing on SI prefixed units.
}

<!-- END FILE: [v0.2.0] lib/src/units/molar/molar_factors.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/molar/molar_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'molar_factors.dart';

/// Represents units for amount of substance (molar amount).
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each molar amount unit.
/// All conversion factors are pre-calculated in the constructor relative to Mole (mol),
/// which is the SI base unit for amount of substance.
enum MolarUnit implements Unit<MolarUnit> {
  /// Mole (mol), the SI base unit for amount of substance.
  /// One mole contains exactly 6.02214076 √ó 10¬≤¬≥ elementary entities (Avogadro's number).
  mole(1, 'mol'),

  /// Millimole (mmol), equal to 0.001 moles.
  millimole(MolarFactors.molesPerMillimole, 'mmol'),

  /// Micromole (¬µmol), equal to 1e-6 moles.
  micromole(MolarFactors.molesPerMicromole, '¬µmol'),

  /// Nanomole (nmol), equal to 1e-9 moles.
  nanomole(MolarFactors.molesPerNanomole, 'nmol'),

  /// Picomole (pmol), equal to 1e-12 moles.
  picomole(MolarFactors.molesPerPicomole, 'pmol'),

  /// Kilomole (kmol), equal to 1000 moles.
  kilomole(MolarFactors.molesPerKilomole, 'kmol');

  // If pound-mole were to be added:
  // /// Pound-mole (lb-mol), an imperial unit for amount of substance.
  // /// 1 lb-mol ‚âà 453.59237 mol.
  // poundMole(MolarFactors.molesPerPoundMole, 'lb-mol');

  /// Constant constructor for enum members.
  ///
  /// [_toMoleFactor] is the factor to convert from this unit to the base unit (Mole).
  /// For Mole itself, this is 1.0.
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `MolarUnit`.
  /// The formula `factor_A_to_B = _toBaseFactor_A / _toBaseFactor_B` is used,
  /// where the base unit is Mole.
  const MolarUnit(double toMoleFactor, this.symbol)
      : _toMoleFactor = toMoleFactor,
        // Initialize direct factors from THIS unit to OTHERS.
        _factorToMole = toMoleFactor / 1.0, // Base unit factor for mole is 1.0
        _factorToMillimole = toMoleFactor / MolarFactors.molesPerMillimole,
        _factorToMicromole = toMoleFactor / MolarFactors.molesPerMicromole,
        _factorToNanomole = toMoleFactor / MolarFactors.molesPerNanomole,
        _factorToPicomole = toMoleFactor / MolarFactors.molesPerPicomole,
        _factorToKilomole = toMoleFactor / MolarFactors.molesPerKilomole;
  // If poundMole were added:
  // _factorToPoundMole = toMoleFactor / MolarFactors.molesPerPoundMole;

  /// The factor to convert a value from this unit to the base unit (Mole).
  /// Example: For Millimole, this is 0.001 (meaning 1 mmol = 0.001 mol).
  /// This field is primarily used internally by the constructor to derive
  /// direct inter-unit conversion factors.
  // ignore: unused_field
  final double _toMoleFactor;

  /// The human-readable symbol for this molar amount unit (e.g., "mol", "mmol").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  // These are calculated once in the const constructor for performance.

  final double _factorToMole;
  final double _factorToMillimole;
  final double _factorToMicromole;
  final double _factorToNanomole;
  final double _factorToPicomole;
  final double _factorToKilomole;
  // If poundMole were added:
  // final double _factorToPoundMole;

  /// Returns the direct conversion factor to convert a value from this [MolarUnit]
  /// to the [targetUnit].
  ///
  /// This method is marked as `@internal` and is primarily used by the `MolarAmount`
  /// class for conversions.
  ///
  /// Example: `MolarUnit.millimole.factorTo(MolarUnit.mole)` would return `0.001`.
  /// `MolarUnit.mole.factorTo(MolarUnit.millimole)` would return `1000.0`.
  ///
  /// - [targetUnit]: The `MolarUnit` to which a value should be converted.
  ///
  /// Returns the multiplication factor.
  @override
  @internal
  double factorTo(MolarUnit targetUnit) {
    switch (targetUnit) {
      case MolarUnit.mole:
        return _factorToMole;
      case MolarUnit.millimole:
        return _factorToMillimole;
      case MolarUnit.micromole:
        return _factorToMicromole;
      case MolarUnit.nanomole:
        return _factorToNanomole;
      case MolarUnit.picomole:
        return _factorToPicomole;
      case MolarUnit.kilomole:
        return _factorToKilomole;
      // If poundMole were added:
      // case MolarUnit.poundMole:
      //   return _factorToPoundMole;
    }
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/molar/molar_unit.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/pressure/pressure.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'pressure_unit.dart';

/// Represents a quantity of pressure.
///
/// Pressure is a fundamental physical quantity, defined as force per unit area.
/// This class provides a type-safe way to handle pressure values and conversions
/// between different units of pressure.
@immutable
class Pressure extends Quantity<PressureUnit> {
  /// Creates a new Pressure quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final standardAtmosphere = Pressure(1.0, PressureUnit.atmosphere);
  /// final tirePressure = Pressure(32.0, PressureUnit.psi);
  /// ```
  const Pressure(super.value, super.unit);

  /// Converts this pressure's value to the specified [targetUnit].
  ///
  /// This method uses pre-calculated direct conversion factors for efficiency,
  /// typically involving a single multiplication.
  ///
  /// Example:
  /// ```dart
  /// final p_atm = Pressure(1.0, PressureUnit.atmosphere);
  /// final p_pascals = p_atm.getValue(PressureUnit.pascal); // 101325.0
  /// ```
  @override
  double getValue(PressureUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Pressure] instance with the value converted to the [targetUnit].
  ///
  /// This is useful for obtaining a new `Pressure` object in a different unit
  /// while preserving type safety and quantity semantics.
  ///
  /// Example:
  /// ```dart
  /// final p_bar = Pressure(1.5, PressureUnit.bar);
  /// final p_psi = p_bar.convertTo(PressureUnit.psi);
  /// print(p_psi); // Output: approx "21.7557 psi"
  /// ```
  @override
  Pressure convertTo(PressureUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Pressure(newValue, targetUnit);
  }

  /// Compares this [Pressure] object to another [Quantity<PressureUnit>].
  ///
  /// Comparison is based on the physical magnitude of the pressures.
  /// For comparison, this pressure is converted to the unit of the [other] pressure.
  ///
  /// Returns:
  /// - A negative integer if this pressure is less than [other].
  /// - Zero if this pressure is equal to [other].
  /// - A positive integer if this pressure is greater than [other].
  ///
  /// Example:
  /// ```dart
  /// final p1 = Pressure(1.0, PressureUnit.bar);    // 100000 Pa
  /// final p2 = Pressure(1000.0, PressureUnit.millibar); // 100000 Pa
  /// final p3 = Pressure(15.0, PressureUnit.psi);   // approx 103421 Pa
  ///
  /// print(p1.compareTo(p2)); // 0 (equal)
  /// print(p1.compareTo(p3)); // -1 (p1 < p3)
  /// ```
  @override
  int compareTo(Quantity<PressureUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this pressure to another pressure.
  /// The [other] pressure is converted to the unit of this pressure before addition.
  /// Returns a new [Pressure] instance with the result in the unit of this pressure.
  Pressure operator +(Pressure other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Pressure(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another pressure from this pressure.
  /// The [other] pressure is converted to the unit of this pressure before subtraction.
  /// Returns a new [Pressure] instance with the result in the unit of this pressure.
  Pressure operator -(Pressure other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Pressure(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this pressure by a scalar value.
  /// Returns a new [Pressure] instance with the scaled value in the original unit.
  Pressure operator *(double scalar) {
    return Pressure(value * scalar, unit);
  }

  /// Divides this pressure by a scalar value.
  /// Returns a new [Pressure] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Pressure operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Pressure(value / scalar, unit);
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/pressure/pressure.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/pressure/pressure_extensions.dart -->
import 'pressure.dart';
import 'pressure_unit.dart';

/// Provides convenient access to [Pressure] values in specific units
/// using shortened unit names where appropriate.
extension PressureValueGetters on Pressure {
  /// Returns the pressure value in Pascals (Pa).
  double get inPa => getValue(PressureUnit.pascal);

  /// Returns the pressure value in Atmospheres (atm).
  double get inAtm => getValue(PressureUnit.atmosphere); // "atm" is already short

  /// Returns the pressure value in Bars (bar).
  double get inBar => getValue(PressureUnit.bar); // "bar" is already short

  /// Returns the pressure value in Pounds per Square Inch (psi).
  double get inPsi => getValue(PressureUnit.psi); // "psi" is already short

  /// Returns the pressure value in Torrs (Torr).
  double get inTorr => getValue(PressureUnit.torr);

  /// Returns the pressure value in Millimeters of Mercury (mmHg).
  double get inMmHg => getValue(PressureUnit.millimeterOfMercury);

  /// Returns the pressure value in Inches of Mercury (inHg).
  double get inInHg => getValue(PressureUnit.inchOfMercury);

  /// Returns the pressure value in Kilopascals (kPa).
  double get inKPa => getValue(PressureUnit.kilopascal);

  /// Returns the pressure value in Hectopascals (hPa).
  double get inHPa => getValue(PressureUnit.hectopascal);

  /// Returns the pressure value in Millibars (mbar).
  double get inMbar => getValue(PressureUnit.millibar);

  /// Returns the pressure value in Centimeters of Water (cmH‚ÇÇO) at 4¬∞C.
  double get inCmH2O => getValue(PressureUnit.centimeterOfWater);

  /// Returns the pressure value in Inches of Water (inH‚ÇÇO) at 4¬∞C.
  double get inInH2O => getValue(PressureUnit.inchOfWater);

  /// Returns a Pressure representing this pressure in Pascals (Pa).
  Pressure get asPa => convertTo(PressureUnit.pascal);

  /// Returns a Pressure representing this pressure in Atmospheres (atm).
  Pressure get asAtm => convertTo(PressureUnit.atmosphere);

  /// Returns a Pressure representing this pressure in Bars (bar).
  Pressure get asBar => convertTo(PressureUnit.bar);

  /// Returns a Pressure representing this pressure in Pounds per Square Inch (psi).
  Pressure get asPsi => convertTo(PressureUnit.psi);

  /// Returns a Pressure representing this pressure in Torrs (Torr).
  Pressure get asTorr => convertTo(PressureUnit.torr);

  /// Returns a Pressure representing this pressure in Millimeters of Mercury (mmHg).
  Pressure get asMmHg => convertTo(PressureUnit.millimeterOfMercury);

  /// Returns a Pressure representing this pressure in Inches of Mercury (inHg).
  Pressure get asInHg => convertTo(PressureUnit.inchOfMercury);

  /// Returns a Pressure representing this pressure in Kilopascals (kPa).
  Pressure get asKPa => convertTo(PressureUnit.kilopascal);

  /// Returns a Pressure representing this pressure in Hectopascals (hPa).
  Pressure get asHPa => convertTo(PressureUnit.hectopascal);

  /// Returns a Pressure representing this pressure in Millibars (mbar).
  Pressure get asMbar => convertTo(PressureUnit.millibar);

  /// Returns a Pressure representing this pressure in Centimeters of Water (cmH‚ÇÇO).
  Pressure get asCmH2O => convertTo(PressureUnit.centimeterOfWater);

  /// Returns a Pressure representing this pressure in Inches of Water (inH‚ÇÇO).
  Pressure get asInH2O => convertTo(PressureUnit.inchOfWater);
}

/// Provides convenient factory methods for creating [Pressure] instances from [num]
/// using shortened unit names where appropriate.
extension PressureCreation on num {
  /// Creates a [Pressure] instance representing this numerical value in Pascals (Pa).
  Pressure get pa => Pressure(toDouble(), PressureUnit.pascal);

  /// Creates a [Pressure] instance representing this numerical value in Atmospheres (atm).
  Pressure get atm => Pressure(toDouble(), PressureUnit.atmosphere);

  /// Creates a [Pressure] instance representing this numerical value in Bars (bar).
  Pressure get bar => Pressure(toDouble(), PressureUnit.bar);

  /// Creates a [Pressure] instance representing this numerical value in Pounds per Square Inch (psi).
  Pressure get psi => Pressure(toDouble(), PressureUnit.psi);

  /// Creates a [Pressure] instance representing this numerical value in Torrs (Torr).
  Pressure get torr => Pressure(toDouble(), PressureUnit.torr);

  /// Creates a [Pressure] instance representing this numerical value in Millimeters of Mercury (mmHg).
  Pressure get mmHg => Pressure(toDouble(), PressureUnit.millimeterOfMercury);

  /// Creates a [Pressure] instance representing this numerical value in Inches of Mercury (inHg).
  Pressure get inHg => Pressure(toDouble(), PressureUnit.inchOfMercury);

  /// Creates a [Pressure] instance representing this numerical value in Kilopascals (kPa).
  Pressure get kPa => Pressure(toDouble(), PressureUnit.kilopascal);

  /// Creates a [Pressure] instance representing this numerical value in Hectopascals (hPa).
  Pressure get hPa => Pressure(toDouble(), PressureUnit.hectopascal);

  /// Creates a [Pressure] instance representing this numerical value in Millibars (mbar).
  Pressure get mbar => Pressure(toDouble(), PressureUnit.millibar);

  /// Creates a [Pressure] instance representing this numerical value in Centimeters of Water (cmH‚ÇÇO) at 4¬∞C.
  Pressure get cmH2O => Pressure(toDouble(), PressureUnit.centimeterOfWater);

  /// Creates a [Pressure] instance representing this numerical value in Inches of Water (inH‚ÇÇO) at 4¬∞C.
  Pressure get inH2O => Pressure(toDouble(), PressureUnit.inchOfWater);

  // Longer aliases (optional)
  // Pressure get pascals => Pressure(toDouble(), PressureUnit.pascal);
  // Pressure get atmospheres => Pressure(toDouble(), PressureUnit.atmosphere);
  // Pressure get bars => Pressure(toDouble(), PressureUnit.bar);
  // Pressure get poundsPerSquareInch => Pressure(toDouble(), PressureUnit.psi);
  // Pressure get torrs => Pressure(toDouble(), PressureUnit.torr);
  // Pressure get millimetersOfMercury => Pressure(toDouble(), PressureUnit.millimeterOfMercury);
  // Pressure get inchesOfMercury => Pressure(toDouble(), PressureUnit.inchOfMercury);
  // Pressure get kilopascals => Pressure(toDouble(), PressureUnit.kilopascal);
  // Pressure get hectopascals => Pressure(toDouble(), PressureUnit.hectopascal);
  // Pressure get millibars => Pressure(toDouble(), PressureUnit.millibar);
  // Pressure get centimetersOfWater => Pressure(toDouble(), PressureUnit.centimeterOfWater);
  // Pressure get inchesOfWater => Pressure(toDouble(), PressureUnit.inchOfWater);
}

<!-- END FILE: [v0.2.0] lib/src/units/pressure/pressure_extensions.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/pressure/pressure_factors.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import '../../../quantify.dart' show Unit;
import '../../core/unit.dart' show Unit;

/// Defines base conversion factors for various pressure units relative to Pascal (Pa).
///
/// These constants are based on international standards (e.g., NIST) where available.
/// The base unit for internal calculations is Pascal.
/// Factors represent: 1 [Unit] = X Pascals.
/// All water column units (cmH‚ÇÇO, inH‚ÇÇO) refer to a water temperature of 4¬∞C (39.2¬∞F)
/// unless otherwise specified, aligning with common scientific reference points for water density
/// and conventional values (e.g., NIST SP 811).
class PressureFactors {
  /// Pascals per Standard Atmosphere (atm): 1 atm = 101325 Pa (exact definition).
  static const double pascalsPerAtmosphere = 101325.0;

  /// Pascals per Bar (bar): 1 bar = 100000 Pa (exact definition).
  static const double pascalsPerBar = 100000.0;

  /// Pascals per Pound per Square Inch (psi): 1 psi ‚âà 6894.757293168361 Pa.
  /// Derived from the international yard and pound agreement:
  /// 1 pound-force (lbf) ‚âà 4.4482216152605 N and 1 inch = 0.0254 m.
  static const double pascalsPerPsi = 6894.757293168361;

  /// Pascals per Torr (Torr): 1 Torr ‚âà 133.322368421 Pa.
  /// Defined as 1/760 of a standard atmosphere. Mercury at 0¬∞C.
  static const double pascalsPerTorr = pascalsPerAtmosphere / 760.0;

  /// Pascals per Millimeter of Mercury (mmHg) at 0¬∞C: Same as Torr.
  /// 1 mmHg (at 0¬∞C) ‚âà 133.322368421 Pa.
  static const double pascalsPerMillimeterOfMercury = pascalsPerTorr;

  /// Pascals per Inch of Mercury (inHg) at 0¬∞C: 1 inHg ‚âà 3386.388687636 Pa.
  /// Defined as `pascalsPerMillimeterOfMercury * 25.4` (since 1 inch = 25.4 mm).
  /// Conventional value often cited from NIST SP 811 is 3386.389 Pa.
  /// The calculated value is (101325.0 / 760.0) * 25.4 = 3386.3886876315788
  static const double pascalsPerInchOfMercury = pascalsPerMillimeterOfMercury * 25.4;
  // For reference, NIST SP 811 Appendix B.8 lists:
  // Inch of mercury (0 ¬∞C)  = 3.386 389 E+03 Pa
  // The calculated value is extremely close and based on fundamental definitions.
  // Using the calculated one for consistency, the difference is negligible for doubles.

  /// Pascals per Kilopascal (kPa): 1 kPa = 1000 Pa.
  static const double pascalsPerKilopascal = 1000.0;

  /// Pascals per Hectopascal (hPa): 1 hPa = 100 Pa.
  static const double pascalsPerHectopascal = 100.0;

  /// Pascals per Millibar (mbar): 1 mbar = 100 Pa (same as hPa).
  static const double pascalsPerMillibar = 100.0;

  /// Conventional value for Pascals per Centimeter of Water (cmH‚ÇÇO) at 4¬∞C.
  /// 1 cmH‚ÇÇO (at 4¬∞C) = 98.0665 Pa.
  /// This value is commonly cited, e.g., in NIST SP 811, based on a conventional
  /// standard gravity (g‚Çô = 9.80665 m/s¬≤) and water density of 1000 kg/m¬≥ at 4¬∞C.
  static const double conventionalPascalsPerCentimeterOfWater4C = 98.0665;

  /// Conventional value for Pascals per Inch of Water (inH‚ÇÇO) at 4¬∞C.
  /// 1 inH‚ÇÇO (at 4¬∞C) = 249.08891 Pa.
  /// This value is commonly cited, e.g., in NIST SP 811, and is derived from
  /// `conventionalPascalsPerCentimeterOfWater4C * 2.54` (since 1 inch = 2.54 cm).
  static const double conventionalPascalsPerInchOfWater4C = 249.08891;
}

<!-- END FILE: [v0.2.0] lib/src/units/pressure/pressure_factors.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/pressure/pressure_unit.dart -->
import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'pressure_factors.dart';

/// Represents units of pressure.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each pressure unit.
/// All conversion factors are pre-calculated in the constructor relative to Pascal (Pa).
enum PressureUnit implements Unit<PressureUnit> {
  /// Pascal (Pa), the SI derived unit of pressure.
  pascal(1, 'Pa'),

  /// Atmosphere (atm), standard atmosphere.
  atmosphere(PressureFactors.pascalsPerAtmosphere, 'atm'),

  /// Bar (bar).
  bar(PressureFactors.pascalsPerBar, 'bar'),

  /// Pound per square inch (psi).
  psi(PressureFactors.pascalsPerPsi, 'psi'),

  /// Torr (Torr), approximately 1 mmHg.
  torr(PressureFactors.pascalsPerTorr, 'Torr'),

  /// Millimeter of mercury (mmHg) at 0¬∞C.
  millimeterOfMercury(PressureFactors.pascalsPerMillimeterOfMercury, 'mmHg'),

  /// Inch of mercury (inHg) at 0¬∞C.
  inchOfMercury(PressureFactors.pascalsPerInchOfMercury, 'inHg'),

  /// Kilopascal (kPa).
  kilopascal(PressureFactors.pascalsPerKilopascal, 'kPa'),

  /// Hectopascal (hPa).
  hectopascal(PressureFactors.pascalsPerHectopascal, 'hPa'),

  /// Millibar (mbar), equivalent to hectopascal.
  millibar(PressureFactors.pascalsPerMillibar, 'mbar'),

  /// Centimeter of water (cmH‚ÇÇO) at 4¬∞C.
  centimeterOfWater(PressureFactors.conventionalPascalsPerCentimeterOfWater4C, 'cmH‚ÇÇO'),

  /// Inch of water (inH‚ÇÇO) at 4¬∞C.
  inchOfWater(PressureFactors.conventionalPascalsPerInchOfWater4C, 'inH‚ÇÇO');

  /// Constant constructor for enum members.
  ///
  /// [_toPascalFactor] is the factor to convert from this unit to the base unit (Pascal).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `PressureUnit`.
  /// The formula `factor_A_to_B = _toPascalFactor_A / _toPascalFactor_B` is used.
  const PressureUnit(this._toPascalFactor, this.symbol)
      : _factorToPascal = _toPascalFactor / 1.0, // Pascal's _toPascalFactor is 1.0
        _factorToAtmosphere = _toPascalFactor / PressureFactors.pascalsPerAtmosphere,
        _factorToBar = _toPascalFactor / PressureFactors.pascalsPerBar,
        _factorToPsi = _toPascalFactor / PressureFactors.pascalsPerPsi,
        _factorToTorr = _toPascalFactor / PressureFactors.pascalsPerTorr,
        _factorToMillimeterOfMercury =
            _toPascalFactor / PressureFactors.pascalsPerMillimeterOfMercury,
        _factorToInchOfMercury = _toPascalFactor / PressureFactors.pascalsPerInchOfMercury,
        _factorToKilopascal = _toPascalFactor / PressureFactors.pascalsPerKilopascal,
        _factorToHectopascal = _toPascalFactor / PressureFactors.pascalsPerHectopascal,
        _factorToMillibar = _toPascalFactor / PressureFactors.pascalsPerMillibar,
        _factorToCentimeterOfWater =
            _toPascalFactor / PressureFactors.conventionalPascalsPerCentimeterOfWater4C,
        _factorToInchOfWater =
            _toPascalFactor / PressureFactors.conventionalPascalsPerInchOfWater4C;

  /// The factor to convert a value from this unit to the base unit (Pascal).
  /// Example: For Bar, this is 100000.0 (meaning 1 bar = 100000.0 Pa).
  /// After constructor initialization, its value is primarily baked into
  /// the specific _factorToXxx fields for direct inter-unit conversions.
  /// It's generally not accessed directly by methods outside this enum's constructor
  /// but is crucial for deriving the pre-calculated factors.
  // ignore: unused_field
  final double _toPascalFactor;

  /// The human-readable symbol for this pressure unit (e.g., "Pa", "psi").
  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  // These are calculated once in the const constructor.

  final double _factorToPascal;
  final double _factorToAtmosphere;
  final double _factorToBar;
  final double _factorToPsi;
  final double _factorToTorr;
  final double _factorToMillimeterOfMercury;
  final double _factorToInchOfMercury;
  final double _factorToKilopascal;
  final double _factorToHectopascal;
  final double _factorToMillibar;
  final double _factorToCentimeterOfWater;
  final double _factorToInchOfWater;

  /// Returns the direct conversion factor to convert a value from this [PressureUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(PressureUnit targetUnit) {
    switch (targetUnit) {
      case PressureUnit.pascal:
        return _factorToPascal;
      case PressureUnit.atmosphere:
        return _factorToAtmosphere;
      case PressureUnit.bar:
        return _factorToBar;
      case PressureUnit.psi:
        return _factorToPsi;
      case PressureUnit.torr:
        return _factorToTorr;
      case PressureUnit.millimeterOfMercury:
        return _factorToMillimeterOfMercury;
      case PressureUnit.inchOfMercury:
        return _factorToInchOfMercury;
      case PressureUnit.kilopascal:
        return _factorToKilopascal;
      case PressureUnit.hectopascal:
        return _factorToHectopascal;
      case PressureUnit.millibar:
        return _factorToMillibar;
      case PressureUnit.centimeterOfWater:
        return _factorToCentimeterOfWater;
      case PressureUnit.inchOfWater:
        return _factorToInchOfWater;
    }
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/pressure/pressure_unit.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/temperature/temperature.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'temperature_unit.dart';

/// Represents a quantity of temperature.
///
/// Temperature conversions are affine (involve offsets) and are handled by
/// specific formulas within the [getValue] method, rather than simple
/// multiplicative factors.
@immutable
class Temperature extends Quantity<TemperatureUnit> {
  /// Creates a new Temperature quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final bodyTemp = Temperature(37.0, TemperatureUnit.celsius);
  /// final absoluteZero = Temperature(0.0, TemperatureUnit.kelvin);
  /// ```
  const Temperature(super.value, super.unit);

  // --- Conversion Constants ---
  // These could also be in a separate TemperatureFactors class if they grew more complex
  // or were needed elsewhere, but for direct formulas they are fine here.

  /// The offset of Kelvin from Celsius (0¬∞C = 273.15K).
  static const double kelvinOffsetFromCelsius = 273.15;

  /// The scaling factor for Fahrenheit to Celsius conversion (9/5).
  static const double fahrenheitScaleFactor = 1.8; // 9.0 / 5.0

  /// The offset for Fahrenheit conversion from Celsius (0¬∞C = 32¬∞F).
  static const double fahrenheitOffset = 32.0;

  /// Converts this temperature's value to the specified [targetUnit]
  /// using direct, optimized formulas for affine conversions.
  ///
  /// Example:
  /// ```dart
  /// final roomTempC = Temperature(20.0, TemperatureUnit.celsius);
  /// final roomTempF = roomTempC.getValue(TemperatureUnit.fahrenheit); // 68.0
  /// ```
  @override
  double getValue(TemperatureUnit targetUnit) {
    if (targetUnit == unit) return value;

    switch (unit) {
      case TemperatureUnit.celsius:
        switch (targetUnit) {
          case TemperatureUnit.kelvin:
            return value + kelvinOffsetFromCelsius;
          case TemperatureUnit.fahrenheit:
            return (value * fahrenheitScaleFactor) + fahrenheitOffset;
          case TemperatureUnit.celsius:
            return value;
        }
      case TemperatureUnit.kelvin:
        switch (targetUnit) {
          case TemperatureUnit.celsius:
            return value - kelvinOffsetFromCelsius;
          case TemperatureUnit.fahrenheit:
            final celsiusValue = value - kelvinOffsetFromCelsius;
            return (celsiusValue * fahrenheitScaleFactor) + fahrenheitOffset;
          case TemperatureUnit.kelvin:
            return value;
        }
      case TemperatureUnit.fahrenheit:
        switch (targetUnit) {
          case TemperatureUnit.celsius:
            return (value - fahrenheitOffset) / fahrenheitScaleFactor;
          case TemperatureUnit.kelvin:
            final celsiusValue = (value - fahrenheitOffset) / fahrenheitScaleFactor;
            return celsiusValue + kelvinOffsetFromCelsius;
          case TemperatureUnit.fahrenheit:
            return value;
        }
    }
  }

  /// Creates a new [Temperature] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final boilingPointC = Temperature(100.0, TemperatureUnit.celsius);
  /// final boilingPointF = boilingPointC.convertTo(TemperatureUnit.fahrenheit);
  /// print(boilingPointF); // Output: "212.0 ¬∞F"
  /// ```
  @override
  Temperature convertTo(TemperatureUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Temperature(newValue, targetUnit);
  }

  /// Compares this [Temperature] object to another [Quantity<TemperatureUnit>].
  ///
  /// Comparison is based on the physical magnitude of the temperatures.
  /// For comparison, this temperature is converted to the unit of the [other] temperature.
  @override
  int compareTo(Quantity<TemperatureUnit> other) {
    // Convert this quantity's value to the unit of the 'other' quantity
    // for a direct numerical comparison.
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators (Specific for Temperature) ---

  /// Subtracts another temperature from this temperature, yielding a temperature difference.
  /// The [other] temperature is converted to the unit of this temperature before subtraction.
  /// Returns a [double] representing the difference in the unit of this temperature.
  /// For example, `20.celsius - 10.celsius` yields `10.0` (a difference of 10 Celsius degrees).
  double operator -(Temperature other) {
    final otherValueInThisUnit = other.getValue(unit);
    return value - otherValueInThisUnit;
  }

  // Operator + (Temperature other) is intentionally not implemented as it's
  // generally not physically meaningful for absolute temperatures.

  // Operator * (double scalar) is intentionally not implemented as it's
  // generally not physically meaningful for absolute temperatures.

  // Operator / (double scalar) is intentionally not implemented as it's
  // generally not physically meaningful for absolute temperatures.

  /// Divides this temperature by another temperature.
  /// The [other] temperature is converted to the unit of this temperature before division.
  /// Returns a scalar [double] representing the ratio.
  /// Note: This operation is only meaningful in specific thermodynamic contexts (e.g., Carnot efficiency)
  /// and should be used with caution. Both temperatures should ideally be on an absolute scale (Kelvin)
  /// for physical meaning, though the calculation will be performed based on converted values.
  /// Throws [ArgumentError] if the effective value of [other] in this unit is zero.
  double operator /(Temperature other) {
    // For ratio calculations, it's often more meaningful if both are converted to Kelvin first,
    // but to keep consistent with other quantity divisions, we convert to `this.unit`.
    final otherValueInThisUnit = other.getValue(unit);
    if (otherValueInThisUnit == 0 && value != 0) {
      // Avoid 0/0 resulting in NaN without error
      // A zero temperature on a non-Kelvin scale might not be absolute zero.
      // However, division by zero magnitude is the primary concern.
      throw ArgumentError('Cannot divide by a zero temperature if the dividend is non-zero.');
    }
    // Handle 0.0 / 0.0 case, which results in NaN. Could throw or return as is.
    // Standard double division handles 0.0/0.0 as NaN.
    if (value == 0 && otherValueInThisUnit == 0) {
      return double.nan; // Or throw, depending on desired strictness for 0/0
    }
    return value / otherValueInThisUnit;
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/temperature/temperature.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/temperature/temperature_extensions.dart -->
import 'temperature.dart';
import 'temperature_unit.dart';

/// Provides convenient access to [Temperature] values in specific units.
extension TemperatureValueGetters on Temperature {
  /// Returns the temperature value in Celsius (¬∞C).
  double get inCelsius => getValue(TemperatureUnit.celsius);

  /// Returns the temperature value in Kelvin (K).
  double get inKelvin => getValue(TemperatureUnit.kelvin);

  /// Returns the temperature value in Fahrenheit (¬∞F).
  double get inFahrenheit => getValue(TemperatureUnit.fahrenheit);

  /// Returns a Temperature representing this temperature in Celsius (¬∞C).
  Temperature get asCelsius => convertTo(TemperatureUnit.celsius);

  /// Returns a Temperature representing this temperature in Kelvin (K).
  Temperature get asKelvin => convertTo(TemperatureUnit.kelvin);

  /// Returns a Temperature representing this temperature in Fahrenheit (¬∞F).
  Temperature get asFahrenheit => convertTo(TemperatureUnit.fahrenheit);
}

/// Provides convenient factory methods for creating [Temperature] instances from [num].
extension TemperatureCreation on num {
  /// Creates a [Temperature] instance representing this numerical value in Celsius (¬∞C).
  Temperature get celsius => Temperature(toDouble(), TemperatureUnit.celsius);

  /// Creates a [Temperature] instance representing this numerical value in Kelvin (K).
  Temperature get kelvin => Temperature(toDouble(), TemperatureUnit.kelvin);

  /// Creates a [Temperature] instance representing this numerical value in Fahrenheit (¬∞F).
  Temperature get fahrenheit => Temperature(toDouble(), TemperatureUnit.fahrenheit);
}

<!-- END FILE: [v0.2.0] lib/src/units/temperature/temperature_extensions.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/temperature/temperature_unit.dart -->
import '../../core/unit.dart';
import 'temperature.dart';

/// Represents units of temperature.
///
/// This enum implements the [Unit] interface but its [factorTo] method
/// will throw an [UnsupportedError] because temperature conversions
/// are affine (involve offsets) and cannot be represented by a single
/// multiplicative factor. Use [Temperature.getValue] or [Temperature.convertTo]
/// for proper conversions.
enum TemperatureUnit implements Unit<TemperatureUnit> {
  /// Celsius (¬∞C).
  celsius('¬∞C'),

  /// Kelvin (K), the SI base unit of thermodynamic temperature.
  kelvin('K'),

  /// Fahrenheit (¬∞F).
  fahrenheit('¬∞F');

  /// Constant constructor for enum members.
  /// [symbol] is the display symbol for the unit.
  const TemperatureUnit(this.symbol);

  @override
  final String symbol;

  /// Throws [UnsupportedError] for temperature units.
  ///
  /// Temperature conversions are affine (involve offsets) and cannot be
  /// represented by a single multiplicative factor.
  /// Use [Temperature.getValue] or [Temperature.convertTo] for proper
  /// temperature conversions.
  @override
  double factorTo(TemperatureUnit targetUnit) {
    throw UnsupportedError(
      'Direct multiplicative factor conversion is not supported for temperature units '
      'due to their affine nature (offsets). '
      'Use Temperature.getValue() or Temperature.convertTo() for proper conversions.',
    );
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/temperature/temperature_unit.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/time/time.dart -->
import 'package:meta/meta.dart';

import '../../core/quantity.dart';
import 'time_unit.dart';

/// Represents a quantity of time (duration).
@immutable
class Time extends Quantity<TimeUnit> {
  /// Creates a new Time quantity with the given [value] and [unit].
  ///
  /// Example:
  /// ```dart
  /// final duration = Time(120.0, TimeUnit.second);
  /// final meetingLength = Time(1.5, TimeUnit.hour);
  /// ```
  const Time(super.value, super.unit);

  /// Converts this time's value to the specified [targetUnit].
  @override
  double getValue(TimeUnit targetUnit) {
    if (targetUnit == unit) return value;
    return value * unit.factorTo(targetUnit);
  }

  /// Creates a new [Time] instance with the value converted to the [targetUnit].
  ///
  /// Example:
  /// ```dart
  /// final twoMinutes = Time(2.0, TimeUnit.minute);
  /// final inSeconds = twoMinutes.convertTo(TimeUnit.second); // Time(120.0, TimeUnit.second)
  /// print(inSeconds.value); // 120.0
  /// ```
  @override
  Time convertTo(TimeUnit targetUnit) {
    if (targetUnit == unit) return this;
    final newValue = getValue(targetUnit);
    return Time(newValue, targetUnit);
  }

  /// Compares this [Time] object to another [Quantity<TimeUnit>].
  ///
  /// Comparison is based on the physical magnitude of the durations.
  @override
  int compareTo(Quantity<TimeUnit> other) {
    final thisValueInOtherUnit = getValue(other.unit);
    return thisValueInOtherUnit.compareTo(other.value);
  }

  // --- Arithmetic Operators ---

  /// Adds this time duration to another time duration.
  /// The [other] time is converted to the unit of this time before addition.
  /// Returns a new [Time] instance with the result in the unit of this time.
  Time operator +(Time other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Time(value + otherValueInThisUnit, unit);
  }

  /// Subtracts another time duration from this time duration.
  /// The [other] time is converted to the unit of this time before subtraction.
  /// Returns a new [Time] instance with the result in the unit of this time.
  Time operator -(Time other) {
    final otherValueInThisUnit = other.getValue(unit);
    return Time(value - otherValueInThisUnit, unit);
  }

  /// Multiplies this time duration by a scalar value.
  /// Returns a new [Time] instance with the scaled value in the original unit.
  Time operator *(double scalar) {
    return Time(value * scalar, unit);
  }

  /// Divides this time duration by a scalar value.
  /// Returns a new [Time] instance with the scaled value in the original unit.
  /// Throws [ArgumentError] if scalar is zero.
  Time operator /(double scalar) {
    if (scalar == 0) {
      throw ArgumentError('Cannot divide by zero.');
    }
    return Time(value / scalar, unit);
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/time/time.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/time/time_extensions.dart -->
import 'time.dart';
import 'time_unit.dart';

/// Provides convenient access to [Time] values in specific units.
extension TimeValueGetters on Time {
  /// Returns the time value in Seconds (s).
  double get inSeconds => getValue(TimeUnit.second);

  /// Returns the time value in Milliseconds (ms).
  double get inMilliseconds => getValue(TimeUnit.millisecond);

  /// Returns the time value in Minutes (min).
  double get inMinutes => getValue(TimeUnit.minute);

  /// Returns the time value in Hours (h).
  double get inHours => getValue(TimeUnit.hour);

  /// Returns the time value in Days (d).
  double get inDays => getValue(TimeUnit.day);

  /// Returns a Time representing this time in Seconds (s).
  Time get asSeconds => convertTo(TimeUnit.second);

  /// Returns a Time representing this time in Milliseconds (ms).
  Time get asMilliseconds => convertTo(TimeUnit.millisecond);

  /// Returns a Time representing this time in Minutes (min).
  Time get asMinutes => convertTo(TimeUnit.minute);

  /// Returns a Time representing this time in Hours (h).
  Time get asHours => convertTo(TimeUnit.hour);

  /// Returns a Time representing this time in Days (d).
  Time get asDays => convertTo(TimeUnit.day);
}

/// Provides convenient factory methods for creating [Time] instances from [num].
extension TimeCreation on num {
  /// Creates a [Time] instance representing this numerical value in Seconds (s).
  Time get seconds => Time(toDouble(), TimeUnit.second);

  /// Creates a [Time] instance representing this numerical value in Milliseconds (ms).
  Time get milliseconds => Time(toDouble(), TimeUnit.millisecond);

  /// Creates a [Time] instance representing this numerical value in Minutes (min).
  Time get minutes => Time(toDouble(), TimeUnit.minute);

  /// Creates a [Time] instance representing this numerical value in Hours (h).
  Time get hours => Time(toDouble(), TimeUnit.hour);

  /// Creates a [Time] instance representing this numerical value in Days (d).
  Time get days => Time(toDouble(), TimeUnit.day);

  // Aliases for shorter creation syntax (optional, but common in other libs)
  // Time get s => Time(toDouble(), TimeUnit.second);
  // Time get ms => Time(toDouble(), TimeUnit.millisecond);
  // Time get min => Time(toDouble(), TimeUnit.minute); // 'm' is meter, so 'min' is better
  // Time get h => Time(toDouble(), TimeUnit.hour);
  // Time get d => Time(toDouble(), TimeUnit.day);
}

<!-- END FILE: [v0.2.0] lib/src/units/time/time_extensions.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/time/time_factors.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

/// Defines base conversion factors for various time units relative to Second (s).
///
/// These constants are based on standard definitions.
class TimeFactors {
  // The base unit for internal calculations is Second.
  // Factors represent: 1 [Unit] = X [Seconds]

  /// Seconds per Millisecond: 1 millisecond = 0.001 seconds.
  static const double secondsPerMillisecond = 0.001;

  /// Seconds per Minute: 1 minute = 60.0 seconds.
  static const double secondsPerMinute = 60.0;

  /// Seconds per Hour: 1 hour = 3600.0 seconds (60 minutes * 60 seconds).
  static const double secondsPerHour = 3600.0;

  /// Seconds per Day: 1 day = 86400.0 seconds (24 hours * 3600 seconds/hour).
  static const double secondsPerDay = 86400.0;

  // Optional: Could add week, month (average), year (average/Julian) if complex time is desired later.
  // For now, keeping it to common, precise units.
}

<!-- END FILE: [v0.2.0] lib/src/units/time/time_factors.dart -->

<!-- BEGIN FILE: [v0.2.0] lib/src/units/time/time_unit.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:meta/meta.dart';

import '../../core/unit.dart';
import 'time_factors.dart';

/// Represents units of time.
///
/// This enum implements the [Unit] interface to provide conversion capabilities
/// and a display [symbol] for each time unit.
/// All conversion factors are pre-calculated in the constructor relative to Second (s).
enum TimeUnit implements Unit<TimeUnit> {
  /// Second (s), the SI base unit of time.
  second(1.0, 's'),

  /// Millisecond (ms), equal to 0.001 seconds.
  millisecond(TimeFactors.secondsPerMillisecond, 'ms'),

  /// Minute (min), equal to 60 seconds.
  minute(TimeFactors.secondsPerMinute, 'min'),

  /// Hour (h), equal to 3600 seconds.
  hour(TimeFactors.secondsPerHour, 'h'),

  /// Day (d), equal to 86400 seconds.
  day(TimeFactors.secondsPerDay, 'd');

  /// Constant constructor for enum members.
  ///
  /// [_toSecondFactor] is the factor to convert from this unit to the base unit (Second).
  /// [symbol] is the display symbol for the unit.
  ///
  /// The constructor pre-calculates all direct conversion factors
  /// from this unit to every other `TimeUnit`.
  const TimeUnit(this._toSecondFactor, this.symbol)
      : _factorToSecond = _toSecondFactor / 1.0, // Second's _toSecondFactor is 1.0
        _factorToMillisecond = _toSecondFactor / TimeFactors.secondsPerMillisecond,
        _factorToMinute = _toSecondFactor / TimeFactors.secondsPerMinute,
        _factorToHour = _toSecondFactor / TimeFactors.secondsPerHour,
        _factorToDay = _toSecondFactor / TimeFactors.secondsPerDay;

  /// The factor to convert a value from this unit to the base unit (Second).
  /// After constructor initialization, its value is primarily baked into
  /// the specific _factorToXxx fields for direct inter-unit conversions.
  /// It's generally not accessed directly by methods outside this enum's constructor
  /// but is crucial for deriving the pre-calculated factors.
  // ignore: unused_field
  final double _toSecondFactor;

  @override
  final String symbol;

  // --- Pre-calculated direct conversion factors from this unit to all others ---
  final double _factorToSecond;
  final double _factorToMillisecond;
  final double _factorToMinute;
  final double _factorToHour;
  final double _factorToDay;

  /// Returns the direct conversion factor to convert a value from this [TimeUnit]
  /// to the [targetUnit].
  @override
  @internal
  double factorTo(TimeUnit targetUnit) {
    switch (targetUnit) {
      case TimeUnit.second:
        return _factorToSecond;
      case TimeUnit.millisecond:
        return _factorToMillisecond;
      case TimeUnit.minute:
        return _factorToMinute;
      case TimeUnit.hour:
        return _factorToHour;
      case TimeUnit.day:
        return _factorToDay;
    }
  }
}

<!-- END FILE: [v0.2.0] lib/src/units/time/time_unit.dart -->

<!-- BEGIN FILE: [v0.2.0] example/CHANGELOG.md -->
# Changelog

## 1.0.0

- Initial version.

<!-- END FILE: [v0.2.0] example/CHANGELOG.md -->

<!-- BEGIN FILE: [v0.2.0] example/README.md -->
# Quantify Package - CLI Example

This directory contains a command-line interface (CLI) example demonstrating the features of the `quantify` package.

## Features Demonstrated

The `quantify_cli_example.dart` script showcases:

* **Creating Quantities:**
  * Using intuitive `num` extensions (e.g., `1500.m`, `2.5.km`).
* **Unit Conversions:**
  * Retrieving numerical values in different units (e.g., `pathA.inKm`).
  * Converting `Quantity` objects to different units (e.g., `pathA.convertTo(LengthUnit.kilometer)`).
* **String Formatting (`toString()`):**
  * Default formatting.
  * Specifying a `targetUnit` for conversion before formatting.
  * Controlling the number of `fractionDigits`.
  * Using a `unitSymbolSeparator`.
  * Locale-specific number formatting using the `locale` parameter (requires the `intl` package).
  * Using a custom `intl.NumberFormat` instance for advanced control over number display.
* **Arithmetic Operations:**
  * Adding (`+`) and subtracting (`-`) quantities (automatic unit conversion for the right-hand operand).
  * Multiplying (`*`) and dividing (`/`) quantities by a scalar.
  * Specific arithmetic for `Temperature` (e.g., difference).
* **Comparisons:**
  * Using `compareTo()` for magnitude comparison.
  * Using `==` to check for equality in both value and unit.
  * Sorting lists of `Quantity` objects.
* **Usage of various implemented quantity types:**
  * Length
  * Time
  * Temperature
  * Pressure

## How to Run

1. Navigate to the root directory of the `quantify` package.
2. Ensure dependencies are fetched:

    ```bash
    dart pub get
    ```

3. Run the example script from the `example` directory:

    ```bash
    dart run example/quantify_cli_example.dart
    ```

    Alternatively, if you are already in the `example` directory:

    ```bash
    dart run quantify_cli_example.dart
    ```

## Dependencies

This example depends on:

* The main `quantify` package (referenced via `path: ../` in its `pubspec.yaml`).
* The `intl` package for locale-specific number formatting features.

<!-- END FILE: [v0.2.0] example/README.md -->

<!-- BEGIN FILE: [v0.2.0] example/analysis_options.yaml -->
include: package:very_good_analysis/analysis_options.yaml

formatter:
  page_width: 100
#  trailing_commas: preserve

analyzer:
  errors:
    unused_import: warning
    todo: ignore

linter:
  rules:
    # Allow relative imports for files within the same package
    always_use_package_imports: false
    # Prefer using relative imports within the same package
    prefer_relative_imports: true
    # Allow lines to exceed 80 characters
    lines_longer_than_80_chars: false
    # Prefer using const constructors where possible
    prefer_const_constructors: true
    # Prefer declaring local variables as final if they are not reassigned
    prefer_final_locals: true
    # Allow mutable literal lists/maps/sets even if they could be const
    prefer_const_literals_to_create_immutables: false
    # Allow explicitly typing closure parameters
    avoid_types_on_closure_parameters: false
    # Use trailing commas for all parameter lists and argument lists.
    require_trailing_commas: true
    # Use enums rather than classes that behave like enums.
    use_enums: true
    # Allow using print() for debugging purposes
    avoid_print: false
<!-- END FILE: [v0.2.0] example/analysis_options.yaml -->

<!-- BEGIN FILE: [v0.2.0] example/pubspec.yaml -->
name: quantify_example
description: A command-line example for the quantify package.
version: 1.0.0
publish_to: "none"

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies:
  intl: ^0.19.0
  quantify:
    path: ../

dev_dependencies:
  test: ^1.26.0
  very_good_analysis: ^8.0.0

<!-- END FILE: [v0.2.0] example/pubspec.yaml -->

<!-- BEGIN FILE: [v0.2.0] example/quantify_cli_example.dart -->
import 'package:intl/intl.dart'; // For locale-specific number formatting
import 'package:quantify/quantify.dart';

void main() {
  print('--- Quantify CLI Example ---');

  // 1. Create and convert lengths
  print('\n--- Length ---');
  final pathA = 1500.m; // Using .m as requested
  final pathB = 2.5.km;

  print('Path A: $pathA'); // Default toString
  print('Path A in Kilometers: ${pathA.inKm} km');
  print(
    'Path A (formatted): ${pathA.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 1)}',
  );
  print(
    'Path B in Miles: ${pathB.toString(targetUnit: LengthUnit.mile, fractionDigits: 2)}',
  );

  // 2. Arithmetic with lengths
  final totalDistance = pathA + pathB; // pathB is automatically converted to meters
  print('Total Distance: ${totalDistance.toString(fractionDigits: 0)}');
  print(
    'Total Distance in Yards: ${totalDistance.toString(targetUnit: LengthUnit.yard, fractionDigits: 0, unitSymbolSeparator: '\u00A0')}',
  );

  final scaledDistance = pathA * 3;
  print('Path A scaled by 3: $scaledDistance');

  // 3. Times
  print('\n--- Time ---');
  final duration1 = 90.minutes;
  final duration2 = 0.5.hours;

  print('Duration 1: $duration1');
  print('Duration 1 in Hours: ${duration1.inHours} h');
  print('Duration 2: ${duration2.toString(targetUnit: TimeUnit.minute)}');

  final totalTime = duration1 + duration2; // 90 min + 30 min = 120 min
  print('Total Time: ${totalTime.toString(targetUnit: TimeUnit.hour)}'); // "2.0 h"

  // 4. Temperatures
  print('\n--- Temperature ---');
  final roomTempC = 20.celsius;
  print('Room Temperature: $roomTempC');
  print('Room Temperature in Fahrenheit: ${roomTempC.inFahrenheit} ¬∞F');
  print(
    'Room Temperature in Kelvin: ${roomTempC.convertTo(TemperatureUnit.kelvin)}',
  );

  final boilingPoint = 100.celsius;
  final freezingPoint = 0.celsius;
  final tempDifference = boilingPoint - freezingPoint; // Returns a double
  print('Difference between boiling and freezing point of water: $tempDifference C¬∞');

  // Caution with temperature division (consider physical meaning)
  try {
    final tempRatio = 200.kelvin / 100.kelvin; // Meaningful
    print('Ratio 200K / 100K: $tempRatio');
    // final problematicRatio = 20.celsius / 10.celsius; // Mathematically 2.0, but often not directly interpretable physically
    // print('Ratio 20¬∞C / 10¬∞C: $problematicRatio');
  } on Exception catch (e) {
    print('Error during temperature division: $e');
  }

  // 5. Pressures
  print('\n--- Pressure ---');
  final pAtm = 1.atm; // Standard atmosphere
  print('Standard Atmosphere: $pAtm');
  print('Standard Atmosphere in Pascals: ${pAtm.inPa} Pa');
  print('Standard Atmosphere in PSI: ${pAtm.asPsi.toString(fractionDigits: 2)}');
  print(
    'Standard Atmosphere in bar: ${pAtm.toString(targetUnit: PressureUnit.bar, fractionDigits: 3)}',
  );

  final tirePressure = 32.psi;
  print('Tire Pressure: ${tirePressure.toString(targetUnit: PressureUnit.bar, fractionDigits: 2)}');

  // 6. Comparisons
  print('\n--- Comparisons ---');
  final oneKm = 1.km;
  final oneMile = 1.mi;
  final thousandMeters = 1000.m; // Using .m

  print(
    '1 km == 1000 m (value & unit): ${oneKm == thousandMeters}',
  ); // false (same value, but km vs m unit)
  print('1 km.compareTo(1000 m): ${oneKm.compareTo(thousandMeters)}'); // 0 (same magnitude)
  print('1 km > 1 mile: ${oneKm.compareTo(oneMile) > 0}'); // false
  // print('1 mile > 1 km: ${oneMile > oneKm}'); // true (syntactic sugar for compareTo)

  final lengths = [10.m, 500.cm, 0.002.km, 1.ft];
  print(
    'Unsorted lengths: ${lengths.map((l) => l.toString(targetUnit: LengthUnit.meter)).toList()}',
  );
  lengths.sort();
  print('Sorted lengths: ${lengths.map((l) => l.toString(targetUnit: LengthUnit.meter)).toList()}');

  // 7. Locale-specific Formatting (requires 'intl' package)
  print('\n--- Locale-specific Formatting ---');
  final distanceDE = 1234.567.m; // Using .m
  // Standard (US-like locale from Dart, usually '.')
  print(
    'Distance DE (default locale): ${distanceDE.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2)}',
  );

  // German (de_DE)
  // To use NumberFormat for a specific locale, it needs to be initialized.
  // Usually, this is done globally with `Intl.defaultLocale = 'de_DE';`
  // or it's passed directly to `NumberFormat`.
  // quantify's toString() uses NumberFormat.decimalPatternDigits if locale and fractionDigits are given.
  print(
    'Distance DE (de_DE locale): ${distanceDE.toString(targetUnit: LengthUnit.kilometer, fractionDigits: 2, locale: 'de_DE')}',
  );
  // Output: "1,23 km" (with comma as decimal separator)

  // With a custom NumberFormat for decimal pattern
  final valueOnlyFormat = NumberFormat.decimalPatternDigits(locale: 'fr_FR', decimalDigits: 3);
  print(
    'Distance (fr_FR locale, custom NumberFormat, value only): ${distanceDE.toString(numberFormat: valueOnlyFormat, showUnitSymbol: false, targetUnit: LengthUnit.kilometer)}',
  );
  // Output: "1,235" (with comma as decimal separator and 3 decimal places)

  print('\n--- End of Example ---');
}

<!-- END FILE: [v0.2.0] example/quantify_cli_example.dart -->

<!-- BEGIN FILE: [v0.2.0] test/units/current_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming Current and CurrentUnit are exported
import 'package:test/test.dart';

void main() {
  group('Current', () {
    const strictTolerance = 1e-12; // For "exact" conversions or small scales
    const defaultTolerance = 1e-9; // General purpose
    const looseTolerance = 1e-6; // For conversions over many orders of magnitude

    // Helper for round trip tests
    void testRoundTrip(
      CurrentUnit initialUnit,
      CurrentUnit intermediateUnit,
      double initialValue, {
      double tol = defaultTolerance,
    }) {
      final c1 = Current(initialValue, initialUnit);
      final c2 = c1.convertTo(intermediateUnit);
      final c3 = c2.convertTo(initialUnit);
      expect(
        c3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${c3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create Current from num extensions and retrieve values correctly', () {
        final curA = 1.5.A; // Using symbol extension
        expect(curA.value, 1.5);
        expect(curA.unit, CurrentUnit.ampere);
        expect(curA.inMilliamperes, closeTo(1500.0, strictTolerance));
        expect(curA.asMilliamperes.value, closeTo(1500.0, strictTolerance));
        expect(curA.asMilliamperes.unit, CurrentUnit.milliampere);

        final curMA = 250.0.milliamperes; // Using alias
        expect(curMA.value, 250.0);
        expect(curMA.unit, CurrentUnit.milliampere);
        expect(curMA.inAmperes, closeTo(0.25, strictTolerance));

        final curUA = 123.0.uA;
        expect(curUA.value, 123.0);
        expect(curUA.unit, CurrentUnit.microampere);
        expect(curUA.inAmperes, closeTo(0.000123, strictTolerance));
        expect(curUA.inNanoamperes, closeTo(123000.0, defaultTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const current = Current(0.01, CurrentUnit.ampere);
        expect(current.getValue(CurrentUnit.ampere), 0.01);
      });
    });

    group('Conversions between various current units', () {
      final oneAmpere = 1.0.A;
      test('1 Ampere to other units', () {
        expect(oneAmpere.inKiloamperes, closeTo(0.001, strictTolerance));
        expect(oneAmpere.inMilliamperes, closeTo(1000.0, strictTolerance));
        expect(oneAmpere.inMicroamperes, closeTo(1.0e6, strictTolerance));
        expect(oneAmpere.inNanoamperes, closeTo(1.0e9, looseTolerance)); // Larger scale
      });

      final oneKiloampere = 1.0.kA;
      test('1 Kiloampere to amperes', () {
        expect(oneKiloampere.inAmperes, closeTo(1000.0, strictTolerance));
      });

      final oneMilliampere = 1.0.mA;
      test('1 Milliampere to microamperes and amperes', () {
        expect(oneMilliampere.inMicroamperes, closeTo(1000.0, strictTolerance));
        expect(oneMilliampere.inAmperes, closeTo(0.001, strictTolerance));
      });

      final fiftyMicroamperes = 50.0.uA;
      test('50 Microamperes to nanoamperes and milliamperes', () {
        expect(fiftyMicroamperes.inNanoamperes, closeTo(50000.0, defaultTolerance));
        expect(fiftyMicroamperes.inMilliamperes, closeTo(0.05, strictTolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Current object with converted value and unit', () {
        final curMA = 1250.0.mA;
        final curA = curMA.convertTo(CurrentUnit.ampere);

        expect(curA.unit, CurrentUnit.ampere);
        expect(curA.value, closeTo(1.25, strictTolerance));
        expect(curMA.unit, CurrentUnit.milliampere); // Original should be unchanged
        expect(curMA.value, 1250.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final c1 = 0.1.A;
        final c2 = c1.convertTo(CurrentUnit.ampere);
        expect(identical(c1, c2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final c1A = 1.0.A;
      final c1000mA = 1000.0.mA;
      final c999mA = 999.0.mA;
      final c0_01kA = 0.01.kA; // 10 A
      final c0_0001kA = 0.0001.kA; // 0.1 A

      test('should correctly compare currents of different units', () {
        expect(c1A.compareTo(c999mA), greaterThan(0)); // 1A > 999mA
        expect(c999mA.compareTo(c1A), lessThan(0)); // 999mA < 1A
        expect(c1A.compareTo(c1000mA), 0); // 1A == 1000mA

        expect(c1A.compareTo(c0_01kA), lessThan(0)); // 1A < 10A
        expect(c1A.compareTo(c0_0001kA), greaterThan(0)); // 1A > 0.1A
      });

      test('should return 0 for equal currents in different units', () {
        final cInUA = 1000000.0.uA; // 1 A in microamperes
        expect(c1A.compareTo(cInUA), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const c1 = Current(0.05, CurrentUnit.ampere);
        const c2 = Current(0.05, CurrentUnit.ampere);
        expect(c1 == c2, isTrue);
        expect(c1.hashCode == c2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const c1 = Current(0.05, CurrentUnit.ampere);
        const c2Diffval = Current(0.051, CurrentUnit.ampere);
        const c3Diffunit = Current(0.05, CurrentUnit.milliampere);

        expect(c1 == c2Diffval, isFalse);
        expect(c1 == c3Diffunit, isFalse);

        expect(c1.hashCode == c2Diffval.hashCode, isFalse);
        expect(c1.hashCode == c3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.A is not equal to 1000.mA', () {
        final oneAmp = 1.A;
        final thousandMilliamp = 1000.mA;
        expect(oneAmp == thousandMilliamp, isFalse);
        expect(oneAmp.compareTo(thousandMilliamp), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(2.5.A.toString(), '2.5\u00A0A');
        expect(15.mA.toString(), '15.0\u00A0mA');
        expect(123.microamperes.toString(), '123.0\u00A0¬µA'); // Note ¬µ symbol
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 0.0123456789;

      for (final unit in CurrentUnit.values) {
        test('Round trip ${unit.symbol} <-> A', () {
          testRoundTrip(
            unit,
            CurrentUnit.ampere,
            testValue,
            tol: (unit == CurrentUnit.ampere ||
                    unit == CurrentUnit.milliampere ||
                    unit == CurrentUnit.kiloampere)
                ? strictTolerance
                : looseTolerance,
          );
        });
      }

      test('Round trip mA <-> ¬µA', () {
        testRoundTrip(CurrentUnit.milliampere, CurrentUnit.microampere, 0.5, tol: strictTolerance);
      });
      test('Round trip ¬µA <-> nA', () {
        testRoundTrip(CurrentUnit.microampere, CurrentUnit.nanoampere, 0.005, tol: strictTolerance);
      });
      test('Round trip A <-> kA', () {
        testRoundTrip(CurrentUnit.ampere, CurrentUnit.kiloampere, 2500.0, tol: strictTolerance);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final cZeroA = 0.0.A;
        for (final unit in CurrentUnit.values) {
          expect(cZeroA.getValue(unit), 0.0, reason: '0 A to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with very small and large values', () {
        final verySmall = 1.0e-10.A; // picoampere range if unit existed
        expect(verySmall.inNanoamperes, closeTo(0.1, strictTolerance));

        final veryLarge = 1.0e4.A; // 10 kA
        expect(veryLarge.inKiloamperes, closeTo(10.0, strictTolerance));
      });
    });

    group('Arithmetic Operators for Current', () {
      final c1A = 1.0.A;
      final c2A = 2.0.A;
      final c500mA = 500.mA; // 0.5 A
      final c100uA = 100.uA; // 0.0001 A

      // Operator +
      test('operator + combines currents, result in unit of left operand', () {
        final sum1 = c2A + c1A;
        expect(sum1.value, closeTo(3.0, defaultTolerance));
        expect(sum1.unit, CurrentUnit.ampere);

        final sum2 = c1A + c500mA; // 1A + 0.5A = 1.5A
        expect(sum2.value, closeTo(1.5, defaultTolerance));
        expect(sum2.unit, CurrentUnit.ampere);

        final sum3 = c500mA + c1A; // 500mA + 1000mA = 1500mA
        expect(sum3.value, closeTo(1500.0, defaultTolerance));
        expect(sum3.unit, CurrentUnit.milliampere);

        final sum4 = c1A + c100uA; // 1A + 0.0001A
        expect(sum4.value, closeTo(1.0 + 0.0001, strictTolerance));
        expect(sum4.unit, CurrentUnit.ampere);
      });

      // Operator -
      test('operator - subtracts currents, result in unit of left operand', () {
        final diff1 = c2A - c1A;
        expect(diff1.value, closeTo(1.0, defaultTolerance));
        expect(diff1.unit, CurrentUnit.ampere);

        final diff2 = c1A - c500mA; // 1A - 0.5A = 0.5A
        expect(diff2.value, closeTo(0.5, defaultTolerance));
        expect(diff2.unit, CurrentUnit.ampere);

        final diff3 = c1A - c100uA; // 1A - 0.0001A
        expect(diff3.value, closeTo(1.0 - 0.0001, strictTolerance));
        expect(diff3.unit, CurrentUnit.ampere);
      });

      // Operator * (scalar)
      test('operator * scales current by a scalar', () {
        final scaled1 = c2A * 1.5;
        expect(scaled1.value, closeTo(3.0, defaultTolerance));
        expect(scaled1.unit, CurrentUnit.ampere);

        final scaled2 = c500mA * 0.2;
        expect(scaled2.value, closeTo(100.0, defaultTolerance));
        expect(scaled2.unit, CurrentUnit.milliampere);
      });

      // Operator / (scalar)
      test('operator / scales current by a scalar', () {
        final scaled1 = c2A / 5.0;
        expect(scaled1.value, closeTo(0.4, defaultTolerance));
        expect(scaled1.unit, CurrentUnit.ampere);

        final scaled2 = c1A / 0.02;
        expect(scaled2.value, closeTo(50.0, defaultTolerance));
        expect(scaled2.unit, CurrentUnit.ampere);

        expect(() => c1A / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialCurrent = 0.5.A;
        final cAdd = initialCurrent + 200.mA; // 0.5A + 0.2A = 0.7A
        final cMul = cAdd * 3.0; // 0.7A * 3 = 2.1A
        final cSub = cMul - 10000.uA; // 2.1A - 0.01A = 2.09A

        expect(initialCurrent.value, 0.5); // Original unchanged
        expect(initialCurrent.unit, CurrentUnit.ampere);

        expect(cAdd.value, closeTo(0.7, defaultTolerance));
        expect(cAdd.unit, CurrentUnit.ampere);

        expect(cMul.value, closeTo(2.1, defaultTolerance));
        expect(cMul.unit, CurrentUnit.ampere);

        final expectedCSubVal = 2.1 - 10000.0.uA.getValue(CurrentUnit.ampere);
        expect(cSub.value, closeTo(expectedCSubVal, strictTolerance));
        expect(cSub.unit, CurrentUnit.ampere);
      });
    });
  });
}

<!-- END FILE: [v0.2.0] test/units/current_test.dart -->

<!-- BEGIN FILE: [v0.2.0] test/units/length_test.dart -->
// ignore_for_file: prefer_int_literals : all constants are doubles.

import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons

  group('Length', () {
    // Helper for round trip tests
    void testRoundTrip(
      LengthUnit initialUnit,
      LengthUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final l1 = Length(initialValue, initialUnit);
      final l2 = l1.convertTo(intermediateUnit);
      final l3 = l2.convertTo(initialUnit);
      expect(
        l3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Length from num extensions and retrieve values', () {
        final l1 = 100.0.m;
        expect(l1.value, 100.0);
        expect(l1.unit, LengthUnit.meter);
        expect(l1.inKm, closeTo(0.1, tolerance));

        final l2 = 5.0.ft;
        expect(l2.value, 5.0);
        expect(l2.unit, LengthUnit.foot);
        expect(l2.inInch, closeTo(60.0, tolerance));

        final l3 = 12.inch;
        expect(l3.inFt, closeTo(1.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const l = Length(25.0, LengthUnit.centimeter);
        expect(l.getValue(LengthUnit.centimeter), 25.0);
      });

      test('getValue for all units from Meter base', () {
        final l = 1000.0.m; // 1 km
        expect(l.inM, 1000.0);
        expect(l.inKm, closeTo(1.0, tolerance));
        expect(l.inCm, closeTo(100000.0, tolerance));
        expect(l.inMm, closeTo(1000000.0, tolerance));
        expect(l.inInch, closeTo(1000.0 / 0.0254, 1e-7));
        expect(l.inFt, closeTo(1000.0 / 0.3048, 1e-7));
        expect(l.inYd, closeTo(1000.0 / 0.9144, 1e-7));
        expect(l.inMi, closeTo(1000.0 / 1609.344, 1e-7));
        expect(l.inNmi, closeTo(1000.0 / 1852.0, 1e-7));
      });
    });

    group('Conversions', () {
      final oneMeter = 1.0.m;

      test('1 meter to various units', () {
        expect(oneMeter.inKm, closeTo(0.001, tolerance));
        expect(oneMeter.inCm, closeTo(100.0, tolerance));
        expect(oneMeter.inMm, closeTo(1000.0, tolerance));
        expect(oneMeter.inInch, closeTo(1 / 0.0254, 1e-7)); // 39.3700787...
        expect(oneMeter.inFt, closeTo(1 / 0.3048, 1e-7)); // 3.2808398...
        expect(oneMeter.inYd, closeTo(1 / 0.9144, 1e-7)); // 1.0936132...
      });

      final oneFoot = 1.0.ft;
      test('1 foot to various units', () {
        expect(oneFoot.inM, closeTo(0.3048, tolerance));
        expect(oneFoot.inInch, closeTo(12.0, tolerance));
        expect(oneFoot.inYd, closeTo(1.0 / 3.0, tolerance));
      });

      final oneMile = 1.0.mi;
      test('1 mile to various units', () {
        expect(oneMile.inM, closeTo(1609.344, tolerance));
        expect(oneMile.inFt, closeTo(5280.0, tolerance));
        expect(oneMile.inYd, closeTo(1760.0, tolerance));
        expect(oneMile.inKm, closeTo(1.609344, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Length object with converted value and unit', () {
        final lMeters = 10.0.m;
        final lFeet = lMeters.convertTo(LengthUnit.foot);
        expect(lFeet.unit, LengthUnit.foot);
        expect(lFeet.value, closeTo(lMeters.inFt, tolerance));
        expect(lMeters.unit, LengthUnit.meter); // Original should be unchanged
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final l1 = 10.0.m;
        final l2 = l1.convertTo(LengthUnit.meter);
        expect(identical(l1, l2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final lMeter = 1.0.m;
      final lSlightlyLessCm = 99.0.cm;
      final lSlightlyMoreCm = 101.0.cm;
      final lFoot = 3.0.ft; // 0.9144 meters

      test('should correctly compare lengths of different units', () {
        expect(lMeter.compareTo(lSlightlyLessCm), greaterThan(0));
        expect(lSlightlyLessCm.compareTo(lMeter), lessThan(0));
        expect(lMeter.compareTo(lSlightlyMoreCm), lessThan(0));
        expect(lMeter.compareTo(lFoot), greaterThan(0)); // 1m > 3ft
      });

      test('should return 0 for equal lengths in different units', () {
        final lCm = 100.0.cm;
        final lInches = (1.0 / 0.0254).inch; // 1 meter in inches
        expect(lMeter.compareTo(lCm), 0);
        expect(lCm.compareTo(lMeter), 0);
        expect(lMeter.compareTo(lInches), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const l1 = Length(10.0, LengthUnit.meter);
        const l2 = Length(10.0, LengthUnit.meter);
        expect(l1 == l2, isTrue);
        expect(l1.hashCode == l2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const l1 = Length(10.0, LengthUnit.meter);
        const l2 = Length(10.1, LengthUnit.meter);
        const l3 = Length(10.0, LengthUnit.foot);
        expect(l1 == l2, isFalse);
        expect(l1 == l3, isFalse);
        expect(l1.hashCode == l2.hashCode, isFalse);
        expect(l1.hashCode == l3.hashCode, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(10.5.m.toString(), '10.5¬†m');
        expect(12.0.inch.toString(), '12.0¬†in');
        expect(1.6.km.toString(), '1.6¬†km');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 789.123;
      const highTolerance = 1e-7; // For chains of conversions

      for (final unit in LengthUnit.values) {
        test('Round trip ${unit.symbol} <-> m', () {
          testRoundTrip(
            unit,
            LengthUnit.meter,
            testValue,
            tolerance: (unit == LengthUnit.meter) ? tolerance : highTolerance,
          );
        });
      }

      test('Round trip ft <-> in', () {
        testRoundTrip(LengthUnit.foot, LengthUnit.inch, testValue);
      });
      test('Round trip yd <-> mi', () {
        testRoundTrip(LengthUnit.yard, LengthUnit.mile, 5000.0, tolerance: highTolerance);
      });
      test('Round trip cm <-> km', () {
        testRoundTrip(
          LengthUnit.centimeter,
          LengthUnit.kilometer,
          250000.0,
          tolerance: highTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final lZero = 0.0.m;
        for (final unit in LengthUnit.values) {
          expect(lZero.getValue(unit), 0.0, reason: '0 m to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for Length', () {
      final l1Meter = 1.0.m;
      final l2Meters = 2.0.m;
      final l50Cm = 50.cm; // 0.5 meters

      // Operator +
      test('operator + combines lengths', () {
        final sum1 = l2Meters + l1Meter;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, LengthUnit.meter);

        final sum2 = l1Meter + l50Cm; // 1m + 0.5m = 1.5m
        expect(sum2.value, closeTo(1.5, tolerance));
        expect(sum2.unit, LengthUnit.meter);

        final sum3 = l50Cm + l1Meter; // 50cm + 100cm = 150cm
        expect(sum3.value, closeTo(150.0, tolerance));
        expect(sum3.unit, LengthUnit.centimeter);
      });

      // Operator -
      test('operator - subtracts lengths', () {
        final diff1 = l2Meters - l1Meter;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, LengthUnit.meter);

        final diff2 = l1Meter - l50Cm; // 1m - 0.5m = 0.5m
        expect(diff2.value, closeTo(0.5, tolerance));
        expect(diff2.unit, LengthUnit.meter);

        final diff3 = l2Meters - l50Cm.convertTo(LengthUnit.meter); // 2m - 0.5m = 1.5m
        expect(diff3.value, closeTo(1.5, tolerance));
        expect(diff3.unit, LengthUnit.meter);
      });

      // Operator * (scalar)
      test('operator * scales length by a scalar', () {
        final scaled = l2Meters * 3.0;
        expect(scaled.value, closeTo(6.0, tolerance));
        expect(scaled.unit, LengthUnit.meter);

        final scaledCm = l50Cm * 2.5;
        expect(scaledCm.value, closeTo(125.0, tolerance));
        expect(scaledCm.unit, LengthUnit.centimeter);
      });

      // Operator / (scalar)
      test('operator / scales length by a scalar', () {
        final scaled = l2Meters / 2.0;
        expect(scaled.value, closeTo(1.0, tolerance));
        expect(scaled.unit, LengthUnit.meter);

        expect(() => l1Meter / 0.0, throwsArgumentError);
      });

      test('operator chaining preserves immutability', () {
        final initialLength = 10.m;
        final l1 = initialLength + 5.m; // 15m
        final l2 = l1 * 2.0; // 30m
        final l3 = l2 - 100.cm; // 30m - 1m = 29m

        expect(initialLength.value, 10.0); // Original unchanged
        expect(l1.value, closeTo(15.0, tolerance));
        expect(l2.value, closeTo(30.0, tolerance));
        expect(l3.value, closeTo(29.0, tolerance));
        expect(l3.unit, LengthUnit.meter);
      });
    });
  });
}

<!-- END FILE: [v0.2.0] test/units/length_test.dart -->

<!-- BEGIN FILE: [v0.2.0] test/units/luminous_intensity_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming LuminousIntensity and Unit are exported
import 'package:test/test.dart';

void main() {
  group('LuminousIntensity', () {
    const strictTolerance = 1e-12; // For "exact" conversions
    const defaultTolerance = 1e-9; // General purpose

    // Helper for round trip tests
    void testRoundTrip(
      LuminousIntensityUnit initialUnit,
      LuminousIntensityUnit intermediateUnit,
      double initialValue, {
      double tol = defaultTolerance,
    }) {
      final li1 = LuminousIntensity(initialValue, initialUnit);
      final li2 = li1.convertTo(intermediateUnit);
      final li3 = li2.convertTo(initialUnit);
      expect(
        li3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${li3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create LuminousIntensity from num extensions and retrieve values', () {
        final liCd = 100.0.cd;
        expect(liCd.value, 100.0);
        expect(liCd.unit, LuminousIntensityUnit.candela);
        expect(liCd.inMillicandelas, closeTo(100000.0, strictTolerance));
        expect(liCd.asMillicandelas.value, closeTo(100000.0, strictTolerance));
        expect(liCd.asMillicandelas.unit, LuminousIntensityUnit.millicandela);

        final liMcd = 250.0.millicandelas; // Using alias
        expect(liMcd.value, 250.0);
        expect(liMcd.unit, LuminousIntensityUnit.millicandela);
        expect(liMcd.inCandelas, closeTo(0.25, strictTolerance));

        final liKcd = 0.5.kcd;
        expect(liKcd.value, 0.5);
        expect(liKcd.unit, LuminousIntensityUnit.kilocandela);
        expect(liKcd.inCandelas, closeTo(500.0, strictTolerance));
      });

      test('getValue should return correct value for same unit', () {
        const intensity = LuminousIntensity(15.0, LuminousIntensityUnit.candela);
        expect(intensity.getValue(LuminousIntensityUnit.candela), 15.0);
      });
    });

    group('Conversions between various luminous intensity units', () {
      final oneCandela = 1.0.cd;
      test('1 Candela to other units', () {
        expect(oneCandela.inMillicandelas, closeTo(1000.0, strictTolerance));
        expect(oneCandela.inKilocandelas, closeTo(0.001, strictTolerance));
      });

      final oneKilocandela = 1.0.kcd;
      test('1 Kilocandela to candelas and millicandelas', () {
        expect(oneKilocandela.inCandelas, closeTo(1000.0, strictTolerance));
        expect(oneKilocandela.inMillicandelas, closeTo(1000000.0, strictTolerance));
      });

      final oneMillicandela = 1.0.mcd;
      test('1 Millicandela to candelas', () {
        expect(oneMillicandela.inCandelas, closeTo(0.001, strictTolerance));
      });
    });

    group('convertTo method', () {
      test('should return new LuminousIntensity object with converted value and unit', () {
        final liMcd = 12500.0.mcd;
        final liCd = liMcd.convertTo(LuminousIntensityUnit.candela);

        expect(liCd.unit, LuminousIntensityUnit.candela);
        expect(liCd.value, closeTo(12.5, strictTolerance));
        expect(liMcd.unit, LuminousIntensityUnit.millicandela); // Original unchanged
        expect(liMcd.value, 12500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final li1 = 10.0.cd;
        final li2 = li1.convertTo(LuminousIntensityUnit.candela);
        expect(identical(li1, li2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final li1Cd = 1.0.cd;
      final li1000Mcd = 1000.0.mcd;
      final li999Mcd = 999.0.mcd;
      final li0_002Kcd = 0.002.kcd; // 2 cd
      final li0_0005Kcd = 0.0005.kcd; // 0.5 cd

      test('should correctly compare luminous intensities of different units', () {
        expect(li1Cd.compareTo(li999Mcd), greaterThan(0)); // 1cd > 999mcd
        expect(li999Mcd.compareTo(li1Cd), lessThan(0)); // 999mcd < 1cd
        expect(li1Cd.compareTo(li1000Mcd), 0); // 1cd == 1000mcd

        expect(li1Cd.compareTo(li0_002Kcd), lessThan(0)); // 1cd < 2cd
        expect(li1Cd.compareTo(li0_0005Kcd), greaterThan(0)); // 1cd > 0.5cd
      });

      test('should return 0 for equal luminous intensities in different units', () {
        final liInKcd = 0.001.kcd; // 1 cd in kilocandelas
        expect(li1Cd.compareTo(liInKcd), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const li1 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        const li2 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        expect(li1 == li2, isTrue);
        expect(li1.hashCode == li2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const li1 = LuminousIntensity(50.0, LuminousIntensityUnit.candela);
        const li2Diffval = LuminousIntensity(50.1, LuminousIntensityUnit.candela);
        const li3Diffunit = LuminousIntensity(50.0, LuminousIntensityUnit.millicandela);

        expect(li1 == li2Diffval, isFalse);
        expect(li1 == li3Diffunit, isFalse);

        expect(li1.hashCode == li2Diffval.hashCode, isFalse);
        expect(li1.hashCode == li3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.cd is not equal to 1000.mcd', () {
        final oneCd = 1.cd;
        final thousandMcd = 1000.mcd;
        expect(oneCd == thousandMcd, isFalse);
        expect(oneCd.compareTo(thousandMcd), 0);
      });
    });

    group('toString() (basic check)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(75.5.cd.toString(), '75.5\u00A0cd');
        expect(120.mcd.toString(), '120.0\u00A0mcd');
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 123.456;

      for (final unit in LuminousIntensityUnit.values) {
        test('Round trip ${unit.symbol} <-> cd', () {
          testRoundTrip(
            unit,
            LuminousIntensityUnit.candela,
            testValue,
            tol: strictTolerance, // Factors are exact powers of 10
          );
        });
      }

      test('Round trip mcd <-> kcd', () {
        // Test with a value that doesn't become too small/large after conversion
        testRoundTrip(
          LuminousIntensityUnit.millicandela,
          LuminousIntensityUnit.kilocandela,
          500000.0,
          tol: strictTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final liZeroCd = 0.0.cd;
        for (final unit in LuminousIntensityUnit.values) {
          expect(liZeroCd.getValue(unit), 0.0, reason: '0 cd to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for LuminousIntensity', () {
      final li100cd = 100.0.cd;
      final li200cd = 200.0.cd;
      final li50000mcd = 50000.0.mcd; // 50 cd

      // Operator +
      test('operator + combines luminous intensities', () {
        final sum1 = li200cd + li100cd;
        expect(sum1.value, closeTo(300.0, defaultTolerance));
        expect(sum1.unit, LuminousIntensityUnit.candela);

        final sum2 = li100cd + li50000mcd; // 100cd + 50cd = 150cd
        expect(sum2.value, closeTo(150.0, defaultTolerance));
        expect(sum2.unit, LuminousIntensityUnit.candela);

        final sum3 = li50000mcd + li100cd; // 50000mcd + 100000mcd = 150000mcd
        expect(sum3.value, closeTo(150000.0, defaultTolerance));
        expect(sum3.unit, LuminousIntensityUnit.millicandela);
      });

      // Operator -
      test('operator - subtracts luminous intensities', () {
        final diff1 = li200cd - li100cd;
        expect(diff1.value, closeTo(100.0, defaultTolerance));
        expect(diff1.unit, LuminousIntensityUnit.candela);

        final diff2 = li100cd - li50000mcd; // 100cd - 50cd = 50cd
        expect(diff2.value, closeTo(50.0, defaultTolerance));
        expect(diff2.unit, LuminousIntensityUnit.candela);
      });

      // Operator * (scalar)
      test('operator * scales luminous intensity by a scalar', () {
        final scaled1 = li100cd * 2.5;
        expect(scaled1.value, closeTo(250.0, defaultTolerance));
        expect(scaled1.unit, LuminousIntensityUnit.candela);
      });

      // Operator / (scalar)
      test('operator / scales luminous intensity by a scalar', () {
        final scaled1 = li200cd / 4.0;
        expect(scaled1.value, closeTo(50.0, defaultTolerance));
        expect(scaled1.unit, LuminousIntensityUnit.candela);

        expect(() => li100cd / 0.0, throwsArgumentError);
      });

      test('operator chaining preserves immutability', () {
        final initialIntensity = 50.cd;
        final liAdd = initialIntensity + 10000.mcd; // 50cd + 10cd = 60cd
        final liMul = liAdd * 2.0; // 60cd * 2 = 120cd
        final liSub = liMul - 0.01.kcd; // 120cd - 10cd = 110cd

        expect(initialIntensity.value, 50.0);
        expect(initialIntensity.unit, LuminousIntensityUnit.candela);

        expect(liAdd.value, closeTo(60.0, defaultTolerance));
        expect(liAdd.unit, LuminousIntensityUnit.candela);

        expect(liMul.value, closeTo(120.0, defaultTolerance));
        expect(liMul.unit, LuminousIntensityUnit.candela);

        final expectedLiSubVal = 120.0 - 0.01.kcd.getValue(LuminousIntensityUnit.candela);
        expect(liSub.value, closeTo(expectedLiSubVal, defaultTolerance));
        expect(liSub.unit, LuminousIntensityUnit.candela);
      });
    });
  });
}

<!-- END FILE: [v0.2.0] test/units/luminous_intensity_test.dart -->

<!-- BEGIN FILE: [v0.2.0] test/units/mass_test.dart -->
// BEGIN FILE: test/units/mass_test.dart
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming Mass and MassUnit are exported via quantify.dart
import 'package:test/test.dart';

void main() {
  group('Mass', () {
    const tolerance = 1e-9; // Tolerance for double comparisons
    const highTolerance = 1e-7; // Higher tolerance for chained conversions or inexact factors

    // Helper for round trip tests
    void testRoundTrip(
      MassUnit initialUnit,
      MassUnit intermediateUnit,
      double initialValue, {
      double tol = highTolerance, // Use highTolerance as default for round trips
    }) {
      final m1 = Mass(initialValue, initialUnit);
      final m2 = m1.convertTo(intermediateUnit);
      final m3 = m2.convertTo(initialUnit);
      expect(
        m3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${m3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create Mass from num extensions and retrieve values correctly', () {
        final mKg = 10.0.kg;
        expect(mKg.value, 10.0);
        expect(mKg.unit, MassUnit.kilogram);
        expect(mKg.inGrams, closeTo(10000.0, tolerance));
        expect(mKg.asGrams.value, closeTo(10000.0, tolerance));
        expect(mKg.asGrams.unit, MassUnit.gram);

        final mGrams = 500.0.grams; // Using alias
        expect(mGrams.value, 500.0);
        expect(mGrams.unit, MassUnit.gram);
        expect(mGrams.inKilograms, closeTo(0.5, tolerance));

        final mLbs = 2.0.pounds; // Using alias
        expect(mLbs.value, 2.0);
        expect(mLbs.unit, MassUnit.pound);
        // 2 lb * 0.45359237 kg/lb = 0.90718474 kg
        expect(mLbs.inKilograms, closeTo(0.90718474, highTolerance));

        final mOz = 16.0.oz; // 1 pound
        expect(mOz.value, 16.0);
        expect(mOz.unit, MassUnit.ounce);
        expect(mOz.inPounds, closeTo(1.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const mass = Mass(25.0, MassUnit.gram);
        expect(mass.getValue(MassUnit.gram), 25.0);
      });
    });

    group('Conversions between various units', () {
      final oneKg = 1.0.kg;
      test('1 Kilogram to other units', () {
        expect(oneKg.inGrams, closeTo(1000.0, tolerance));
        expect(oneKg.inMilligrams, closeTo(1000000.0, tolerance));
        expect(oneKg.inTonnes, closeTo(0.001, tolerance));
        expect(oneKg.inPounds, closeTo(1.0 / 0.45359237, highTolerance)); // ~2.20462 lbs
        expect(oneKg.inOunces, closeTo(16.0 / 0.45359237, highTolerance)); // ~35.27396 oz
        expect(oneKg.inStones, closeTo(1.0 / (14.0 * 0.45359237), highTolerance)); // ~0.15747 st
        expect(oneKg.inSlugs, closeTo(1.0 / 14.5939029372, highTolerance)); // ~0.06852 slugs
      });

      final onePound = 1.0.lb;
      test('1 Pound to other units', () {
        expect(onePound.inKilograms, closeTo(0.45359237, tolerance));
        expect(onePound.inGrams, closeTo(453.59237, tolerance));
        expect(onePound.inOunces, closeTo(16.0, tolerance));
        expect(onePound.inStones, closeTo(1.0 / 14.0, highTolerance));
      });

      final oneOunce = 1.0.oz;
      test('1 Ounce to grams', () {
        expect(oneOunce.inGrams, closeTo(0.45359237 * 1000.0 / 16.0, highTolerance)); // ~28.3495 g
      });

      final oneTonne = 1.0.t;
      test('1 Tonne to kilograms and pounds', () {
        expect(oneTonne.inKilograms, closeTo(1000.0, tolerance));
        expect(oneTonne.inPounds, closeTo(1000.0 / 0.45359237, highTolerance));
      });

      final oneSlug = 1.0.slugs;
      test('1 Slug to kilograms and pounds', () {
        expect(oneSlug.inKilograms, closeTo(14.5939029372, tolerance));
        expect(oneSlug.inPounds, closeTo(14.5939029372 / 0.45359237, highTolerance)); // ~32.174 lbs
      });
    });

    group('convertTo method', () {
      test('should return new Mass object with converted value and unit', () {
        final massGrams = 1500.0.g;
        final massKilograms = massGrams.convertTo(MassUnit.kilogram);

        expect(massKilograms.unit, MassUnit.kilogram);
        expect(massKilograms.value, closeTo(1.5, tolerance));
        expect(massGrams.unit, MassUnit.gram); // Original should be unchanged
        expect(massGrams.value, 1500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final m1 = 10.0.kg;
        final m2 = m1.convertTo(MassUnit.kilogram);
        expect(identical(m1, m2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final m1Kg = 1.0.kg;
      final m1000g = 1000.0.g;
      final m999g = 999.0.g;
      final m2lb = 2.0.lb; // approx 0.907 kg
      final m3lb = 3.0.lb; // approx 1.360 kg

      test('should correctly compare masses of different units', () {
        expect(m1Kg.compareTo(m999g), greaterThan(0)); // 1kg > 999g
        expect(m999g.compareTo(m1Kg), lessThan(0)); // 999g < 1kg
        expect(m1Kg.compareTo(m1000g), 0); // 1kg == 1000g

        expect(m1Kg.compareTo(m2lb), greaterThan(0)); // 1kg > 2lb
        expect(m1Kg.compareTo(m3lb), lessThan(0)); // 1kg < 3lb
      });

      test('should return 0 for equal masses in different units', () {
        final mInLbs = (1.0 / 0.45359237).pounds; // 1 kg in pounds
        expect(m1Kg.compareTo(mInLbs), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const m1 = Mass(10.0, MassUnit.kilogram);
        const m2 = Mass(10.0, MassUnit.kilogram);
        expect(m1 == m2, isTrue);
        expect(m1.hashCode == m2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const m1 = Mass(10.0, MassUnit.kilogram);
        const m2Diffval = Mass(10.1, MassUnit.kilogram);
        const m3Diffunit = Mass(10.0, MassUnit.gram);
        const m4Diffvalandunit = Mass(1.0, MassUnit.pound);

        expect(m1 == m2Diffval, isFalse);
        expect(m1 == m3Diffunit, isFalse);
        expect(m1 == m4Diffvalandunit, isFalse);

        expect(m1.hashCode == m2Diffval.hashCode, isFalse);
        // Hash collisions are possible but unlikely for these simple diffs
        expect(m1.hashCode == m3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.kg is not equal to 1000.g', () {
        // This confirms that `==` checks unit, not just magnitude.
        // For magnitude, `compareTo` is used.
        final oneKg = 1.kg;
        final thousandGrams = 1000.g;
        expect(oneKg == thousandGrams, isFalse);
        expect(oneKg.compareTo(thousandGrams), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(10.5.kg.toString(), '10.5\u00A0kg'); // \u00A0 is non-breaking space
        expect(500.grams.toString(), '500.0\u00A0g');
        expect(2.2.pounds.toString(), '2.2\u00A0lb');
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 123.456;

      // Test all units via Kilogram (the base for MassUnit)
      for (final unit in MassUnit.values) {
        test('Round trip ${unit.symbol} <-> kg', () {
          testRoundTrip(
            unit,
            MassUnit.kilogram,
            testValue,
            tol: (unit == MassUnit.kilogram) ? tolerance : highTolerance,
          );
        });
      }

      // Test some other common pairs
      test('Round trip g <-> mg', () {
        testRoundTrip(MassUnit.gram, MassUnit.milligram, testValue);
      });
      test('Round trip lb <-> oz', () {
        testRoundTrip(MassUnit.pound, MassUnit.ounce, testValue);
      });
      test('Round trip lb <-> st', () {
        testRoundTrip(
          MassUnit.pound,
          MassUnit.stone,
          28.0,
        ); // Test with a value that easily converts
      });
      test('Round trip kg <-> tonne', () {
        testRoundTrip(MassUnit.kilogram, MassUnit.tonne, 5000.0);
      });
      test('Round trip kg <-> slug', () {
        testRoundTrip(MassUnit.kilogram, MassUnit.slug, testValue);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final mZeroKg = 0.0.kg;
        for (final unit in MassUnit.values) {
          expect(mZeroKg.getValue(unit), 0.0, reason: '0 kg to ${unit.symbol} should be 0');
        }

        final mZeroLb = 0.0.lb;
        for (final unit in MassUnit.values) {
          expect(mZeroLb.getValue(unit), 0.0, reason: '0 lb to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with negative value (mass is typically positive, but math should work)', () {
        final mNegativeKg = (-10.0).kg;
        expect(mNegativeKg.inGrams, closeTo(-10000.0, tolerance));
        expect(mNegativeKg.inPounds, closeTo(-10.0 / 0.45359237, highTolerance));
      });
    });

    group('Arithmetic Operators for Mass', () {
      final m1kg = 1.0.kg;
      final m2kg = 2.0.kg;
      final m500g = 500.g; // 0.5 kg
      final m1lb = 1.lb; // 0.45359237 kg

      // Operator +
      test('operator + combines masses, result in unit of left operand', () {
        final sum1 = m2kg + m1kg;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, MassUnit.kilogram);

        final sum2 = m1kg + m500g; // 1kg + 0.5kg = 1.5kg
        expect(sum2.value, closeTo(1.5, tolerance));
        expect(sum2.unit, MassUnit.kilogram);

        final sum3 = m500g + m1kg; // 500g + 1000g = 1500g
        expect(sum3.value, closeTo(1500.0, tolerance));
        expect(sum3.unit, MassUnit.gram);

        final sum4 = m1kg + m1lb; // 1kg + 0.45359237kg
        expect(sum4.value, closeTo(1.0 + 0.45359237, highTolerance));
        expect(sum4.unit, MassUnit.kilogram);
      });

      // Operator -
      test('operator - subtracts masses, result in unit of left operand', () {
        final diff1 = m2kg - m1kg;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, MassUnit.kilogram);

        final diff2 = m1kg - m500g; // 1kg - 0.5kg = 0.5kg
        expect(diff2.value, closeTo(0.5, tolerance));
        expect(diff2.unit, MassUnit.kilogram);

        final diff3 = m1kg - m1lb; // 1kg - 0.45359237kg
        expect(diff3.value, closeTo(1.0 - 0.45359237, highTolerance));
        expect(diff3.unit, MassUnit.kilogram);
      });

      // Operator * (scalar)
      test('operator * scales mass by a scalar', () {
        final scaled1 = m2kg * 3.5;
        expect(scaled1.value, closeTo(7.0, tolerance));
        expect(scaled1.unit, MassUnit.kilogram);

        final scaled2 = m500g * 0.5;
        expect(scaled2.value, closeTo(250.0, tolerance));
        expect(scaled2.unit, MassUnit.gram);
      });

      // Operator / (scalar)
      test('operator / scales mass by a scalar', () {
        final scaled1 = m2kg / 4.0;
        expect(scaled1.value, closeTo(0.5, tolerance));
        expect(scaled1.unit, MassUnit.kilogram);

        final scaled2 = m1kg / 0.1;
        expect(scaled2.value, closeTo(10.0, tolerance));
        expect(scaled2.unit, MassUnit.kilogram);

        expect(() => m1kg / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialMass = 10.kg;
        final mAdd = initialMass + 500.g; // 10kg + 0.5kg = 10.5kg
        final mMul = mAdd * 2.0; // 10.5kg * 2 = 21kg
        final mSub = mMul - 1.lb; // 21kg - ~0.45kg

        expect(initialMass.value, 10.0); // Original unchanged
        expect(initialMass.unit, MassUnit.kilogram);

        expect(mAdd.value, closeTo(10.5, tolerance));
        expect(mAdd.unit, MassUnit.kilogram);

        expect(mMul.value, closeTo(21.0, tolerance));
        expect(mMul.unit, MassUnit.kilogram);

        final expectedMSubVal = 21.0 - 1.0.lb.getValue(MassUnit.kilogram);
        expect(mSub.value, closeTo(expectedMSubVal, highTolerance));
        expect(mSub.unit, MassUnit.kilogram);
      });
    });
  });
}
// END FILE: test/units/mass_test.dart

<!-- END FILE: [v0.2.0] test/units/mass_test.dart -->

<!-- BEGIN FILE: [v0.2.0] test/units/molar_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart'; // Assuming MolarAmount and MolarUnit are exported
import 'package:test/test.dart';

void main() {
  group('MolarAmount', () {
    const tolerance = 1e-12; // Molar amounts can be very small, requiring higher precision
    const defaultTolerance = 1e-9; // For general comparisons

    // Helper for round trip tests
    void testRoundTrip(
      MolarUnit initialUnit,
      MolarUnit intermediateUnit,
      double initialValue, {
      double tol = tolerance, // Default to higher precision for molar round trips
    }) {
      final ma1 = MolarAmount(initialValue, initialUnit);
      final ma2 = ma1.convertTo(intermediateUnit);
      final ma3 = ma2.convertTo(initialUnit);
      expect(
        ma3.value,
        closeTo(initialValue, tol),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue. Expected $initialValue, got ${ma3.value}',
      );
    }

    group('Constructors and Getters (from num extensions)', () {
      test('should create MolarAmount from num extensions and retrieve values correctly', () {
        final maMol = 0.5.mol;
        expect(maMol.value, 0.5);
        expect(maMol.unit, MolarUnit.mole);
        expect(maMol.inMillimoles, closeTo(500.0, tolerance));
        expect(maMol.asMillimoles.value, closeTo(500.0, tolerance));
        expect(maMol.asMillimoles.unit, MolarUnit.millimole);

        final maMmol = 2500.0.millimoles; // Using alias
        expect(maMmol.value, 2500.0);
        expect(maMmol.unit, MolarUnit.millimole);
        expect(maMmol.inMoles, closeTo(2.5, tolerance));

        final maUmol = 1234.0.umol;
        expect(maUmol.value, 1234.0);
        expect(maUmol.unit, MolarUnit.micromole);
        expect(maUmol.inMoles, closeTo(0.001234, tolerance));
        expect(maUmol.inNanomoles, closeTo(1234000.0, 1e-9));
      });

      test('getValue should return correct value for same unit', () {
        const molarAmount = MolarAmount(0.025, MolarUnit.mole);
        expect(molarAmount.getValue(MolarUnit.mole), 0.025);
      });
    });

    group('Conversions between various molar units', () {
      final oneMole = 1.0.mol;
      test('1 Mole to other units', () {
        expect(oneMole.inKilomoles, closeTo(0.001, tolerance));
        expect(oneMole.inMillimoles, closeTo(1000.0, tolerance));
        expect(oneMole.inMicromoles, closeTo(1000000.0, tolerance));
        expect(oneMole.inNanomoles, closeTo(1.0e9, 1e-6));
        expect(oneMole.inPicomoles, closeTo(1.0e12, tolerance));
      });

      final oneKiloMole = 1.0.kmol;
      test('1 Kilomole to moles', () {
        expect(oneKiloMole.inMoles, closeTo(1000.0, tolerance));
      });

      final oneMilliMole = 1.0.mmol;
      test('1 Millimole to micromoles and moles', () {
        expect(oneMilliMole.inMicromoles, closeTo(1000.0, tolerance));
        expect(oneMilliMole.inMoles, closeTo(0.001, tolerance));
      });

      final oneNanoMole = 123.0.nmol;
      test('123 Nanomoles to picomoles and micromoles', () {
        expect(oneNanoMole.inPicomoles, closeTo(123000.0, 1e-10));
        expect(oneNanoMole.inMicromoles, closeTo(0.123, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new MolarAmount object with converted value and unit', () {
        final maMmol = 1500.0.mmol;
        final maMol = maMmol.convertTo(MolarUnit.mole);

        expect(maMol.unit, MolarUnit.mole);
        expect(maMol.value, closeTo(1.5, tolerance));
        expect(maMmol.unit, MolarUnit.millimole); // Original should be unchanged
        expect(maMmol.value, 1500.0);
      });

      test('convertTo same unit should return same instance (immutable optimization)', () {
        final ma1 = 0.1.mol;
        final ma2 = ma1.convertTo(MolarUnit.mole);
        expect(identical(ma1, ma2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final ma1Mol = 1.0.mol;
      final ma1000Mmol = 1000.0.mmol;
      final ma999Mmol = 999.0.mmol;
      final ma0_1Kmol = 0.1.kmol; // 100 mol
      final ma0_0001Kmol = 0.0001.kmol; // 0.1 mol

      test('should correctly compare molar amounts of different units', () {
        expect(ma1Mol.compareTo(ma999Mmol), greaterThan(0)); // 1mol > 999mmol
        expect(ma999Mmol.compareTo(ma1Mol), lessThan(0)); // 999mmol < 1mol
        expect(ma1Mol.compareTo(ma1000Mmol), 0); // 1mol == 1000mmol

        expect(ma1Mol.compareTo(ma0_1Kmol), lessThan(0)); // 1mol < 100mol
        expect(ma1Mol.compareTo(ma0_0001Kmol), greaterThan(0)); // 1mol > 0.1mol
      });

      test('should return 0 for equal molar amounts in different units', () {
        final maInUmol = 1000000.0.umol; // 1 mol in micromoles
        expect(ma1Mol.compareTo(maInUmol), 0);
      });
    });

    group('Equality (operator ==) and HashCode', () {
      test('should be equal for same value and unit', () {
        const ma1 = MolarAmount(0.05, MolarUnit.mole);
        const ma2 = MolarAmount(0.05, MolarUnit.mole);
        expect(ma1 == ma2, isTrue);
        expect(ma1.hashCode == ma2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const ma1 = MolarAmount(0.05, MolarUnit.mole);
        const ma2Diffval = MolarAmount(0.051, MolarUnit.mole);
        const ma3Diffunit = MolarAmount(0.05, MolarUnit.millimole);
        const ma4Diffvalandunit = MolarAmount(1.0, MolarUnit.kilomole);

        expect(ma1 == ma2Diffval, isFalse);
        expect(ma1 == ma3Diffunit, isFalse);
        expect(ma1 == ma4Diffvalandunit, isFalse);

        expect(ma1.hashCode == ma2Diffval.hashCode, isFalse);
        expect(ma1.hashCode == ma3Diffunit.hashCode, isFalse);
      });

      test('equality is strict, 1.mol is not equal to 1000.mmol', () {
        final oneMol = 1.mol;
        final thousandMmol = 1000.mmol;
        expect(oneMol == thousandMmol, isFalse);
        expect(oneMol.compareTo(thousandMmol), 0);
      });
    });

    group('toString() (basic check, formatting is in Quantity class)', () {
      test('should return formatted string with default non-breaking space', () {
        expect(0.25.mol.toString(), '0.25\u00A0mol');
        expect(123.micromoles.toString(), '123.0\u00A0¬µmol'); // Note ¬µ symbol
        expect(
          1.5e-9.nmol.toString(),
          '1.5e-9\u00A0nmol',
        ); // Scientific notation from double.toString()
      });
    });

    group('Round Trip Conversions (thorough)', () {
      const testValue = 0.0123456789;

      // Test all units via Mole (the base for MolarUnit)
      for (final unit in MolarUnit.values) {
        test('Round trip ${unit.symbol} <-> mol', () {
          testRoundTrip(
            unit,
            MolarUnit.mole,
            testValue,
            tol: (unit == MolarUnit.mole) ? tolerance : tolerance, // Use high precision always
          );
        });
      }

      // Test some other common pairs
      test('Round trip mmol <-> ¬µmol', () {
        testRoundTrip(MolarUnit.millimole, MolarUnit.micromole, 0.5);
      });
      test('Round trip nmol <-> pmol', () {
        testRoundTrip(MolarUnit.nanomole, MolarUnit.picomole, 0.005);
      });
      test('Round trip mol <-> kmol', () {
        testRoundTrip(MolarUnit.mole, MolarUnit.kilomole, 2500.0);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final maZeroMol = 0.0.mol;
        for (final unit in MolarUnit.values) {
          expect(maZeroMol.getValue(unit), 0.0, reason: '0 mol to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with very small and large values', () {
        final verySmall = 1.0e-15.mol; // femtomoles range
        expect(verySmall.inPicomoles, closeTo(0.001, tolerance));

        final veryLarge = 1.0e6.mol; // megamoles range
        expect(veryLarge.inKilomoles, closeTo(1000.0, tolerance));
      });
    });

    group('Arithmetic Operators for MolarAmount', () {
      final ma1mol = 1.0.mol;
      final ma2mol = 2.0.mol;
      final ma500mmol = 500.mmol; // 0.5 mol
      final ma100umol = 100.umol; // 0.0001 mol

      // Operator +
      test('operator + combines molar amounts, result in unit of left operand', () {
        final sum1 = ma2mol + ma1mol;
        expect(sum1.value, closeTo(3.0, defaultTolerance));
        expect(sum1.unit, MolarUnit.mole);

        final sum2 = ma1mol + ma500mmol; // 1mol + 0.5mol = 1.5mol
        expect(sum2.value, closeTo(1.5, defaultTolerance));
        expect(sum2.unit, MolarUnit.mole);

        final sum3 = ma500mmol + ma1mol; // 500mmol + 1000mmol = 1500mmol
        expect(sum3.value, closeTo(1500.0, defaultTolerance));
        expect(sum3.unit, MolarUnit.millimole);

        final sum4 = ma1mol + ma100umol; // 1mol + 0.0001mol
        expect(sum4.value, closeTo(1.0 + 0.0001, tolerance));
        expect(sum4.unit, MolarUnit.mole);
      });

      // Operator -
      test('operator - subtracts molar amounts, result in unit of left operand', () {
        final diff1 = ma2mol - ma1mol;
        expect(diff1.value, closeTo(1.0, defaultTolerance));
        expect(diff1.unit, MolarUnit.mole);

        final diff2 = ma1mol - ma500mmol; // 1mol - 0.5mol = 0.5mol
        expect(diff2.value, closeTo(0.5, defaultTolerance));
        expect(diff2.unit, MolarUnit.mole);

        final diff3 = ma1mol - ma100umol; // 1mol - 0.0001mol
        expect(diff3.value, closeTo(1.0 - 0.0001, tolerance));
        expect(diff3.unit, MolarUnit.mole);
      });

      // Operator * (scalar)
      test('operator * scales molar amount by a scalar', () {
        final scaled1 = ma2mol * 3.5;
        expect(scaled1.value, closeTo(7.0, defaultTolerance));
        expect(scaled1.unit, MolarUnit.mole);

        final scaled2 = ma500mmol * 0.1;
        expect(scaled2.value, closeTo(50.0, defaultTolerance));
        expect(scaled2.unit, MolarUnit.millimole);
      });

      // Operator / (scalar)
      test('operator / scales molar amount by a scalar', () {
        final scaled1 = ma2mol / 4.0;
        expect(scaled1.value, closeTo(0.5, defaultTolerance));
        expect(scaled1.unit, MolarUnit.mole);

        final scaled2 = ma1mol / 0.01;
        expect(scaled2.value, closeTo(100.0, defaultTolerance));
        expect(scaled2.unit, MolarUnit.mole);

        expect(() => ma1mol / 0.0, throwsArgumentError, reason: 'Division by zero should throw');
      });

      test('operator chaining preserves immutability', () {
        final initialAmount = 0.1.mol;
        final maAdd = initialAmount + 50.mmol; // 0.1mol + 0.05mol = 0.15mol
        final maMul = maAdd * 10.0; // 0.15mol * 10 = 1.5mol
        final maSub = maMul - 100000.umol; // 1.5mol - 0.1mol = 1.4mol

        expect(initialAmount.value, 0.1); // Original unchanged
        expect(initialAmount.unit, MolarUnit.mole);

        expect(maAdd.value, closeTo(0.15, tolerance));
        expect(maAdd.unit, MolarUnit.mole);

        expect(maMul.value, closeTo(1.5, tolerance));
        expect(maMul.unit, MolarUnit.mole);

        final expectedMaSubVal = 1.5 - 100000.0.umol.getValue(MolarUnit.mole);
        expect(maSub.value, closeTo(expectedMaSubVal, tolerance));
        expect(maSub.unit, MolarUnit.mole);
      });
    });
  });
}

<!-- END FILE: [v0.2.0] test/units/molar_test.dart -->

<!-- BEGIN FILE: [v0.2.0] test/units/pressure_test.dart -->
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  const tolerance = 1e-9; // Tolerance for double comparisons

  group('Pressure', () {
    // Helper for round trip tests
    void testRoundTrip(
      PressureUnit initialUnit,
      PressureUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final p1 = Pressure(initialValue, initialUnit);
      final p2 = p1.convertTo(intermediateUnit);
      final p3 = p2.convertTo(initialUnit);
      expect(
        p3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Pressure from num extensions and retrieve values', () {
        final p1 = 101325.0.pa;
        expect(p1.value, 101325.0);
        expect(p1.unit, PressureUnit.pascal);
        expect(p1.inAtm, closeTo(1.0, 1e-9));

        final p2 = 1.0.atm;
        expect(p2.value, 1.0);
        expect(p2.unit, PressureUnit.atmosphere);
        expect(p2.inPa, closeTo(101325.0, 1e-9));

        final p3 = 30.0.psi;
        expect(p3.inPsi, 30.0);
        expect(p3.unit, PressureUnit.psi);

        final p4 = 1000.mbar; // millibars
        expect(p4.inMbar, 1000.0);
        expect(p4.inHPa, closeTo(1000.0, 1e-9)); // mbar and hPa are often same scale
        expect(p4.inBar, closeTo(1.0, 1e-9));
      });

      test('getValue should return correct value for same unit', () {
        const p = Pressure(15, PressureUnit.psi);
        expect(p.getValue(PressureUnit.psi), 15.0);
      });

      test('getValue for all units from Pascal base', () {
        final p = 100000.0.pa; // 1 bar
        expect(p.inPa, 100000.0);
        expect(p.inAtm, closeTo(100000.0 / 101325.0, 1e-7));
        expect(p.inBar, closeTo(1.0, 1e-9));
        expect(p.inPsi, closeTo(100000.0 / 6894.757293168361, 1e-7));
        expect(p.inTorr, closeTo(100000.0 / (101325.0 / 760.0), 1e-7));
        expect(p.inMmHg, closeTo(100000.0 / (101325.0 / 760.0), 1e-7));
        expect(
          p.inInHg,
          closeTo(
            100000.0 / ((101325.0 / 760.0) * 25.4),
            1e-6,
          ),
        ); // Higher tolerance due to more factors
        expect(p.inKPa, closeTo(100.0, 1e-9));
        expect(p.inHPa, closeTo(1000.0, 1e-9));
        expect(p.inMbar, closeTo(1000.0, 1e-9));
        expect(p.inCmH2O, closeTo(100000.0 / 98.0665, 1e-7));
        expect(p.inInH2O, closeTo(100000.0 / 249.08891, 1e-7));
      });
    });

    group('Conversions', () {
      final oneAtm = 1.0.atm;

      test('1 atm to Pascals', () {
        expect(oneAtm.inPa, closeTo(101325.0, 1e-9));
      });
      test('1 atm to Bars', () {
        expect(oneAtm.inBar, closeTo(1.01325, 1e-9));
      });
      test('1 atm to PSI', () {
        expect(oneAtm.inPsi, closeTo(14.695948775513, 1e-7));
      });
      test('1 atm to Torr (mmHg)', () {
        expect(oneAtm.inTorr, closeTo(760.0, 1e-9));
        expect(oneAtm.inMmHg, closeTo(760.0, 1e-9));
      });
      test('1 atm to Inches of Mercury', () {
        expect(oneAtm.inInHg, closeTo(760.0 / 25.4, 1e-7));
      });
      test('1 atm to Kilopascals', () {
        expect(oneAtm.inKPa, closeTo(101.325, 1e-9));
      });
      test('1 atm to Hectopascals/Millibars', () {
        expect(oneAtm.inHPa, closeTo(1013.25, 1e-9));
        expect(oneAtm.inMbar, closeTo(1013.25, 1e-9));
      });
      test('1 atm to cmH2O', () {
        expect(oneAtm.inCmH2O, closeTo(101325.0 / 98.0665, 1e-7));
      });
      test('1 atm to inH2O', () {
        expect(oneAtm.inInH2O, closeTo(101325.0 / 249.08891, 1e-7));
      });

      // Test specific tricky conversions
      test('PSI to Bar', () {
        final pPsi = 29.0.psi; // Approx 1.99948 bar
        expect(pPsi.inBar, closeTo(29.0 * 6894.757293168361 / 100000.0, 1e-7));
      });

      test('Bar to PSI', () {
        final pBar = 2.0.bar; // Approx 29.0075 psi
        expect(pBar.inPsi, closeTo(2.0 * 100000.0 / 6894.757293168361, 1e-7));
      });

      test('inH2O to Pa', () {
        final pInH2O = 10.0.inH2O;
        expect(pInH2O.inPa, closeTo(10.0 * 249.08891, 1e-7));
      });
    });

    group('convertTo method', () {
      test('should return new Pressure object with converted value and unit', () {
        final pPsi = 29.0.psi;
        final pBar = pPsi.convertTo(PressureUnit.bar);
        expect(pBar.unit, PressureUnit.bar);
        expect(pBar.value, closeTo(pPsi.inBar, 1e-9));
        expect(pPsi.unit, PressureUnit.psi); // Original should be unchanged
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final p1 = 10.0.pa;
        final p2 = p1.convertTo(PressureUnit.pascal);
        expect(identical(p1, p2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final pBar = 1.0.bar; // 100000 Pa
      final pPsiSlightlyLess = 14.5.psi; // 14.5 * 6894.757... ‚âà 99973.98 Pa
      final pPsiSlightlyMore = 14.6.psi; // 14.6 * 6894.757... ‚âà 100663.4 Pa
      final pAtm = 1.0.atm; // 101325 Pa

      test('should correctly compare pressures of different units', () {
        expect(pBar.compareTo(pPsiSlightlyLess), greaterThan(0)); // 1 bar > 14.5 psi
        expect(pPsiSlightlyLess.compareTo(pBar), lessThan(0)); // 14.5 psi < 1 bar
        expect(pBar.compareTo(pPsiSlightlyMore), lessThan(0)); // 1 bar < 14.6 psi
        expect(pBar.compareTo(pAtm), lessThan(0)); // 1 bar < 1 atm
      });

      test('should return 0 for equal pressures in different units', () {
        final pPascals = 100000.0.pa;
        final pMillibars = 1000.0.mbar;
        expect(pBar.compareTo(pPascals), 0);
        expect(pPascals.compareTo(pBar), 0);
        expect(pBar.compareTo(pMillibars), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const p1 = Pressure(10, PressureUnit.bar);
        const p2 = Pressure(10, PressureUnit.bar);
        expect(p1 == p2, isTrue);
        expect(p1.hashCode == p2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const p1 = Pressure(10, PressureUnit.bar);
        const p2 = Pressure(10.1, PressureUnit.bar);
        const p3 = Pressure(10, PressureUnit.psi);
        expect(p1 == p2, isFalse);
        expect(p1 == p3, isFalse);
        expect(p1.hashCode == p2.hashCode, isFalse); // Likely false
        expect(p1.hashCode == p3.hashCode, isFalse); // Likely false
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(14.7.psi.toString(), '14.7¬†psi');
        expect(1013.25.mbar.toString(), '1013.25¬†mbar');
        expect(1.0.atm.toString(), '1.0¬†atm');
        expect(25.0.cmH2O.toString(), '25.0¬†cmH‚ÇÇO');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 123.456;
      const highTolerance = 1e-6; // For chains of conversions

      // Test all units via Pascal
      for (final unit in PressureUnit.values) {
        test('Round trip ${unit.symbol} <-> Pa', () {
          testRoundTrip(
            unit,
            PressureUnit.pascal,
            testValue,
            tolerance: (unit == PressureUnit.pascal) ? 1e-9 : highTolerance,
          );
        });
      }

      // Test some other common pairs
      test('Round trip psi <-> bar', () {
        testRoundTrip(PressureUnit.psi, PressureUnit.bar, testValue, tolerance: highTolerance);
      });
      test('Round trip atm <-> mmHg', () {
        testRoundTrip(
          PressureUnit.atmosphere,
          PressureUnit.millimeterOfMercury,
          2.5,
          tolerance: highTolerance,
        );
      });
      test('Round trip kPa <-> psi', () {
        testRoundTrip(PressureUnit.kilopascal, PressureUnit.psi, 350, tolerance: highTolerance);
      });
      test('Round trip inH2O <-> cmH2O', () {
        testRoundTrip(
          PressureUnit.inchOfWater,
          PressureUnit.centimeterOfWater,
          10,
          tolerance: highTolerance,
        );
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final pZero = 0.0.pa;
        for (final unit in PressureUnit.values) {
          expect(pZero.getValue(unit), 0.0, reason: '0 Pa to ${unit.symbol} should be 0');
        }
        final pPsiZero = 0.0.psi;
        for (final unit in PressureUnit.values) {
          expect(pPsiZero.getValue(unit), 0.0, reason: '0 psi to ${unit.symbol} should be 0');
        }
      });

      test('Conversion with negative value (if meaningful for pressure, though usually positive)',
          () {
        // Pressure is typically positive, but the math should still work.
        final pNegative = (-100.0).pa;
        expect(pNegative.inBar, closeTo(-0.001, 1e-9));
      });
    });

    group('Arithmetic Operators for Pressure', () {
      final p1Bar = 1.0.bar;
      final p2Bar = 2.0.bar;
      final p10Psi = 10.psi; // approx 0.689 bar

      // Operator +
      test('operator + combines pressures', () {
        final sum1 = p2Bar + p1Bar;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, PressureUnit.bar);

        final sum2 = p1Bar + p10Psi; // 1 bar + ~0.689 bar
        final expectedSum2Value = 1.0 + p10Psi.getValue(PressureUnit.bar);
        expect(sum2.value, closeTo(expectedSum2Value, tolerance));
        expect(sum2.unit, PressureUnit.bar);

        final sum3 = p10Psi + p1Bar; // 10 psi + (1 bar in psi)
        final expectedSum3Value = 10.0 + p1Bar.getValue(PressureUnit.psi);
        expect(sum3.value, closeTo(expectedSum3Value, tolerance));
        expect(sum3.unit, PressureUnit.psi);
      });

      // Operator -
      test('operator - subtracts pressures', () {
        final diff1 = p2Bar - p1Bar;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, PressureUnit.bar);

        final diff2 = p1Bar - p10Psi; // 1 bar - ~0.689 bar
        final expectedDiff2Value = 1.0 - p10Psi.getValue(PressureUnit.bar);
        expect(diff2.value, closeTo(expectedDiff2Value, tolerance));
        expect(diff2.unit, PressureUnit.bar);
      });

      // Operator * (scalar)
      test('operator * scales pressure by a scalar', () {
        final scaled = p2Bar * 1.5;
        expect(scaled.value, closeTo(3.0, tolerance));
        expect(scaled.unit, PressureUnit.bar);
      });

      // Operator / (scalar)
      test('operator / scales pressure by a scalar', () {
        final scaled = p2Bar / 4.0;
        expect(scaled.value, closeTo(0.5, tolerance));
        expect(scaled.unit, PressureUnit.bar);
        expect(() => p1Bar / 0.0, throwsArgumentError);
      });
    });
  });
}

<!-- END FILE: [v0.2.0] test/units/pressure_test.dart -->

<!-- BEGIN FILE: [v0.2.0] test/units/temperature_test.dart -->
import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('Temperature', () {
    const tolerance = 1e-9; // Tolerance for double comparisons

    group('Constructors and Getters', () {
      test('should create Temperature from num extensions and retrieve values', () {
        final t1 = 25.0.celsius;
        expect(t1.value, 25.0);
        expect(t1.unit, TemperatureUnit.celsius);
        expect(t1.inFahrenheit, closeTo(77.0, tolerance));

        final t2 = 0.0.kelvin;
        expect(t2.value, 0.0);
        expect(t2.unit, TemperatureUnit.kelvin);
        expect(t2.inCelsius, closeTo(-273.15, tolerance));

        final t3 = 32.fahrenheit;
        expect(t3.value, 32.0);
        expect(t3.unit, TemperatureUnit.fahrenheit);
        expect(t3.inCelsius, closeTo(0.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const temp = Temperature(100, TemperatureUnit.celsius);
        expect(temp.getValue(TemperatureUnit.celsius), 100.0);
      });

      test('Unit.factorTo should throw UnsupportedError for TemperatureUnit', () {
        expect(
          // ignore: invalid_use_of_protected_member : protected member access
          () => TemperatureUnit.celsius.factorTo(TemperatureUnit.fahrenheit),
          throwsUnsupportedError,
        );
        expect(
          // ignore: invalid_use_of_protected_member : protected member access
          () => TemperatureUnit.kelvin.factorTo(TemperatureUnit.celsius),
          throwsUnsupportedError,
        );
      });
    });

    group('Conversions', () {
      // Celsius to others
      test('0¬∞C to Fahrenheit and Kelvin', () {
        final tempC = 0.0.celsius;
        expect(tempC.inFahrenheit, closeTo(32.0, tolerance));
        expect(tempC.inKelvin, closeTo(273.15, tolerance));
      });
      test('100¬∞C to Fahrenheit and Kelvin', () {
        final tempC = 100.0.celsius;
        expect(tempC.inFahrenheit, closeTo(212.0, tolerance));
        expect(tempC.inKelvin, closeTo(373.15, tolerance));
      });
      test('-40¬∞C to Fahrenheit and Kelvin', () {
        final tempC = (-40.0).celsius;
        expect(tempC.inFahrenheit, closeTo(-40.0, tolerance));
        expect(tempC.inKelvin, closeTo(233.15, tolerance));
      });

      // Kelvin to others
      test('0K to Celsius and Fahrenheit', () {
        final tempK = 0.0.kelvin;
        expect(tempK.inCelsius, closeTo(-273.15, tolerance));
        // (-273.15 * 1.8) + 32 = -491.67 + 32 = -459.67
        expect(tempK.inFahrenheit, closeTo(-459.67, tolerance));
      });
      test('273.15K to Celsius and Fahrenheit', () {
        final tempK = 273.15.kelvin;
        expect(tempK.inCelsius, closeTo(0.0, tolerance));
        expect(tempK.inFahrenheit, closeTo(32.0, tolerance));
      });

      // Fahrenheit to others
      test('32¬∞F to Celsius and Kelvin', () {
        final tempF = 32.0.fahrenheit;
        expect(tempF.inCelsius, closeTo(0.0, tolerance));
        expect(tempF.inKelvin, closeTo(273.15, tolerance));
      });
      test('212¬∞F to Celsius and Kelvin', () {
        final tempF = 212.0.fahrenheit;
        expect(tempF.inCelsius, closeTo(100.0, tolerance));
        expect(tempF.inKelvin, closeTo(373.15, tolerance));
      });
      test('-40¬∞F to Celsius and Kelvin', () {
        final tempF = (-40.0).fahrenheit;
        expect(tempF.inCelsius, closeTo(-40.0, tolerance));
        expect(tempF.inKelvin, closeTo(233.15, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Temperature object with converted value and unit', () {
        final tempC = 20.0.celsius;
        final tempF = tempC.convertTo(TemperatureUnit.fahrenheit);

        expect(tempF.unit, TemperatureUnit.fahrenheit);
        expect(tempF.value, closeTo(68.0, tolerance));
        expect(tempC.unit, TemperatureUnit.celsius); // Original should be unchanged
        expect(tempC.value, 20.0);
      });

      test('convertTo same unit should return same instance (or equal if optimized)', () {
        final t1 = 10.0.kelvin;
        final t2 = t1.convertTo(TemperatureUnit.kelvin);
        expect(identical(t1, t2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final t0c = 0.0.celsius;
      final t32f = 32.0.fahrenheit;
      final t273k = 273.15.kelvin;

      final t10c = 10.0.celsius;
      final t50f = 50.0.fahrenheit; // 10¬∞C

      test('should correctly compare temperatures of different units', () {
        expect(t0c.compareTo(t32f), 0); // 0¬∞C == 32¬∞F
        expect(t0c.compareTo(t273k), 0); // 0¬∞C == 273.15K
        expect(t32f.compareTo(t273k), 0); // 32¬∞F == 273.15K

        expect(t10c.compareTo(t0c), greaterThan(0)); // 10¬∞C > 0¬∞C
        expect(t50f.compareTo(t32f), greaterThan(0)); // 50¬∞F > 32¬∞F (10¬∞C > 0¬∞C)
        expect(t10c.compareTo(t32f), greaterThan(0)); // 10¬∞C > 32¬∞F (0¬∞C)
        expect(t0c.compareTo(t10c), lessThan(0));
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const t1 = Temperature(25, TemperatureUnit.celsius);
        const t2 = Temperature(25, TemperatureUnit.celsius);
        expect(t1 == t2, isTrue);
        expect(t1.hashCode == t2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const t1 = Temperature(25, TemperatureUnit.celsius);
        const t2 = Temperature(25.1, TemperatureUnit.celsius);
        const t3 = Temperature(25, TemperatureUnit.fahrenheit);
        expect(t1 == t2, isFalse);
        expect(t1 == t3, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(25.0.celsius.toString(), '25.0¬†¬∞C');
        expect(0.0.kelvin.toString(), '0.0¬†K');
        expect(77.fahrenheit.toString(), '77.0¬†¬∞F');
      });
    });

    group('Round Trip Conversions (via direct methods)', () {
      const initialCelsius = 23.45;
      const initialKelvin = 300.12;
      const initialFahrenheit = 68.78;

      test('Celsius round trips', () {
        final c1 = initialCelsius.celsius;
        expect(
          c1.convertTo(TemperatureUnit.fahrenheit).convertTo(TemperatureUnit.celsius).value,
          closeTo(initialCelsius, tolerance),
        );
        expect(
          c1.convertTo(TemperatureUnit.kelvin).convertTo(TemperatureUnit.celsius).value,
          closeTo(initialCelsius, tolerance),
        );
      });

      test('Kelvin round trips', () {
        final k1 = initialKelvin.kelvin;
        expect(
          k1.convertTo(TemperatureUnit.celsius).convertTo(TemperatureUnit.kelvin).value,
          closeTo(initialKelvin, tolerance),
        );
        expect(
          k1.convertTo(TemperatureUnit.fahrenheit).convertTo(TemperatureUnit.kelvin).value,
          closeTo(initialKelvin, tolerance),
        );
      });

      test('Fahrenheit round trips', () {
        final f1 = initialFahrenheit.fahrenheit;
        expect(
          f1.convertTo(TemperatureUnit.celsius).convertTo(TemperatureUnit.fahrenheit).value,
          closeTo(initialFahrenheit, tolerance),
        );
        expect(
          f1.convertTo(TemperatureUnit.kelvin).convertTo(TemperatureUnit.fahrenheit).value,
          closeTo(initialFahrenheit, tolerance),
        );
      });
    });
    group('Arithmetic Operators for Temperature', () {
      final t20C = 20.0.celsius;
      final t10C = 10.0.celsius;
      final t50F = 50.0.fahrenheit; // 10 ¬∞C
      final t283K = 283.15.kelvin; // 10 ¬∞C

      // Operator - (Temperature) -> double (difference)
      test('operator - calculates temperature difference as double', () {
        final diffC = t20C - t10C; // 20¬∞C - 10¬∞C = 10 C¬∞
        expect(diffC, closeTo(10.0, tolerance));

        final diffCFromF = t20C - t50F; // 20¬∞C - 10¬∞C = 10 C¬∞
        expect(diffCFromF, closeTo(10.0, tolerance));

        // Corrected from previous state where 'diffF_direct' was not used:
        // Original operation: t50F - t20C.convertTo(TemperatureUnit.fahrenheit)
        // This is 50¬∞F - (20¬∞C as ¬∞F which is 68¬∞F) = -18 F¬∞
        final temp20CAsFahrenheit = t20C.convertTo(TemperatureUnit.fahrenheit);
        final diffF = t50F - temp20CAsFahrenheit;
        expect(
          diffF,
          closeTo(-18.0, tolerance),
          reason: '50F - 20C (as F) should be -18 F difference',
        );

        final diffkOperation = t283K - t20C; // 283.15K (10¬∞C) - 20¬∞C (converted to K)
        // 283.15K - (20 + 273.15)K = 283.15K - 293.15K = -10.0
        expect(diffkOperation, closeTo(-10.0, tolerance));

        // This was the variable causing the warning. Let's ensure it's used.
        // It will hold the same value as diffK_operation in this case.
        final diffkVariable = t283K - t20C;
        expect(
          diffkVariable,
          closeTo(-10.0, tolerance),
          reason: 'Variable diffK should hold -10.0',
        );

        final zeroDiff = t10C - t50F; // 10C - 10C (50F)
        expect(zeroDiff, closeTo(0.0, tolerance));
      });

      // Operator / (Temperature) -> double (ratio)
      test('operator / divides temperature by another, returning double ratio', () {
        // Note: Ratios of Celsius or Fahrenheit are generally not physically meaningful.
        // Kelvin should be used for meaningful ratios. Test calculates as per implementation.

        final t200K = 200.0.kelvin;
        final t100K = 100.0.kelvin;
        final ratioK = t200K / t100K;
        expect(ratioK, closeTo(2.0, tolerance));

        final t10CVal = 10.0.celsius; // Not 283.15K
        final t20CVal = 20.0.celsius; // Not 293.15K
        // Ratio based on C values: 20/10 = 2.0. If converted to K first, result would be different.
        // The implementation converts the 'other' to 'this.unit'
        final ratioC = t20CVal / t10CVal;
        expect(ratioC, closeTo(2.0, tolerance));

        // 20 C / 50 F => 20 C / 10 C (as 50F is 10C)
        final ratioCF = t20CVal / 50.0.fahrenheit;
        expect(ratioCF, closeTo(2.0, tolerance));

        expect(
          () => t20C / 0.0.celsius,
          throwsArgumentError,
          reason: 'Should throw on division by zero magnitude if dividend is non-zero',
        );
        expect(0.0.celsius / 0.0.celsius, isNaN, reason: '0.0/0.0 should be NaN');
        expect(0.0.kelvin / 0.0.kelvin, isNaN);

        final tZeroKelvin = 0.0.kelvin;
        final tNonZeroKelvin = 10.0.kelvin;
        expect(() => tNonZeroKelvin / tZeroKelvin, throwsArgumentError);
      });

      test('operator + is not defined for Temperature + Temperature', () {
        // This is a check that the operator isn't inadvertently available.
        // Since Dart doesn't allow removing operators via inheritance easily
        // without an abstract method in the base or a linter rule,
        // we just ensure it's not implemented directly in Temperature.
        // If it were inherited from a base that defined it, this test would need adjustment.
        // For now, it's just a conceptual check.
        final dynamic tempA = 10.celsius;
        final dynamic tempB = 20.celsius;
        // Check if calling the '+' operator results in an error,
        // typically NoSuchMethodError if not defined, or TypeError in some dynamic contexts.
        expect(
          // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
          () => tempA + tempB,
          throwsA(
            anyOf(
              isA<NoSuchMethodError>(),
              isA<TypeError>(),
              // Falls eine Basisklasse es doch implementieren w√ºrde und Temperature es blockiert:
              // isA<UnsupportedError>()
            ),
          ),
        );
      });

      test('operator * (scalar) is not defined for Temperature', () {
        final dynamic tempA = 10.celsius;
        // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
        expect(() => tempA * 2.0, throwsA(anyOf(isA<NoSuchMethodError>(), isA<TypeError>())));
      });
      test('operator / (scalar) is not defined for Temperature', () {
        final dynamic tempA = 10.celsius;
        // ignore: avoid_dynamic_calls : Using dynamic to simulate a missing operator
        expect(() => tempA / 2.0, throwsA(anyOf(isA<NoSuchMethodError>(), isA<TypeError>())));
      });
    });
  });
}

<!-- END FILE: [v0.2.0] test/units/temperature_test.dart -->

<!-- BEGIN FILE: [v0.2.0] test/units/time_test.dart -->
// ignore_for_file: prefer_int_literals // All constants are doubles for precision.

import 'package:quantify/quantify.dart';
import 'package:test/test.dart';

void main() {
  group('Time', () {
    const tolerance = 1e-9;

    // Helper for round trip tests
    void testRoundTrip(
      TimeUnit initialUnit,
      TimeUnit intermediateUnit,
      double initialValue, {
      double tolerance = 1e-9,
    }) {
      final t1 = Time(initialValue, initialUnit);
      final t2 = t1.convertTo(intermediateUnit);
      final t3 = t2.convertTo(initialUnit);
      expect(
        t3.value,
        closeTo(initialValue, tolerance),
        reason:
            '${initialUnit.symbol} -> ${intermediateUnit.symbol} -> ${initialUnit.symbol} failed for $initialValue',
      );
    }

    group('Constructors and Getters', () {
      test('should create Time from num extensions and retrieve values', () {
        final t1 = 60.0.seconds;
        expect(t1.value, 60.0);
        expect(t1.unit, TimeUnit.second);
        expect(t1.inMinutes, closeTo(1.0, tolerance));

        final t2 = 1.5.hours;
        expect(t2.value, 1.5);
        expect(t2.unit, TimeUnit.hour);
        expect(t2.inMinutes, closeTo(90.0, tolerance));
        expect(t2.inSeconds, closeTo(1.5 * 3600.0, tolerance));

        final t3 = 500.milliseconds;
        expect(t3.inSeconds, closeTo(0.5, tolerance));

        final t4 = 1.days;
        expect(t4.inHours, closeTo(24.0, tolerance));
      });

      test('getValue should return correct value for same unit', () {
        const t = Time(25.0, TimeUnit.minute);
        expect(t.getValue(TimeUnit.minute), 25.0);
      });

      test('getValue for all units from Second base', () {
        final t = 3600.0.seconds; // 1 hour
        expect(t.inSeconds, 3600.0);
        expect(t.inMilliseconds, closeTo(3600.0 * 1000.0, tolerance));
        expect(t.inMinutes, closeTo(60.0, tolerance));
        expect(t.inHours, closeTo(1.0, tolerance));
        expect(t.inDays, closeTo(1.0 / 24.0, tolerance));
      });
    });

    group('Conversions', () {
      final oneHour = 1.0.hours;

      test('1 hour to various units', () {
        expect(oneHour.inMinutes, closeTo(60.0, tolerance));
        expect(oneHour.inSeconds, closeTo(3600.0, tolerance));
        expect(oneHour.inMilliseconds, closeTo(3600.0 * 1000.0, tolerance));
      });

      final oneDay = 1.0.days;
      test('1 day to various units', () {
        expect(oneDay.inHours, closeTo(24.0, tolerance));
        expect(oneDay.inMinutes, closeTo(24.0 * 60.0, tolerance));
        expect(oneDay.inSeconds, closeTo(24.0 * 3600.0, tolerance));
      });

      final thirtyMinutes = 30.0.minutes;
      test('30 minutes to hours and seconds', () {
        expect(thirtyMinutes.inHours, closeTo(0.5, tolerance));
        expect(thirtyMinutes.inSeconds, closeTo(30.0 * 60.0, tolerance));
      });
    });

    group('convertTo method', () {
      test('should return new Time object with converted value and unit', () {
        final tMinutes = 90.0.minutes;
        final tHours = tMinutes.convertTo(TimeUnit.hour);
        expect(tHours.unit, TimeUnit.hour);
        expect(tHours.value, closeTo(1.5, tolerance));
        expect(tMinutes.unit, TimeUnit.minute); // Original should be unchanged
      });

      test('convertTo same unit should return same instance', () {
        final t1 = 10.0.seconds;
        final t2 = t1.convertTo(TimeUnit.second);
        expect(identical(t1, t2), isTrue);
      });
    });

    group('Comparison (compareTo)', () {
      final t1Hour = 1.0.hours;
      final t59Minutes = 59.0.minutes;
      final t61Minutes = 61.0.minutes;
      final t3600Seconds = 3600.0.seconds;

      test('should correctly compare times of different units', () {
        expect(t1Hour.compareTo(t59Minutes), greaterThan(0));
        expect(t59Minutes.compareTo(t1Hour), lessThan(0));
        expect(t1Hour.compareTo(t61Minutes), lessThan(0));
      });

      test('should return 0 for equal times in different units', () {
        expect(t1Hour.compareTo(t3600Seconds), 0);
        expect(t3600Seconds.compareTo(t1Hour), 0);
        final tPoint5Hours = 0.5.hours;
        final t30Minutes = 30.0.minutes;
        expect(tPoint5Hours.compareTo(t30Minutes), 0);
      });
    });

    group('Equality and HashCode', () {
      test('should be equal for same value and unit', () {
        const t1 = Time(10.0, TimeUnit.second);
        const t2 = Time(10.0, TimeUnit.second);
        expect(t1 == t2, isTrue);
        expect(t1.hashCode == t2.hashCode, isTrue);
      });

      test('should not be equal for different values or units', () {
        const t1 = Time(10.0, TimeUnit.second);
        const t2 = Time(10.1, TimeUnit.second);
        const t3 = Time(10.0, TimeUnit.minute);
        expect(t1 == t2, isFalse);
        expect(t1 == t3, isFalse);
      });
    });

    group('toString()', () {
      test('should return formatted string', () {
        expect(10.5.seconds.toString(), '10.5¬†s');
        expect(120.0.minutes.toString(), '120.0¬†min');
        expect(2.5.hours.toString(), '2.5¬†h');
        expect(1.days.toString(), '1.0¬†d');
      });
    });

    group('Round Trip Conversions', () {
      const testValue = 789.123;
      const highTolerance = 1e-7;

      for (final unit in TimeUnit.values) {
        test('Round trip ${unit.symbol} <-> s', () {
          testRoundTrip(
            unit,
            TimeUnit.second,
            testValue,
            tolerance: (unit == TimeUnit.second) ? 1e-9 : highTolerance,
          );
        });
      }

      test('Round trip min <-> h', () {
        testRoundTrip(TimeUnit.minute, TimeUnit.hour, 120.0, tolerance: highTolerance);
      });
      test('Round trip ms <-> s', () {
        testRoundTrip(TimeUnit.millisecond, TimeUnit.second, 2500.0, tolerance: highTolerance);
      });
    });

    group('Edge Cases', () {
      test('Conversion with zero value', () {
        final tZero = 0.0.seconds;
        for (final unit in TimeUnit.values) {
          expect(tZero.getValue(unit), 0.0, reason: '0 s to ${unit.symbol} should be 0');
        }
      });
    });

    group('Arithmetic Operators for Time', () {
      final t1Hour = 1.0.hours;
      final t2Hours = 2.0.hours;
      final t30Minutes = 30.minutes; // 0.5 hours

      // Operator +
      test('operator + combines time durations', () {
        final sum1 = t2Hours + t1Hour;
        expect(sum1.value, closeTo(3.0, tolerance));
        expect(sum1.unit, TimeUnit.hour);

        final sum2 = t1Hour + t30Minutes; // 1h + 0.5h = 1.5h
        expect(sum2.value, closeTo(1.5, tolerance));
        expect(sum2.unit, TimeUnit.hour);

        final sum3 = t30Minutes + t1Hour; // 30min + 60min = 90min
        expect(sum3.value, closeTo(90.0, tolerance));
        expect(sum3.unit, TimeUnit.minute);
      });

      // Operator -
      test('operator - subtracts time durations', () {
        final diff1 = t2Hours - t1Hour;
        expect(diff1.value, closeTo(1.0, tolerance));
        expect(diff1.unit, TimeUnit.hour);

        final diff2 = t1Hour - t30Minutes; // 1h - 0.5h = 0.5h
        expect(diff2.value, closeTo(0.5, tolerance));
        expect(diff2.unit, TimeUnit.hour);
      });

      // Operator * (scalar)
      test('operator * scales time duration by a scalar', () {
        final scaled = t2Hours * 0.5;
        expect(scaled.value, closeTo(1.0, tolerance));
        expect(scaled.unit, TimeUnit.hour);
      });

      // Operator / (scalar)
      test('operator / scales time duration by a scalar', () {
        final scaled = t2Hours / 2.0;
        expect(scaled.value, closeTo(1.0, tolerance));
        expect(scaled.unit, TimeUnit.hour);
        expect(() => t1Hour / 0.0, throwsArgumentError);
      });
    });
  });
}

<!-- END FILE: [v0.2.0] test/units/time_test.dart -->

---
Generated with llmifier v0.2.2
Created by Software Engineering Philipp Gerber
Repository: https://github.com/PhilippHGerber/llmifier
Package: https://pub.dev/packages/llmifier
